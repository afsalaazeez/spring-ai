{
  "org.springframework.ai.chat.memory.cassandra" : {
    "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemory.java" : {
      "imports" : [ {
        "dereferencedParts" : [ ],
        "name" : "java.time.Instant"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.ArrayList"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.List"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.concurrent.atomic.AtomicLong"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.cql.BoundStatementBuilder"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.cql.PreparedStatement"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.cql.Row"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.QueryBuilder"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.delete.Delete"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.delete.DeleteSelection"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.insert.InsertInto"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.insert.RegularInsert"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.select.Select"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.shaded.guava.common.base.Preconditions"
      }, {
        "dereferencedParts" : [ {
          "name" : "ChatMemory",
          "comments" : "The ChatMemory interface represents a storage for chat conversation history. It\nprovides methods to add messages to a conversation, retrieve messages from a\nconversation, and clear the conversation history.",
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ ],
          "constructors" : [ ],
          "extends" : [ ],
          "implements" : [ ],
          "nestedClass" : null,
          "accessSpecifier" : "public",
          "records" : null,
          "imports" : [ {
            "dereferencedParts" : [ ],
            "name" : "java.util.List"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.chat.messages.Message"
          } ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/chat/memory/ChatMemory.java",
        "name" : "org.springframework.ai.chat.memory.ChatMemory"
      }, {
        "dereferencedParts" : [ ],
        "name" : "org.springframework.ai.chat.memory.cassandra.CassandraChatMemoryConfig.SchemaColumn"
      }, {
        "dereferencedParts" : [ {
          "name" : "AssistantMessage",
          "comments" : "Lets the generative know the content was generated as a response to the user. This role\nindicates messages that the generative has previously generated in the conversation. By\nincluding assistant messages in the series, you provide context to the generative about\nprior exchanges in the conversation.",
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ {
            "name" : "toolCalls",
            "accessModifier" : "private,final",
            "value" : null,
            "type" : "List<ToolCall>",
            "comments" : null
          }, {
            "name" : "media",
            "accessModifier" : "protected,final",
            "value" : null,
            "type" : "List<Media>",
            "comments" : null
          } ],
          "constructors" : [ {
            "name" : "AssistantMessage",
            "arguments" : [ "String content" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "of",
              "arguments" : [ ],
              "body" : ""
            } ],
            "usedEntities" : [ "content", "Map" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public AssistantMessage(String content) {\n    this(content, Map.of());\n}"
          }, {
            "name" : "AssistantMessage",
            "arguments" : [ "String content", "Map<String, Object> properties" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "of",
              "arguments" : [ ],
              "body" : ""
            } ],
            "usedEntities" : [ "content", "properties", "List" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public AssistantMessage(String content, Map<String, Object> properties) {\n    this(content, properties, List.of());\n}"
          }, {
            "name" : "AssistantMessage",
            "arguments" : [ "String content", "Map<String, Object> properties", "List<ToolCall> toolCalls" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "of",
              "arguments" : [ ],
              "body" : ""
            } ],
            "usedEntities" : [ "content", "properties", "toolCalls", "List" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public AssistantMessage(String content, Map<String, Object> properties, List<ToolCall> toolCalls) {\n    this(content, properties, toolCalls, List.of());\n}"
          }, {
            "name" : "AssistantMessage",
            "arguments" : [ "String content", "Map<String, Object> properties", "List<ToolCall> toolCalls", "List<Media> media" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "notNull",
              "arguments" : [ "toolCalls", "\"Tool calls must not be null\"" ],
              "body" : ""
            }, {
              "name" : "notNull",
              "arguments" : [ "media", "\"Media must not be null\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "MessageType", "content", "properties", "Assert", "toolCalls", "media" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public AssistantMessage(String content, Map<String, Object> properties, List<ToolCall> toolCalls, List<Media> media) {\n    super(MessageType.ASSISTANT, content, properties);\n    Assert.notNull(toolCalls, \"Tool calls must not be null\");\n    Assert.notNull(media, \"Media must not be null\");\n    this.toolCalls = toolCalls;\n    this.media = media;\n}"
          } ],
          "extends" : [ "AbstractMessage" ],
          "implements" : [ "MediaContent" ],
          "nestedClass" : null,
          "accessSpecifier" : "public",
          "records" : null,
          "imports" : [ {
            "dereferencedParts" : [ ],
            "name" : "java.util.List"
          }, {
            "dereferencedParts" : [ ],
            "name" : "java.util.Map"
          }, {
            "dereferencedParts" : [ ],
            "name" : "java.util.Objects"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.model.Media"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.model.MediaContent"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.util.Assert"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.util.CollectionUtils"
          } ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/chat/messages/AssistantMessage.java",
        "name" : "org.springframework.ai.chat.messages.AssistantMessage"
      }, {
        "dereferencedParts" : [ {
          "name" : "Message",
          "comments" : "The Message interface represents a message that can be sent or received in a chat\napplication. Messages can have content, media attachments, properties, and message\ntypes.",
          "annotations" : [ ],
          "methods" : [ {
            "name" : "getMessageType",
            "arguments" : [ ],
            "accessModifier" : "",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "returnType" : "MessageType",
            "comments" : "Get the message type.",
            "methodDefinition" : "MessageType getMessageType();"
          } ],
          "fields" : [ ],
          "constructors" : [ ],
          "extends" : [ "Content" ],
          "implements" : [ ],
          "nestedClass" : null,
          "accessSpecifier" : "public",
          "records" : null,
          "imports" : [ {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.model.Content"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.model.Media"
          } ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/chat/messages/Message.java",
        "name" : "org.springframework.ai.chat.messages.Message"
      }, {
        "dereferencedParts" : [ {
          "name" : "UserMessage",
          "comments" : "A message of the type 'user' passed as input Messages with the user role are from the\nend-user or developer. They represent questions, prompts, or any input that you want\nthe generative to respond to.",
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ {
            "name" : "media",
            "accessModifier" : "protected,final",
            "value" : null,
            "type" : "List<Media>",
            "comments" : null
          } ],
          "constructors" : [ {
            "name" : "UserMessage",
            "arguments" : [ "String textContent" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "of",
              "arguments" : [ ],
              "body" : ""
            } ],
            "usedEntities" : [ "MessageType", "textContent", "Map" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public UserMessage(String textContent) {\n    this(MessageType.USER, textContent, new ArrayList<>(), Map.of());\n}"
          }, {
            "name" : "UserMessage",
            "arguments" : [ "Resource resource" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "of",
              "arguments" : [ ],
              "body" : ""
            } ],
            "usedEntities" : [ "MessageType", "resource", "Map" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public UserMessage(Resource resource) {\n    super(MessageType.USER, resource, Map.of());\n    this.media = new ArrayList<>();\n}"
          }, {
            "name" : "UserMessage",
            "arguments" : [ "String textContent", "List<Media> media" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "of",
              "arguments" : [ ],
              "body" : ""
            } ],
            "usedEntities" : [ "MessageType", "textContent", "media", "Map" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public UserMessage(String textContent, List<Media> media) {\n    this(MessageType.USER, textContent, media, Map.of());\n}"
          }, {
            "name" : "UserMessage",
            "arguments" : [ "String textContent", "Media... media" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "asList",
              "arguments" : [ "media" ],
              "body" : ""
            } ],
            "usedEntities" : [ "textContent", "Arrays", "media" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public UserMessage(String textContent, Media... media) {\n    this(textContent, Arrays.asList(media));\n}"
          }, {
            "name" : "UserMessage",
            "arguments" : [ "String textContent", "Collection<Media> mediaList", "Map<String, Object> metadata" ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ "MessageType", "textContent", "mediaList", "metadata" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public UserMessage(String textContent, Collection<Media> mediaList, Map<String, Object> metadata) {\n    this(MessageType.USER, textContent, mediaList, metadata);\n}"
          }, {
            "name" : "UserMessage",
            "arguments" : [ "MessageType messageType", "String textContent", "Collection<Media> media", "Map<String, Object> metadata" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "notNull",
              "arguments" : [ "media", "\"media data must not be null\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "messageType", "textContent", "metadata", "Assert", "media" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public UserMessage(MessageType messageType, String textContent, Collection<Media> media, Map<String, Object> metadata) {\n    super(messageType, textContent, metadata);\n    Assert.notNull(media, \"media data must not be null\");\n    this.media = new ArrayList<>(media);\n}"
          } ],
          "extends" : [ "AbstractMessage" ],
          "implements" : [ "MediaContent" ],
          "nestedClass" : null,
          "accessSpecifier" : "public",
          "records" : null,
          "imports" : [ {
            "dereferencedParts" : [ ],
            "name" : "java.util.ArrayList"
          }, {
            "dereferencedParts" : [ ],
            "name" : "java.util.Arrays"
          }, {
            "dereferencedParts" : [ ],
            "name" : "java.util.Collection"
          }, {
            "dereferencedParts" : [ ],
            "name" : "java.util.List"
          }, {
            "dereferencedParts" : [ ],
            "name" : "java.util.Map"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.model.Media"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.model.MediaContent"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.core.io.Resource"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.util.Assert"
          } ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/chat/messages/UserMessage.java",
        "name" : "org.springframework.ai.chat.messages.UserMessage"
      } ],
      "classes" : [ {
        "name" : "CassandraChatMemory",
        "comments" : "Create a CassandraChatMemory like <code>\n CassandraChatMemory.create(CassandraChatMemoryConfig.builder().withTimeToLive(Duration.ofDays(1)).build());\n </code>\n\nFor example @see org.springframework.ai.chat.memory.cassandra.CassandraChatMemory",
        "annotations" : [ ],
        "methods" : [ {
          "name" : "create",
          "arguments" : [ "CassandraChatMemoryConfig conf" ],
          "accessModifier" : "public,static",
          "methodsCalled" : [ ],
          "usedEntities" : [ "conf" ],
          "annotations" : [ ],
          "returnType" : "CassandraChatMemory",
          "comments" : null,
          "methodDefinition" : "public static CassandraChatMemory create(CassandraChatMemoryConfig conf) {\n    return new CassandraChatMemory(conf);\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemory.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "add",
          "arguments" : [ "String conversationId", "List<Message> messages" ],
          "accessModifier" : "public",
          "methodsCalled" : [ {
            "name" : "toEpochMilli",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "now",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "forEach",
            "arguments" : [ "msg -> {\n    if (msg.getMetadata().containsKey(CONVERSATION_TS)) {\n        msg.getMetadata().put(CONVERSATION_TS, Instant.ofEpochMilli(instantSeq.getAndIncrement()));\n    }\n    add(conversationId, msg);\n}" ],
            "body" : ""
          }, {
            "name" : "containsKey",
            "arguments" : [ "CONVERSATION_TS" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "put",
            "arguments" : [ "CONVERSATION_TS", "Instant.ofEpochMilli(instantSeq.getAndIncrement())" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "ofEpochMilli",
            "arguments" : [ "instantSeq.getAndIncrement()" ],
            "body" : ""
          }, {
            "name" : "getAndIncrement",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "add",
            "arguments" : [ "conversationId", "msg" ],
            "body" : "@Override\npublic void add(String conversationId, List<Message> messages) {\n    final AtomicLong instantSeq = new AtomicLong(Instant.now().toEpochMilli());\n    messages.forEach(msg -> {\n        if (msg.getMetadata().containsKey(CONVERSATION_TS)) {\n            msg.getMetadata().put(CONVERSATION_TS, Instant.ofEpochMilli(instantSeq.getAndIncrement()));\n        }\n        add(conversationId, msg);\n    });\n}"
          } ],
          "usedEntities" : [ "Instant", "messages", "msg", "CONVERSATION_TS", "instantSeq", "conversationId" ],
          "annotations" : [ "Override" ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "@Override\npublic void add(String conversationId, List<Message> messages) {\n    final AtomicLong instantSeq = new AtomicLong(Instant.now().toEpochMilli());\n    messages.forEach(msg -> {\n        if (msg.getMetadata().containsKey(CONVERSATION_TS)) {\n            msg.getMetadata().put(CONVERSATION_TS, Instant.ofEpochMilli(instantSeq.getAndIncrement()));\n        }\n        add(conversationId, msg);\n    });\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemory.java",
          "test_exists" : true,
          "test_functions" : {
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreObservationIT.java" : {
              "observationVectorStoreAddAndQueryOperations" : {
                "definition" : "@Test\nvoid observationVectorStoreAddAndQueryOperations() {\n    this.contextRunner.run(context -> {\n        VectorStore vectorStore = context.getBean(VectorStore.class);\n        TestObservationRegistry observationRegistry = context.getBean(TestObservationRegistry.class);\n        vectorStore.add(this.documents);\n        TestObservationRegistryAssert.assertThat(observationRegistry).doesNotHaveAnyRemainingCurrentObservation().hasObservationWithNameEqualTo(DefaultVectorStoreObservationConvention.DEFAULT_NAME).that().hasContextualNameEqualTo(\"%s add\".formatted(VectorStoreProvider.CASSANDRA.value())).hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_OPERATION_NAME.asString(), \"add\").hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_SYSTEM.asString(), VectorStoreProvider.CASSANDRA.value()).hasLowCardinalityKeyValue(LowCardinalityKeyNames.SPRING_AI_KIND.asString(), SpringAiKind.VECTOR_STORE.value()).doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_QUERY_CONTENT.asString()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_DIMENSION_COUNT.asString(), \"384\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_COLLECTION_NAME.asString(), CassandraVectorStore.DEFAULT_TABLE_NAME).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_NAMESPACE.asString(), \"test_springframework\").doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_FIELD_NAME.asString()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_SEARCH_SIMILARITY_METRIC.asString(), VectorStoreSimilarityMetric.COSINE.value()).doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_QUERY_TOP_K.asString()).doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_QUERY_SIMILARITY_THRESHOLD.asString()).hasBeenStarted().hasBeenStopped();\n        observationRegistry.clear();\n        List<Document> results = vectorStore.similaritySearch(SearchRequest.builder().query(\"What is Great Depression\").topK(1).build());\n        assertThat(results).isNotEmpty();\n        TestObservationRegistryAssert.assertThat(observationRegistry).doesNotHaveAnyRemainingCurrentObservation().hasObservationWithNameEqualTo(DefaultVectorStoreObservationConvention.DEFAULT_NAME).that().hasContextualNameEqualTo(\"%s query\".formatted(VectorStoreProvider.CASSANDRA.value())).hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_OPERATION_NAME.asString(), \"query\").hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_SYSTEM.asString(), VectorStoreProvider.CASSANDRA.value()).hasLowCardinalityKeyValue(LowCardinalityKeyNames.SPRING_AI_KIND.asString(), SpringAiKind.VECTOR_STORE.value()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_QUERY_CONTENT.asString(), \"What is Great Depression\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_DIMENSION_COUNT.asString(), \"384\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_COLLECTION_NAME.asString(), CassandraVectorStore.DEFAULT_TABLE_NAME).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_NAMESPACE.asString(), \"test_springframework\").doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_FIELD_NAME.asString()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_SEARCH_SIMILARITY_METRIC.asString(), VectorStoreSimilarityMetric.COSINE.value()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_QUERY_TOP_K.asString(), \"1\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_QUERY_SIMILARITY_THRESHOLD.asString(), \"0.0\").hasBeenStarted().hasBeenStopped();\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraFilterExpressionConverterTests.java" : {
              "testNe" : {
                "definition" : "@Test\nvoid testNe() {\n    Set<ColumnMetadata> columns = new HashSet(COLUMNS);\n    columns.add(new DefaultColumnMetadata(T, T, CqlIdentifier.fromInternal(\"city\"), DataTypes.TEXT, false));\n    CassandraFilterExpressionConverter filter = new CassandraFilterExpressionConverter(columns);\n    \n    String vectorExpr = filter.convertExpression(new Expression(OR, new Expression(GTE, new Key(\"year\"), new Value(2020)), new Group(new Expression(AND, new Expression(EQ, new Key(\"country\"), new Value(\"BG\")), new Expression(NE, new Key(\"city\"), new Value(\"Sofia\"))))));\n    assertThat(vectorExpr).isEqualTo(\"\\\"year\\\" >= 2020 or \\\"country\\\" = 'BG' and \\\"city\\\" != 'Sofia'\");\n}"
              },
              "testGroup" : {
                "definition" : "@Test\nvoid testGroup() {\n    Set<ColumnMetadata> columns = new HashSet(COLUMNS);\n    columns.add(new DefaultColumnMetadata(T, T, CqlIdentifier.fromInternal(\"city\"), DataTypes.TEXT, false));\n    CassandraFilterExpressionConverter filter = new CassandraFilterExpressionConverter(columns);\n    \n    String vectorExpr = filter.convertExpression(new Expression(AND, new Group(new Expression(OR, new Expression(GTE, new Key(\"year\"), new Value(2020)), new Expression(EQ, new Key(\"country\"), new Value(\"BG\")))), new Expression(IN, new Key(\"city\"), new Value(List.of(\"Sofia\", \"Plovdiv\")))));\n    assertThat(vectorExpr).isEqualTo(\"\\\"year\\\" >= 2020 or \\\"country\\\" = 'BG' and \\\"city\\\" IN ('Sofia','Plovdiv')\");\n}"
              },
              "tesBoolean" : {
                "definition" : "@Test\nvoid tesBoolean() {\n    Set<ColumnMetadata> columns = new HashSet(COLUMNS);\n    columns.add(new DefaultColumnMetadata(T, T, CqlIdentifier.fromInternal(\"isOpen\"), DataTypes.BOOLEAN, false));\n    CassandraFilterExpressionConverter filter = new CassandraFilterExpressionConverter(columns);\n    \n    String vectorExpr = filter.convertExpression(new Expression(AND, new Expression(AND, new Expression(EQ, new Key(\"isOpen\"), new Value(true)), new Expression(GTE, new Key(\"year\"), new Value(2020))), new Expression(IN, new Key(\"country\"), new Value(List.of(\"BG\", \"NL\", \"US\")))));\n    assertThat(vectorExpr).isEqualTo(\"\\\"isOpen\\\" = true and \\\"year\\\" >= 2020 and \\\"country\\\" IN ('BG','NL','US')\");\n}"
              },
              "testDecimal" : {
                "definition" : "@Test\nvoid testDecimal() {\n    Set<ColumnMetadata> columns = new HashSet(COLUMNS);\n    columns.add(new DefaultColumnMetadata(T, T, CqlIdentifier.fromInternal(\"temperature\"), DataTypes.DOUBLE, false));\n    CassandraFilterExpressionConverter filter = new CassandraFilterExpressionConverter(columns);\n    \n    String vectorExpr = filter.convertExpression(new Expression(AND, new Expression(GTE, new Key(\"temperature\"), new Value(-15.6)), new Expression(LTE, new Key(\"temperature\"), new Value(20.13))));\n    assertThat(vectorExpr).isEqualTo(\"\\\"temperature\\\" >= -15.6 and \\\"temperature\\\" <= 20.13\");\n}"
              },
              "testComplexIdentifiers" : {
                "definition" : "@Test\nvoid testComplexIdentifiers() {\n    Set<ColumnMetadata> columns = new HashSet(COLUMNS);\n    columns.add(new DefaultColumnMetadata(T, T, CqlIdentifier.fromInternal(\"\\\"country 1 2 3\\\"\"), DataTypes.TEXT, false));\n    columns.add(new DefaultColumnMetadata(T, T, CqlIdentifier.fromInternal(\"'country 1 2 3'\"), DataTypes.TEXT, false));\n    CassandraFilterExpressionConverter filter = new CassandraFilterExpressionConverter(columns);\n    String vectorExpr = filter.convertExpression(new Expression(EQ, new Key(\"\\\"country 1 2 3\\\"\"), new Value(\"BG\")));\n    assertThat(vectorExpr).isEqualTo(\"\\\"\\\"\\\"country 1 2 3\\\"\\\"\\\" = 'BG'\");\n    vectorExpr = filter.convertExpression(new Expression(EQ, new Key(\"'country 1 2 3'\"), new Value(\"BG\")));\n    assertThat(vectorExpr).isEqualTo(\"\\\"'country 1 2 3'\\\" = 'BG'\");\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreIT.java" : {
              "addAndSearch" : {
                "definition" : "@Test\nvoid addAndSearch() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"meta1\", DataTypes.TEXT), new SchemaColumn(\"meta2\", DataTypes.TEXT))) {\n            List<Document> documents = documents();\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents().get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Spring AI provides abstractions that serve as the foundation for developing AI applications.\");\n            assertThat(resultDoc.getMetadata()).hasSize(2);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"meta1\", DocumentMetadata.DISTANCE.value());\n            \n            store.delete(documents().stream().map(doc -> doc.getId()).toList());\n            results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).isEmpty();\n        }\n    });\n}"
              },
              "addAndSearchReturnEmbeddings" : {
                "definition" : "@Test\nvoid addAndSearchReturnEmbeddings() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore.Builder builder = storeBuilder(context.getBean(CqlSession.class), context.getBean(EmbeddingModel.class)).returnEmbeddings(true);\n        try (CassandraVectorStore store = createTestStore(context, builder)) {\n            List<Document> documents = documents();\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents().get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Spring AI provides abstractions that serve as the foundation for developing AI applications.\");\n            assertThat(resultDoc.getMetadata()).hasSize(1);\n            assertThat(resultDoc.getMetadata()).containsKey(DocumentMetadata.DISTANCE.value());\n            \n            store.delete(documents().stream().map(doc -> doc.getId()).toList());\n            results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).isEmpty();\n        }\n    });\n}"
              },
              "searchWithPartitionFilter" : {
                "definition" : "@Test\nvoid searchWithPartitionFilter() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"BG\", \"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"year\", (short) 2020));\n            var nlDocument = new Document(\"NL\", \"The World is Big and Salvation Lurks Around the Corner\", java.util.Collections.emptyMap());\n            var bgDocument2 = new Document(\"BG2\", \"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"%s == 'NL'\", CassandraVectorStore.DEFAULT_ID_NAME)).build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(nlDocument.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"%s == 'BG2'\", CassandraVectorStore.DEFAULT_ID_NAME)).build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(bgDocument2.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"%s == 'BG' && year == 2020\", CassandraVectorStore.DEFAULT_ID_NAME)).build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(bgDocument.getId());\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"NOT(%s == 'BG' && year == 2020)\", CassandraVectorStore.DEFAULT_ID_NAME)).build()));\n        }\n    });\n}"
              },
              "unsearchableFilters" : {
                "definition" : "@Test\nvoid unsearchableFilters() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'NL'\").build()));\n        }\n    });\n}"
              },
              "searchWithFilters" : {
                "definition" : "@Test\nvoid searchWithFilters() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"country\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'NL'\").build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(nlDocument.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'BG'\").build());\n            assertThat(results).hasSize(2);\n            assertThat(results.get(0).getId()).isIn(bgDocument.getId(), bgDocument2.getId());\n            assertThat(results.get(1).getId()).isIn(bgDocument.getId(), bgDocument2.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'BG' && year == 2020\").build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(bgDocument.getId());\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'BG' || year == 2020\").build()));\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"NOT(country == 'BG' && year == 2020)\").build()));\n        }\n    });\n}"
              },
              "documentUpdate" : {
                "definition" : "@Test\nvoid documentUpdate() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            Document document = new Document(UUID.randomUUID().toString(), \"Spring AI rocks!!\", Collections.singletonMap(\"meta1\", \"meta1\"));\n            store.add(List.of(document));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(5).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(document.getId());\n            assertThat(resultDoc.getText()).isEqualTo(\"Spring AI rocks!!\");\n            assertThat(resultDoc.getMetadata()).containsKey(\"meta1\");\n            Document sameIdDocument = new Document(document.getId(), \"The World is Big and Salvation Lurks Around the Corner\", Collections.singletonMap(\"meta2\", \"meta2\"));\n            store.add(List.of(sameIdDocument));\n            results = store.similaritySearch(SearchRequest.builder().query(\"FooBar\").topK(5).build());\n            assertThat(results).hasSize(1);\n            resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(document.getId());\n            assertThat(resultDoc.getText()).isEqualTo(\"The World is Big and Salvation Lurks Around the Corner\");\n            assertThat(resultDoc.getMetadata()).containsKeys(\"meta2\", DocumentMetadata.DISTANCE.value());\n            store.delete(List.of(document.getId()));\n        }\n    });\n}"
              },
              "searchWithThreshold" : {
                "definition" : "@Test\nvoid searchWithThreshold() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            store.add(documents());\n            List<Document> fullResult = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(5).similarityThresholdAll().build());\n            List<Double> scores = fullResult.stream().map(Document::getScore).toList();\n            assertThat(scores).hasSize(3);\n            double similarityThreshold = (scores.get(0) + scores.get(1)) / 2;\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(5).similarityThreshold(similarityThreshold).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents().get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Spring AI provides abstractions that serve as the foundation for developing AI applications.\");\n            assertThat(resultDoc.getMetadata()).containsKeys(\"meta1\", DocumentMetadata.DISTANCE.value());\n            assertThat(resultDoc.getScore()).isGreaterThanOrEqualTo(similarityThreshold);\n        }\n    });\n}"
              },
              "deleteByFilter" : {
                "definition" : "@Test\nprotected void deleteByFilter() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"country\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            \n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            \n            Filter.Expression filterExpression = new Filter.Expression(Filter.ExpressionType.EQ, new Filter.Key(\"country\"), new Filter.Value(\"BG\"));\n            store.delete(filterExpression);\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getMetadata()).containsEntry(\"country\", \"NL\");\n        }\n    });\n}"
              },
              "deleteWithStringFilterExpression" : {
                "definition" : "@Test\nprotected void deleteWithStringFilterExpression() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"country\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            \n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            store.delete(\"country == 'BG'\");\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getMetadata()).containsEntry(\"country\", \"NL\");\n        }\n    });\n}"
              },
              "deleteWithComplexFilterExpression" : {
                "definition" : "@Test\nvoid deleteWithComplexFilterExpression() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"type\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"priority\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var doc1 = new Document(\"Content 1\", Map.of(\"type\", \"A\", \"priority\", (short) 1));\n            var doc2 = new Document(\"Content 2\", Map.of(\"type\", \"A\", \"priority\", (short) 2));\n            var doc3 = new Document(\"Content 3\", Map.of(\"type\", \"B\", \"priority\", (short) 1));\n            store.add(List.of(doc1, doc2, doc3));\n            \n            Filter.Expression priorityFilter = new Filter.Expression(Filter.ExpressionType.GT, new Filter.Key(\"priority\"), new Filter.Value((short) 1));\n            Filter.Expression typeFilter = new Filter.Expression(Filter.ExpressionType.EQ, new Filter.Key(\"type\"), new Filter.Value(\"A\"));\n            Filter.Expression complexFilter = new Filter.Expression(Filter.ExpressionType.AND, typeFilter, priorityFilter);\n            store.delete(complexFilter);\n            var results = store.similaritySearch(SearchRequest.builder().query(\"Content\").topK(5).similarityThresholdAll().build());\n            assertThat(results).hasSize(2);\n            assertThat(results.stream().map(doc -> doc.getMetadata().get(\"type\")).collect(Collectors.toList())).containsExactlyInAnyOrder(\"A\", \"B\");\n            assertThat(results.stream().map(doc -> ((Short) doc.getMetadata().get(\"priority\")).intValue()).collect(Collectors.toList())).containsExactlyInAnyOrder(1, 1);\n        }\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraRichSchemaVectorStoreIT.java" : {
              "addAndSearch" : {
                "definition" : "@Test\nvoid addAndSearch() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Neptunes gravity makes its atmosphere\").topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents.get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Neptunes gravity makes its atmosphere\");\n            assertThat(resultDoc.getMetadata()).hasSize(3);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"id\", \"revision\", DocumentMetadata.DISTANCE.value());\n            \n            store.delete(documents.stream().map(doc -> doc.getId()).toList());\n            results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).isEmpty();\n        }\n    });\n}"
              },
              "addAndSearchPoormansBench" : {
                "definition" : "@Test\nvoid addAndSearchPoormansBench() {\n    \n    int nThreads = CassandraVectorStore.DEFAULT_ADD_CONCURRENCY;\n    \n    int runs = 10;\n    \n    int docsPerAdd = 12;\n    int rounds = 3;\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = storeBuilder(context, List.of()).fixedThreadPoolExecutorSize(nThreads).build()) {\n            var executor = Executors.newFixedThreadPool((int) (nThreads * 1.2));\n            for (int k = 0; k < rounds; ++k) {\n                long start = System.nanoTime();\n                var futures = new CompletableFuture[runs];\n                for (int j = 0; j < runs; ++j) {\n                    futures[j] = CompletableFuture.runAsync(() -> {\n                        List<Document> documents = new ArrayList<>();\n                        for (int i = docsPerAdd; i >= 0; --i) {\n                            documents.add(new Document(RandomStringUtils.randomAlphanumeric(4) + \"§¶\" + ThreadLocalRandom.current().nextInt(1, 10), RandomStringUtils.randomAlphanumeric(1024), Map.of(\"revision\", ThreadLocalRandom.current().nextInt(1, 100000), \"id\", 1000)));\n                        }\n                        store.add(documents);\n                        var results = store.similaritySearch(SearchRequest.builder().query(RandomStringUtils.randomAlphanumeric(20)).topK(10).build());\n                        assertThat(results).hasSize(10);\n                    }, executor);\n                }\n                CompletableFuture.allOf(futures).join();\n                long time = System.nanoTime() - start;\n                logger.info(\"add+search took an average of {} ms\", Duration.ofNanos(time / runs).toMillis());\n            }\n        }\n    });\n}"
              },
              "searchWithPartitionFilter" : {
                "definition" : "@Test\nvoid searchWithPartitionFilter() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"wiki == 'simplewiki' && language == 'en' && title == 'Neptune'\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            results = store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"wiki == 'simplewiki' && language == 'en' && title == 'Neptune' && id == 558\").build());\n            assertThat(results).hasSize(3);\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"NOT(wiki == 'simplewiki' && language == 'en' && title == 'Neptune' && id == 1)\").build()));\n        }\n    });\n}"
              },
              "unsearchableFilters" : {
                "definition" : "@Test\nvoid unsearchableFilters() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).build());\n            assertThat(results).hasSize(3);\n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"revision == 9385813\").build()));\n        }\n    });\n}"
              },
              "searchWithFilters" : {
                "definition" : "@Test\nvoid searchWithFilters() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id == 558\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id > 557\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id >= 558\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            \n            \n            \n            \n            \n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id > 557 && \\\"chunk_no\\\" == 1\").build()));\n            \n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"id == 558 || revision == 2020\").build()));\n            \n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"NOT(id == 557 || revision == 2020)\").build()));\n        }\n    });\n}"
              },
              "searchWithFilterOnPrimaryKeys" : {
                "definition" : "@Test\nvoid searchWithFilterOnPrimaryKeys() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        List<SchemaColumn> overrides = List.of(new SchemaColumn(\"title\", DataTypes.TEXT, CassandraVectorStore.SchemaColumnTags.INDEXED), new SchemaColumn(\"chunk_no\", DataTypes.INT, CassandraVectorStore.SchemaColumnTags.INDEXED));\n        try (CassandraVectorStore store = createStore(context, overrides, false, true)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).build());\n            assertThat(results).hasSize(3);\n            store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id > 557 && \\\"chunk_no\\\" == 1\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            \n            \n            \n            \n            \n            \n            \n            \n            \n        }\n    });\n}"
              },
              "documentUpdate" : {
                "definition" : "@Test\nvoid documentUpdate() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getText()).contains(URANUS_ORBIT_QUERY);\n            assertThat(resultDoc.getMetadata()).containsKey(\"revision\");\n            String newContent = \"The World is Big and Salvation Lurks Around the Corner\";\n            Document sameIdDocument = new Document(documents.get(1).getId(), newContent, Collections.emptyMap());\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            store.delete(List.of(sameIdDocument.getId()));\n            results = store.similaritySearch(SearchRequest.builder().query(newContent).topK(1).build());\n            assertThat(results).hasSize(1);\n            resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isNotEqualTo(sameIdDocument.getId());\n            assertThat(resultDoc.getText()).doesNotContain(newContent);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"id\", \"revision\", DocumentMetadata.DISTANCE.value());\n        }\n    });\n}"
              },
              "searchWithThreshold" : {
                "definition" : "@Test\nvoid searchWithThreshold() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> fullResult = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().build());\n            List<Double> scores = fullResult.stream().map(Document::getScore).toList();\n            assertThat(scores).hasSize(3);\n            double similarityThreshold = (scores.get(0) + scores.get(1)) / 2;\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThreshold(similarityThreshold).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents.get(1).getId());\n            assertThat(resultDoc.getText()).contains(URANUS_ORBIT_QUERY);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"id\", \"revision\", DocumentMetadata.DISTANCE.value());\n            assertThat(resultDoc.getScore()).isGreaterThanOrEqualTo(similarityThreshold);\n        }\n    });\n}"
              }
            }
          }
        }, {
          "name" : "add",
          "arguments" : [ "String sessionId", "Message msg" ],
          "accessModifier" : "public",
          "methodsCalled" : [ {
            "name" : "checkArgument",
            "arguments" : [ "!msg.getMetadata().containsKey(CONVERSATION_TS) || msg.getMetadata().get(CONVERSATION_TS) instanceof Instant", "\"messages only accept metadata '%s' entries of type Instant\"", "CONVERSATION_TS" ],
            "body" : ""
          }, {
            "name" : "containsKey",
            "arguments" : [ "CONVERSATION_TS" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "CONVERSATION_TS" ],
            "body" : "@Override\npublic List<Message> get(String sessionId, int lastN) {\n    List<Object> primaryKeys = this.conf.primaryKeyTranslator.apply(sessionId);\n    BoundStatementBuilder builder = this.getStmt.boundStatementBuilder().setInt(\"lastN\", lastN);\n    for (int k = 0; k < primaryKeys.size(); ++k) {\n        SchemaColumn keyColumn = this.conf.getPrimaryKeyColumn(k);\n        builder = builder.set(keyColumn.name(), primaryKeys.get(k), keyColumn.javaType());\n    }\n    List<Message> messages = new ArrayList<>();\n    for (Row r : this.conf.session.execute(builder.build())) {\n        String assistant = r.getString(this.conf.assistantColumn);\n        String user = r.getString(this.conf.userColumn);\n        if (null != assistant) {\n            messages.add(new AssistantMessage(assistant));\n        }\n        if (null != user) {\n            messages.add(new UserMessage(user));\n        }\n    }\n    return messages;\n}"
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "putIfAbsent",
            "arguments" : [ "CONVERSATION_TS", "Instant.now()" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "now",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getStatement",
            "arguments" : [ "msg" ],
            "body" : "PreparedStatement getStatement(Message msg) {\n    return switch(msg.getMessageType()) {\n        case USER ->\n            this.addUserStmt;\n        case ASSISTANT ->\n            this.addAssistantStmt;\n        default ->\n            throw new IllegalArgumentException(\"Cant add type \" + msg);\n    };\n}"
          }, {
            "name" : "apply",
            "arguments" : [ "sessionId" ],
            "body" : ""
          }, {
            "name" : "boundStatementBuilder",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "size",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getPrimaryKeyColumn",
            "arguments" : [ "k" ],
            "body" : ""
          }, {
            "name" : "set",
            "arguments" : [ "keyColumn.name()", "primaryKeys.get(k)", "keyColumn.javaType()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "k" ],
            "body" : "@Override\npublic List<Message> get(String sessionId, int lastN) {\n    List<Object> primaryKeys = this.conf.primaryKeyTranslator.apply(sessionId);\n    BoundStatementBuilder builder = this.getStmt.boundStatementBuilder().setInt(\"lastN\", lastN);\n    for (int k = 0; k < primaryKeys.size(); ++k) {\n        SchemaColumn keyColumn = this.conf.getPrimaryKeyColumn(k);\n        builder = builder.set(keyColumn.name(), primaryKeys.get(k), keyColumn.javaType());\n    }\n    List<Message> messages = new ArrayList<>();\n    for (Row r : this.conf.session.execute(builder.build())) {\n        String assistant = r.getString(this.conf.assistantColumn);\n        String user = r.getString(this.conf.userColumn);\n        if (null != assistant) {\n            messages.add(new AssistantMessage(assistant));\n        }\n        if (null != user) {\n            messages.add(new UserMessage(user));\n        }\n    }\n    return messages;\n}"
          }, {
            "name" : "javaType",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "CONVERSATION_TS" ],
            "body" : "@Override\npublic List<Message> get(String sessionId, int lastN) {\n    List<Object> primaryKeys = this.conf.primaryKeyTranslator.apply(sessionId);\n    BoundStatementBuilder builder = this.getStmt.boundStatementBuilder().setInt(\"lastN\", lastN);\n    for (int k = 0; k < primaryKeys.size(); ++k) {\n        SchemaColumn keyColumn = this.conf.getPrimaryKeyColumn(k);\n        builder = builder.set(keyColumn.name(), primaryKeys.get(k), keyColumn.javaType());\n    }\n    List<Message> messages = new ArrayList<>();\n    for (Row r : this.conf.session.execute(builder.build())) {\n        String assistant = r.getString(this.conf.assistantColumn);\n        String user = r.getString(this.conf.userColumn);\n        if (null != assistant) {\n            messages.add(new AssistantMessage(assistant));\n        }\n        if (null != user) {\n            messages.add(new UserMessage(user));\n        }\n    }\n    return messages;\n}"
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "setString",
            "arguments" : [ "\"message\"", "msg.getText()" ],
            "body" : ""
          }, {
            "name" : "setInstant",
            "arguments" : [ "CassandraChatMemoryConfig.DEFAULT_EXCHANGE_ID_NAME", "instant" ],
            "body" : ""
          }, {
            "name" : "getText",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "execute",
            "arguments" : [ "builder.build()" ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "Preconditions", "msg", "CONVERSATION_TS", "Instant", "sessionId", "stmt", "k", "primaryKeys", "builder", "keyColumn", "CassandraChatMemoryConfig", "instant" ],
          "annotations" : [ "Override" ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "@Override\npublic void add(String sessionId, Message msg) {\n    Preconditions.checkArgument(!msg.getMetadata().containsKey(CONVERSATION_TS) || msg.getMetadata().get(CONVERSATION_TS) instanceof Instant, \"messages only accept metadata '%s' entries of type Instant\", CONVERSATION_TS);\n    msg.getMetadata().putIfAbsent(CONVERSATION_TS, Instant.now());\n    PreparedStatement stmt = getStatement(msg);\n    List<Object> primaryKeys = this.conf.primaryKeyTranslator.apply(sessionId);\n    BoundStatementBuilder builder = stmt.boundStatementBuilder();\n    for (int k = 0; k < primaryKeys.size(); ++k) {\n        SchemaColumn keyColumn = this.conf.getPrimaryKeyColumn(k);\n        builder = builder.set(keyColumn.name(), primaryKeys.get(k), keyColumn.javaType());\n    }\n    Instant instant = (Instant) msg.getMetadata().get(CONVERSATION_TS);\n    builder = builder.setInstant(CassandraChatMemoryConfig.DEFAULT_EXCHANGE_ID_NAME, instant).setString(\"message\", msg.getText());\n    this.conf.session.execute(builder.build());\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemory.java",
          "test_exists" : true,
          "test_functions" : {
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreObservationIT.java" : {
              "observationVectorStoreAddAndQueryOperations" : {
                "definition" : "@Test\nvoid observationVectorStoreAddAndQueryOperations() {\n    this.contextRunner.run(context -> {\n        VectorStore vectorStore = context.getBean(VectorStore.class);\n        TestObservationRegistry observationRegistry = context.getBean(TestObservationRegistry.class);\n        vectorStore.add(this.documents);\n        TestObservationRegistryAssert.assertThat(observationRegistry).doesNotHaveAnyRemainingCurrentObservation().hasObservationWithNameEqualTo(DefaultVectorStoreObservationConvention.DEFAULT_NAME).that().hasContextualNameEqualTo(\"%s add\".formatted(VectorStoreProvider.CASSANDRA.value())).hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_OPERATION_NAME.asString(), \"add\").hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_SYSTEM.asString(), VectorStoreProvider.CASSANDRA.value()).hasLowCardinalityKeyValue(LowCardinalityKeyNames.SPRING_AI_KIND.asString(), SpringAiKind.VECTOR_STORE.value()).doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_QUERY_CONTENT.asString()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_DIMENSION_COUNT.asString(), \"384\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_COLLECTION_NAME.asString(), CassandraVectorStore.DEFAULT_TABLE_NAME).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_NAMESPACE.asString(), \"test_springframework\").doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_FIELD_NAME.asString()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_SEARCH_SIMILARITY_METRIC.asString(), VectorStoreSimilarityMetric.COSINE.value()).doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_QUERY_TOP_K.asString()).doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_QUERY_SIMILARITY_THRESHOLD.asString()).hasBeenStarted().hasBeenStopped();\n        observationRegistry.clear();\n        List<Document> results = vectorStore.similaritySearch(SearchRequest.builder().query(\"What is Great Depression\").topK(1).build());\n        assertThat(results).isNotEmpty();\n        TestObservationRegistryAssert.assertThat(observationRegistry).doesNotHaveAnyRemainingCurrentObservation().hasObservationWithNameEqualTo(DefaultVectorStoreObservationConvention.DEFAULT_NAME).that().hasContextualNameEqualTo(\"%s query\".formatted(VectorStoreProvider.CASSANDRA.value())).hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_OPERATION_NAME.asString(), \"query\").hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_SYSTEM.asString(), VectorStoreProvider.CASSANDRA.value()).hasLowCardinalityKeyValue(LowCardinalityKeyNames.SPRING_AI_KIND.asString(), SpringAiKind.VECTOR_STORE.value()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_QUERY_CONTENT.asString(), \"What is Great Depression\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_DIMENSION_COUNT.asString(), \"384\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_COLLECTION_NAME.asString(), CassandraVectorStore.DEFAULT_TABLE_NAME).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_NAMESPACE.asString(), \"test_springframework\").doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_FIELD_NAME.asString()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_SEARCH_SIMILARITY_METRIC.asString(), VectorStoreSimilarityMetric.COSINE.value()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_QUERY_TOP_K.asString(), \"1\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_QUERY_SIMILARITY_THRESHOLD.asString(), \"0.0\").hasBeenStarted().hasBeenStopped();\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraFilterExpressionConverterTests.java" : {
              "testNe" : {
                "definition" : "@Test\nvoid testNe() {\n    Set<ColumnMetadata> columns = new HashSet(COLUMNS);\n    columns.add(new DefaultColumnMetadata(T, T, CqlIdentifier.fromInternal(\"city\"), DataTypes.TEXT, false));\n    CassandraFilterExpressionConverter filter = new CassandraFilterExpressionConverter(columns);\n    \n    String vectorExpr = filter.convertExpression(new Expression(OR, new Expression(GTE, new Key(\"year\"), new Value(2020)), new Group(new Expression(AND, new Expression(EQ, new Key(\"country\"), new Value(\"BG\")), new Expression(NE, new Key(\"city\"), new Value(\"Sofia\"))))));\n    assertThat(vectorExpr).isEqualTo(\"\\\"year\\\" >= 2020 or \\\"country\\\" = 'BG' and \\\"city\\\" != 'Sofia'\");\n}"
              },
              "testGroup" : {
                "definition" : "@Test\nvoid testGroup() {\n    Set<ColumnMetadata> columns = new HashSet(COLUMNS);\n    columns.add(new DefaultColumnMetadata(T, T, CqlIdentifier.fromInternal(\"city\"), DataTypes.TEXT, false));\n    CassandraFilterExpressionConverter filter = new CassandraFilterExpressionConverter(columns);\n    \n    String vectorExpr = filter.convertExpression(new Expression(AND, new Group(new Expression(OR, new Expression(GTE, new Key(\"year\"), new Value(2020)), new Expression(EQ, new Key(\"country\"), new Value(\"BG\")))), new Expression(IN, new Key(\"city\"), new Value(List.of(\"Sofia\", \"Plovdiv\")))));\n    assertThat(vectorExpr).isEqualTo(\"\\\"year\\\" >= 2020 or \\\"country\\\" = 'BG' and \\\"city\\\" IN ('Sofia','Plovdiv')\");\n}"
              },
              "tesBoolean" : {
                "definition" : "@Test\nvoid tesBoolean() {\n    Set<ColumnMetadata> columns = new HashSet(COLUMNS);\n    columns.add(new DefaultColumnMetadata(T, T, CqlIdentifier.fromInternal(\"isOpen\"), DataTypes.BOOLEAN, false));\n    CassandraFilterExpressionConverter filter = new CassandraFilterExpressionConverter(columns);\n    \n    String vectorExpr = filter.convertExpression(new Expression(AND, new Expression(AND, new Expression(EQ, new Key(\"isOpen\"), new Value(true)), new Expression(GTE, new Key(\"year\"), new Value(2020))), new Expression(IN, new Key(\"country\"), new Value(List.of(\"BG\", \"NL\", \"US\")))));\n    assertThat(vectorExpr).isEqualTo(\"\\\"isOpen\\\" = true and \\\"year\\\" >= 2020 and \\\"country\\\" IN ('BG','NL','US')\");\n}"
              },
              "testDecimal" : {
                "definition" : "@Test\nvoid testDecimal() {\n    Set<ColumnMetadata> columns = new HashSet(COLUMNS);\n    columns.add(new DefaultColumnMetadata(T, T, CqlIdentifier.fromInternal(\"temperature\"), DataTypes.DOUBLE, false));\n    CassandraFilterExpressionConverter filter = new CassandraFilterExpressionConverter(columns);\n    \n    String vectorExpr = filter.convertExpression(new Expression(AND, new Expression(GTE, new Key(\"temperature\"), new Value(-15.6)), new Expression(LTE, new Key(\"temperature\"), new Value(20.13))));\n    assertThat(vectorExpr).isEqualTo(\"\\\"temperature\\\" >= -15.6 and \\\"temperature\\\" <= 20.13\");\n}"
              },
              "testComplexIdentifiers" : {
                "definition" : "@Test\nvoid testComplexIdentifiers() {\n    Set<ColumnMetadata> columns = new HashSet(COLUMNS);\n    columns.add(new DefaultColumnMetadata(T, T, CqlIdentifier.fromInternal(\"\\\"country 1 2 3\\\"\"), DataTypes.TEXT, false));\n    columns.add(new DefaultColumnMetadata(T, T, CqlIdentifier.fromInternal(\"'country 1 2 3'\"), DataTypes.TEXT, false));\n    CassandraFilterExpressionConverter filter = new CassandraFilterExpressionConverter(columns);\n    String vectorExpr = filter.convertExpression(new Expression(EQ, new Key(\"\\\"country 1 2 3\\\"\"), new Value(\"BG\")));\n    assertThat(vectorExpr).isEqualTo(\"\\\"\\\"\\\"country 1 2 3\\\"\\\"\\\" = 'BG'\");\n    vectorExpr = filter.convertExpression(new Expression(EQ, new Key(\"'country 1 2 3'\"), new Value(\"BG\")));\n    assertThat(vectorExpr).isEqualTo(\"\\\"'country 1 2 3'\\\" = 'BG'\");\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreIT.java" : {
              "addAndSearch" : {
                "definition" : "@Test\nvoid addAndSearch() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"meta1\", DataTypes.TEXT), new SchemaColumn(\"meta2\", DataTypes.TEXT))) {\n            List<Document> documents = documents();\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents().get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Spring AI provides abstractions that serve as the foundation for developing AI applications.\");\n            assertThat(resultDoc.getMetadata()).hasSize(2);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"meta1\", DocumentMetadata.DISTANCE.value());\n            \n            store.delete(documents().stream().map(doc -> doc.getId()).toList());\n            results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).isEmpty();\n        }\n    });\n}"
              },
              "addAndSearchReturnEmbeddings" : {
                "definition" : "@Test\nvoid addAndSearchReturnEmbeddings() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore.Builder builder = storeBuilder(context.getBean(CqlSession.class), context.getBean(EmbeddingModel.class)).returnEmbeddings(true);\n        try (CassandraVectorStore store = createTestStore(context, builder)) {\n            List<Document> documents = documents();\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents().get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Spring AI provides abstractions that serve as the foundation for developing AI applications.\");\n            assertThat(resultDoc.getMetadata()).hasSize(1);\n            assertThat(resultDoc.getMetadata()).containsKey(DocumentMetadata.DISTANCE.value());\n            \n            store.delete(documents().stream().map(doc -> doc.getId()).toList());\n            results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).isEmpty();\n        }\n    });\n}"
              },
              "searchWithPartitionFilter" : {
                "definition" : "@Test\nvoid searchWithPartitionFilter() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"BG\", \"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"year\", (short) 2020));\n            var nlDocument = new Document(\"NL\", \"The World is Big and Salvation Lurks Around the Corner\", java.util.Collections.emptyMap());\n            var bgDocument2 = new Document(\"BG2\", \"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"%s == 'NL'\", CassandraVectorStore.DEFAULT_ID_NAME)).build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(nlDocument.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"%s == 'BG2'\", CassandraVectorStore.DEFAULT_ID_NAME)).build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(bgDocument2.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"%s == 'BG' && year == 2020\", CassandraVectorStore.DEFAULT_ID_NAME)).build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(bgDocument.getId());\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"NOT(%s == 'BG' && year == 2020)\", CassandraVectorStore.DEFAULT_ID_NAME)).build()));\n        }\n    });\n}"
              },
              "unsearchableFilters" : {
                "definition" : "@Test\nvoid unsearchableFilters() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'NL'\").build()));\n        }\n    });\n}"
              },
              "searchWithFilters" : {
                "definition" : "@Test\nvoid searchWithFilters() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"country\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'NL'\").build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(nlDocument.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'BG'\").build());\n            assertThat(results).hasSize(2);\n            assertThat(results.get(0).getId()).isIn(bgDocument.getId(), bgDocument2.getId());\n            assertThat(results.get(1).getId()).isIn(bgDocument.getId(), bgDocument2.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'BG' && year == 2020\").build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(bgDocument.getId());\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'BG' || year == 2020\").build()));\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"NOT(country == 'BG' && year == 2020)\").build()));\n        }\n    });\n}"
              },
              "documentUpdate" : {
                "definition" : "@Test\nvoid documentUpdate() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            Document document = new Document(UUID.randomUUID().toString(), \"Spring AI rocks!!\", Collections.singletonMap(\"meta1\", \"meta1\"));\n            store.add(List.of(document));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(5).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(document.getId());\n            assertThat(resultDoc.getText()).isEqualTo(\"Spring AI rocks!!\");\n            assertThat(resultDoc.getMetadata()).containsKey(\"meta1\");\n            Document sameIdDocument = new Document(document.getId(), \"The World is Big and Salvation Lurks Around the Corner\", Collections.singletonMap(\"meta2\", \"meta2\"));\n            store.add(List.of(sameIdDocument));\n            results = store.similaritySearch(SearchRequest.builder().query(\"FooBar\").topK(5).build());\n            assertThat(results).hasSize(1);\n            resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(document.getId());\n            assertThat(resultDoc.getText()).isEqualTo(\"The World is Big and Salvation Lurks Around the Corner\");\n            assertThat(resultDoc.getMetadata()).containsKeys(\"meta2\", DocumentMetadata.DISTANCE.value());\n            store.delete(List.of(document.getId()));\n        }\n    });\n}"
              },
              "searchWithThreshold" : {
                "definition" : "@Test\nvoid searchWithThreshold() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            store.add(documents());\n            List<Document> fullResult = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(5).similarityThresholdAll().build());\n            List<Double> scores = fullResult.stream().map(Document::getScore).toList();\n            assertThat(scores).hasSize(3);\n            double similarityThreshold = (scores.get(0) + scores.get(1)) / 2;\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(5).similarityThreshold(similarityThreshold).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents().get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Spring AI provides abstractions that serve as the foundation for developing AI applications.\");\n            assertThat(resultDoc.getMetadata()).containsKeys(\"meta1\", DocumentMetadata.DISTANCE.value());\n            assertThat(resultDoc.getScore()).isGreaterThanOrEqualTo(similarityThreshold);\n        }\n    });\n}"
              },
              "deleteByFilter" : {
                "definition" : "@Test\nprotected void deleteByFilter() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"country\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            \n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            \n            Filter.Expression filterExpression = new Filter.Expression(Filter.ExpressionType.EQ, new Filter.Key(\"country\"), new Filter.Value(\"BG\"));\n            store.delete(filterExpression);\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getMetadata()).containsEntry(\"country\", \"NL\");\n        }\n    });\n}"
              },
              "deleteWithStringFilterExpression" : {
                "definition" : "@Test\nprotected void deleteWithStringFilterExpression() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"country\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            \n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            store.delete(\"country == 'BG'\");\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getMetadata()).containsEntry(\"country\", \"NL\");\n        }\n    });\n}"
              },
              "deleteWithComplexFilterExpression" : {
                "definition" : "@Test\nvoid deleteWithComplexFilterExpression() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"type\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"priority\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var doc1 = new Document(\"Content 1\", Map.of(\"type\", \"A\", \"priority\", (short) 1));\n            var doc2 = new Document(\"Content 2\", Map.of(\"type\", \"A\", \"priority\", (short) 2));\n            var doc3 = new Document(\"Content 3\", Map.of(\"type\", \"B\", \"priority\", (short) 1));\n            store.add(List.of(doc1, doc2, doc3));\n            \n            Filter.Expression priorityFilter = new Filter.Expression(Filter.ExpressionType.GT, new Filter.Key(\"priority\"), new Filter.Value((short) 1));\n            Filter.Expression typeFilter = new Filter.Expression(Filter.ExpressionType.EQ, new Filter.Key(\"type\"), new Filter.Value(\"A\"));\n            Filter.Expression complexFilter = new Filter.Expression(Filter.ExpressionType.AND, typeFilter, priorityFilter);\n            store.delete(complexFilter);\n            var results = store.similaritySearch(SearchRequest.builder().query(\"Content\").topK(5).similarityThresholdAll().build());\n            assertThat(results).hasSize(2);\n            assertThat(results.stream().map(doc -> doc.getMetadata().get(\"type\")).collect(Collectors.toList())).containsExactlyInAnyOrder(\"A\", \"B\");\n            assertThat(results.stream().map(doc -> ((Short) doc.getMetadata().get(\"priority\")).intValue()).collect(Collectors.toList())).containsExactlyInAnyOrder(1, 1);\n        }\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraRichSchemaVectorStoreIT.java" : {
              "addAndSearch" : {
                "definition" : "@Test\nvoid addAndSearch() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Neptunes gravity makes its atmosphere\").topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents.get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Neptunes gravity makes its atmosphere\");\n            assertThat(resultDoc.getMetadata()).hasSize(3);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"id\", \"revision\", DocumentMetadata.DISTANCE.value());\n            \n            store.delete(documents.stream().map(doc -> doc.getId()).toList());\n            results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).isEmpty();\n        }\n    });\n}"
              },
              "addAndSearchPoormansBench" : {
                "definition" : "@Test\nvoid addAndSearchPoormansBench() {\n    \n    int nThreads = CassandraVectorStore.DEFAULT_ADD_CONCURRENCY;\n    \n    int runs = 10;\n    \n    int docsPerAdd = 12;\n    int rounds = 3;\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = storeBuilder(context, List.of()).fixedThreadPoolExecutorSize(nThreads).build()) {\n            var executor = Executors.newFixedThreadPool((int) (nThreads * 1.2));\n            for (int k = 0; k < rounds; ++k) {\n                long start = System.nanoTime();\n                var futures = new CompletableFuture[runs];\n                for (int j = 0; j < runs; ++j) {\n                    futures[j] = CompletableFuture.runAsync(() -> {\n                        List<Document> documents = new ArrayList<>();\n                        for (int i = docsPerAdd; i >= 0; --i) {\n                            documents.add(new Document(RandomStringUtils.randomAlphanumeric(4) + \"§¶\" + ThreadLocalRandom.current().nextInt(1, 10), RandomStringUtils.randomAlphanumeric(1024), Map.of(\"revision\", ThreadLocalRandom.current().nextInt(1, 100000), \"id\", 1000)));\n                        }\n                        store.add(documents);\n                        var results = store.similaritySearch(SearchRequest.builder().query(RandomStringUtils.randomAlphanumeric(20)).topK(10).build());\n                        assertThat(results).hasSize(10);\n                    }, executor);\n                }\n                CompletableFuture.allOf(futures).join();\n                long time = System.nanoTime() - start;\n                logger.info(\"add+search took an average of {} ms\", Duration.ofNanos(time / runs).toMillis());\n            }\n        }\n    });\n}"
              },
              "searchWithPartitionFilter" : {
                "definition" : "@Test\nvoid searchWithPartitionFilter() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"wiki == 'simplewiki' && language == 'en' && title == 'Neptune'\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            results = store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"wiki == 'simplewiki' && language == 'en' && title == 'Neptune' && id == 558\").build());\n            assertThat(results).hasSize(3);\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"NOT(wiki == 'simplewiki' && language == 'en' && title == 'Neptune' && id == 1)\").build()));\n        }\n    });\n}"
              },
              "unsearchableFilters" : {
                "definition" : "@Test\nvoid unsearchableFilters() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).build());\n            assertThat(results).hasSize(3);\n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"revision == 9385813\").build()));\n        }\n    });\n}"
              },
              "searchWithFilters" : {
                "definition" : "@Test\nvoid searchWithFilters() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id == 558\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id > 557\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id >= 558\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            \n            \n            \n            \n            \n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id > 557 && \\\"chunk_no\\\" == 1\").build()));\n            \n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"id == 558 || revision == 2020\").build()));\n            \n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"NOT(id == 557 || revision == 2020)\").build()));\n        }\n    });\n}"
              },
              "searchWithFilterOnPrimaryKeys" : {
                "definition" : "@Test\nvoid searchWithFilterOnPrimaryKeys() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        List<SchemaColumn> overrides = List.of(new SchemaColumn(\"title\", DataTypes.TEXT, CassandraVectorStore.SchemaColumnTags.INDEXED), new SchemaColumn(\"chunk_no\", DataTypes.INT, CassandraVectorStore.SchemaColumnTags.INDEXED));\n        try (CassandraVectorStore store = createStore(context, overrides, false, true)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).build());\n            assertThat(results).hasSize(3);\n            store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id > 557 && \\\"chunk_no\\\" == 1\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            \n            \n            \n            \n            \n            \n            \n            \n            \n        }\n    });\n}"
              },
              "documentUpdate" : {
                "definition" : "@Test\nvoid documentUpdate() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getText()).contains(URANUS_ORBIT_QUERY);\n            assertThat(resultDoc.getMetadata()).containsKey(\"revision\");\n            String newContent = \"The World is Big and Salvation Lurks Around the Corner\";\n            Document sameIdDocument = new Document(documents.get(1).getId(), newContent, Collections.emptyMap());\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            store.delete(List.of(sameIdDocument.getId()));\n            results = store.similaritySearch(SearchRequest.builder().query(newContent).topK(1).build());\n            assertThat(results).hasSize(1);\n            resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isNotEqualTo(sameIdDocument.getId());\n            assertThat(resultDoc.getText()).doesNotContain(newContent);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"id\", \"revision\", DocumentMetadata.DISTANCE.value());\n        }\n    });\n}"
              },
              "searchWithThreshold" : {
                "definition" : "@Test\nvoid searchWithThreshold() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> fullResult = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().build());\n            List<Double> scores = fullResult.stream().map(Document::getScore).toList();\n            assertThat(scores).hasSize(3);\n            double similarityThreshold = (scores.get(0) + scores.get(1)) / 2;\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThreshold(similarityThreshold).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents.get(1).getId());\n            assertThat(resultDoc.getText()).contains(URANUS_ORBIT_QUERY);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"id\", \"revision\", DocumentMetadata.DISTANCE.value());\n            assertThat(resultDoc.getScore()).isGreaterThanOrEqualTo(similarityThreshold);\n        }\n    });\n}"
              }
            }
          }
        }, {
          "name" : "getStatement",
          "arguments" : [ "Message msg" ],
          "accessModifier" : "",
          "methodsCalled" : [ {
            "name" : "getMessageType",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "msg", "USER", "ASSISTANT" ],
          "annotations" : [ ],
          "returnType" : "PreparedStatement",
          "comments" : null,
          "methodDefinition" : "PreparedStatement getStatement(Message msg) {\n    return switch(msg.getMessageType()) {\n        case USER ->\n            this.addUserStmt;\n        case ASSISTANT ->\n            this.addAssistantStmt;\n        default ->\n            throw new IllegalArgumentException(\"Cant add type \" + msg);\n    };\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemory.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "clear",
          "arguments" : [ "String sessionId" ],
          "accessModifier" : "public",
          "methodsCalled" : [ {
            "name" : "apply",
            "arguments" : [ "sessionId" ],
            "body" : ""
          }, {
            "name" : "boundStatementBuilder",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "size",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getPrimaryKeyColumn",
            "arguments" : [ "k" ],
            "body" : ""
          }, {
            "name" : "set",
            "arguments" : [ "keyColumn.name()", "primaryKeys.get(k)", "keyColumn.javaType()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "k" ],
            "body" : "@Override\npublic List<Message> get(String sessionId, int lastN) {\n    List<Object> primaryKeys = this.conf.primaryKeyTranslator.apply(sessionId);\n    BoundStatementBuilder builder = this.getStmt.boundStatementBuilder().setInt(\"lastN\", lastN);\n    for (int k = 0; k < primaryKeys.size(); ++k) {\n        SchemaColumn keyColumn = this.conf.getPrimaryKeyColumn(k);\n        builder = builder.set(keyColumn.name(), primaryKeys.get(k), keyColumn.javaType());\n    }\n    List<Message> messages = new ArrayList<>();\n    for (Row r : this.conf.session.execute(builder.build())) {\n        String assistant = r.getString(this.conf.assistantColumn);\n        String user = r.getString(this.conf.userColumn);\n        if (null != assistant) {\n            messages.add(new AssistantMessage(assistant));\n        }\n        if (null != user) {\n            messages.add(new UserMessage(user));\n        }\n    }\n    return messages;\n}"
          }, {
            "name" : "javaType",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "execute",
            "arguments" : [ "builder.build()" ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "sessionId", "k", "primaryKeys", "builder", "keyColumn" ],
          "annotations" : [ "Override" ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "@Override\npublic void clear(String sessionId) {\n    List<Object> primaryKeys = this.conf.primaryKeyTranslator.apply(sessionId);\n    BoundStatementBuilder builder = this.deleteStmt.boundStatementBuilder();\n    for (int k = 0; k < primaryKeys.size(); ++k) {\n        SchemaColumn keyColumn = this.conf.getPrimaryKeyColumn(k);\n        builder = builder.set(keyColumn.name(), primaryKeys.get(k), keyColumn.javaType());\n    }\n    this.conf.session.execute(builder.build());\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemory.java",
          "test_exists" : true,
          "test_functions" : {
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreObservationIT.java" : {
              "observationVectorStoreAddAndQueryOperations" : {
                "definition" : "@Test\nvoid observationVectorStoreAddAndQueryOperations() {\n    this.contextRunner.run(context -> {\n        VectorStore vectorStore = context.getBean(VectorStore.class);\n        TestObservationRegistry observationRegistry = context.getBean(TestObservationRegistry.class);\n        vectorStore.add(this.documents);\n        TestObservationRegistryAssert.assertThat(observationRegistry).doesNotHaveAnyRemainingCurrentObservation().hasObservationWithNameEqualTo(DefaultVectorStoreObservationConvention.DEFAULT_NAME).that().hasContextualNameEqualTo(\"%s add\".formatted(VectorStoreProvider.CASSANDRA.value())).hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_OPERATION_NAME.asString(), \"add\").hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_SYSTEM.asString(), VectorStoreProvider.CASSANDRA.value()).hasLowCardinalityKeyValue(LowCardinalityKeyNames.SPRING_AI_KIND.asString(), SpringAiKind.VECTOR_STORE.value()).doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_QUERY_CONTENT.asString()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_DIMENSION_COUNT.asString(), \"384\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_COLLECTION_NAME.asString(), CassandraVectorStore.DEFAULT_TABLE_NAME).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_NAMESPACE.asString(), \"test_springframework\").doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_FIELD_NAME.asString()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_SEARCH_SIMILARITY_METRIC.asString(), VectorStoreSimilarityMetric.COSINE.value()).doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_QUERY_TOP_K.asString()).doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_QUERY_SIMILARITY_THRESHOLD.asString()).hasBeenStarted().hasBeenStopped();\n        observationRegistry.clear();\n        List<Document> results = vectorStore.similaritySearch(SearchRequest.builder().query(\"What is Great Depression\").topK(1).build());\n        assertThat(results).isNotEmpty();\n        TestObservationRegistryAssert.assertThat(observationRegistry).doesNotHaveAnyRemainingCurrentObservation().hasObservationWithNameEqualTo(DefaultVectorStoreObservationConvention.DEFAULT_NAME).that().hasContextualNameEqualTo(\"%s query\".formatted(VectorStoreProvider.CASSANDRA.value())).hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_OPERATION_NAME.asString(), \"query\").hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_SYSTEM.asString(), VectorStoreProvider.CASSANDRA.value()).hasLowCardinalityKeyValue(LowCardinalityKeyNames.SPRING_AI_KIND.asString(), SpringAiKind.VECTOR_STORE.value()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_QUERY_CONTENT.asString(), \"What is Great Depression\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_DIMENSION_COUNT.asString(), \"384\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_COLLECTION_NAME.asString(), CassandraVectorStore.DEFAULT_TABLE_NAME).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_NAMESPACE.asString(), \"test_springframework\").doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_FIELD_NAME.asString()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_SEARCH_SIMILARITY_METRIC.asString(), VectorStoreSimilarityMetric.COSINE.value()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_QUERY_TOP_K.asString(), \"1\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_QUERY_SIMILARITY_THRESHOLD.asString(), \"0.0\").hasBeenStarted().hasBeenStopped();\n    });\n}"
              }
            }
          }
        }, {
          "name" : "get",
          "arguments" : [ "String sessionId", "int lastN" ],
          "accessModifier" : "public",
          "methodsCalled" : [ {
            "name" : "apply",
            "arguments" : [ "sessionId" ],
            "body" : ""
          }, {
            "name" : "setInt",
            "arguments" : [ "\"lastN\"", "lastN" ],
            "body" : ""
          }, {
            "name" : "boundStatementBuilder",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "size",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getPrimaryKeyColumn",
            "arguments" : [ "k" ],
            "body" : ""
          }, {
            "name" : "set",
            "arguments" : [ "keyColumn.name()", "primaryKeys.get(k)", "keyColumn.javaType()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "k" ],
            "body" : "@Override\npublic List<Message> get(String sessionId, int lastN) {\n    List<Object> primaryKeys = this.conf.primaryKeyTranslator.apply(sessionId);\n    BoundStatementBuilder builder = this.getStmt.boundStatementBuilder().setInt(\"lastN\", lastN);\n    for (int k = 0; k < primaryKeys.size(); ++k) {\n        SchemaColumn keyColumn = this.conf.getPrimaryKeyColumn(k);\n        builder = builder.set(keyColumn.name(), primaryKeys.get(k), keyColumn.javaType());\n    }\n    List<Message> messages = new ArrayList<>();\n    for (Row r : this.conf.session.execute(builder.build())) {\n        String assistant = r.getString(this.conf.assistantColumn);\n        String user = r.getString(this.conf.userColumn);\n        if (null != assistant) {\n            messages.add(new AssistantMessage(assistant));\n        }\n        if (null != user) {\n            messages.add(new UserMessage(user));\n        }\n    }\n    return messages;\n}"
          }, {
            "name" : "javaType",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "execute",
            "arguments" : [ "builder.build()" ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getString",
            "arguments" : [ "this.conf.assistantColumn" ],
            "body" : ""
          }, {
            "name" : "getString",
            "arguments" : [ "this.conf.userColumn" ],
            "body" : ""
          }, {
            "name" : "add",
            "arguments" : [ "new AssistantMessage(assistant)" ],
            "body" : "@Override\npublic void add(String conversationId, List<Message> messages) {\n    final AtomicLong instantSeq = new AtomicLong(Instant.now().toEpochMilli());\n    messages.forEach(msg -> {\n        if (msg.getMetadata().containsKey(CONVERSATION_TS)) {\n            msg.getMetadata().put(CONVERSATION_TS, Instant.ofEpochMilli(instantSeq.getAndIncrement()));\n        }\n        add(conversationId, msg);\n    });\n}"
          }, {
            "name" : "add",
            "arguments" : [ "new UserMessage(user)" ],
            "body" : "@Override\npublic void add(String conversationId, List<Message> messages) {\n    final AtomicLong instantSeq = new AtomicLong(Instant.now().toEpochMilli());\n    messages.forEach(msg -> {\n        if (msg.getMetadata().containsKey(CONVERSATION_TS)) {\n            msg.getMetadata().put(CONVERSATION_TS, Instant.ofEpochMilli(instantSeq.getAndIncrement()));\n        }\n        add(conversationId, msg);\n    });\n}"
          } ],
          "usedEntities" : [ "sessionId", "lastN", "k", "primaryKeys", "builder", "keyColumn", "r", "assistant", "messages", "user" ],
          "annotations" : [ "Override" ],
          "returnType" : "List<Message>",
          "comments" : null,
          "methodDefinition" : "@Override\npublic List<Message> get(String sessionId, int lastN) {\n    List<Object> primaryKeys = this.conf.primaryKeyTranslator.apply(sessionId);\n    BoundStatementBuilder builder = this.getStmt.boundStatementBuilder().setInt(\"lastN\", lastN);\n    for (int k = 0; k < primaryKeys.size(); ++k) {\n        SchemaColumn keyColumn = this.conf.getPrimaryKeyColumn(k);\n        builder = builder.set(keyColumn.name(), primaryKeys.get(k), keyColumn.javaType());\n    }\n    List<Message> messages = new ArrayList<>();\n    for (Row r : this.conf.session.execute(builder.build())) {\n        String assistant = r.getString(this.conf.assistantColumn);\n        String user = r.getString(this.conf.userColumn);\n        if (null != assistant) {\n            messages.add(new AssistantMessage(assistant));\n        }\n        if (null != user) {\n            messages.add(new UserMessage(user));\n        }\n    }\n    return messages;\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemory.java",
          "test_exists" : true,
          "test_functions" : {
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreIT.java" : {
              "addAndSearch" : {
                "definition" : "@Test\nvoid addAndSearch() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"meta1\", DataTypes.TEXT), new SchemaColumn(\"meta2\", DataTypes.TEXT))) {\n            List<Document> documents = documents();\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents().get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Spring AI provides abstractions that serve as the foundation for developing AI applications.\");\n            assertThat(resultDoc.getMetadata()).hasSize(2);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"meta1\", DocumentMetadata.DISTANCE.value());\n            \n            store.delete(documents().stream().map(doc -> doc.getId()).toList());\n            results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).isEmpty();\n        }\n    });\n}"
              },
              "addAndSearchReturnEmbeddings" : {
                "definition" : "@Test\nvoid addAndSearchReturnEmbeddings() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore.Builder builder = storeBuilder(context.getBean(CqlSession.class), context.getBean(EmbeddingModel.class)).returnEmbeddings(true);\n        try (CassandraVectorStore store = createTestStore(context, builder)) {\n            List<Document> documents = documents();\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents().get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Spring AI provides abstractions that serve as the foundation for developing AI applications.\");\n            assertThat(resultDoc.getMetadata()).hasSize(1);\n            assertThat(resultDoc.getMetadata()).containsKey(DocumentMetadata.DISTANCE.value());\n            \n            store.delete(documents().stream().map(doc -> doc.getId()).toList());\n            results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).isEmpty();\n        }\n    });\n}"
              },
              "searchWithPartitionFilter" : {
                "definition" : "@Test\nvoid searchWithPartitionFilter() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"BG\", \"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"year\", (short) 2020));\n            var nlDocument = new Document(\"NL\", \"The World is Big and Salvation Lurks Around the Corner\", java.util.Collections.emptyMap());\n            var bgDocument2 = new Document(\"BG2\", \"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"%s == 'NL'\", CassandraVectorStore.DEFAULT_ID_NAME)).build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(nlDocument.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"%s == 'BG2'\", CassandraVectorStore.DEFAULT_ID_NAME)).build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(bgDocument2.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"%s == 'BG' && year == 2020\", CassandraVectorStore.DEFAULT_ID_NAME)).build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(bgDocument.getId());\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"NOT(%s == 'BG' && year == 2020)\", CassandraVectorStore.DEFAULT_ID_NAME)).build()));\n        }\n    });\n}"
              },
              "searchWithFilters" : {
                "definition" : "@Test\nvoid searchWithFilters() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"country\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'NL'\").build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(nlDocument.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'BG'\").build());\n            assertThat(results).hasSize(2);\n            assertThat(results.get(0).getId()).isIn(bgDocument.getId(), bgDocument2.getId());\n            assertThat(results.get(1).getId()).isIn(bgDocument.getId(), bgDocument2.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'BG' && year == 2020\").build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(bgDocument.getId());\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'BG' || year == 2020\").build()));\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"NOT(country == 'BG' && year == 2020)\").build()));\n        }\n    });\n}"
              },
              "documentUpdate" : {
                "definition" : "@Test\nvoid documentUpdate() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            Document document = new Document(UUID.randomUUID().toString(), \"Spring AI rocks!!\", Collections.singletonMap(\"meta1\", \"meta1\"));\n            store.add(List.of(document));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(5).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(document.getId());\n            assertThat(resultDoc.getText()).isEqualTo(\"Spring AI rocks!!\");\n            assertThat(resultDoc.getMetadata()).containsKey(\"meta1\");\n            Document sameIdDocument = new Document(document.getId(), \"The World is Big and Salvation Lurks Around the Corner\", Collections.singletonMap(\"meta2\", \"meta2\"));\n            store.add(List.of(sameIdDocument));\n            results = store.similaritySearch(SearchRequest.builder().query(\"FooBar\").topK(5).build());\n            assertThat(results).hasSize(1);\n            resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(document.getId());\n            assertThat(resultDoc.getText()).isEqualTo(\"The World is Big and Salvation Lurks Around the Corner\");\n            assertThat(resultDoc.getMetadata()).containsKeys(\"meta2\", DocumentMetadata.DISTANCE.value());\n            store.delete(List.of(document.getId()));\n        }\n    });\n}"
              },
              "searchWithThreshold" : {
                "definition" : "@Test\nvoid searchWithThreshold() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            store.add(documents());\n            List<Document> fullResult = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(5).similarityThresholdAll().build());\n            List<Double> scores = fullResult.stream().map(Document::getScore).toList();\n            assertThat(scores).hasSize(3);\n            double similarityThreshold = (scores.get(0) + scores.get(1)) / 2;\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(5).similarityThreshold(similarityThreshold).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents().get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Spring AI provides abstractions that serve as the foundation for developing AI applications.\");\n            assertThat(resultDoc.getMetadata()).containsKeys(\"meta1\", DocumentMetadata.DISTANCE.value());\n            assertThat(resultDoc.getScore()).isGreaterThanOrEqualTo(similarityThreshold);\n        }\n    });\n}"
              },
              "deleteByFilter" : {
                "definition" : "@Test\nprotected void deleteByFilter() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"country\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            \n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            \n            Filter.Expression filterExpression = new Filter.Expression(Filter.ExpressionType.EQ, new Filter.Key(\"country\"), new Filter.Value(\"BG\"));\n            store.delete(filterExpression);\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getMetadata()).containsEntry(\"country\", \"NL\");\n        }\n    });\n}"
              },
              "deleteWithStringFilterExpression" : {
                "definition" : "@Test\nprotected void deleteWithStringFilterExpression() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"country\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            \n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            store.delete(\"country == 'BG'\");\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getMetadata()).containsEntry(\"country\", \"NL\");\n        }\n    });\n}"
              },
              "deleteWithComplexFilterExpression" : {
                "definition" : "@Test\nvoid deleteWithComplexFilterExpression() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"type\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"priority\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var doc1 = new Document(\"Content 1\", Map.of(\"type\", \"A\", \"priority\", (short) 1));\n            var doc2 = new Document(\"Content 2\", Map.of(\"type\", \"A\", \"priority\", (short) 2));\n            var doc3 = new Document(\"Content 3\", Map.of(\"type\", \"B\", \"priority\", (short) 1));\n            store.add(List.of(doc1, doc2, doc3));\n            \n            Filter.Expression priorityFilter = new Filter.Expression(Filter.ExpressionType.GT, new Filter.Key(\"priority\"), new Filter.Value((short) 1));\n            Filter.Expression typeFilter = new Filter.Expression(Filter.ExpressionType.EQ, new Filter.Key(\"type\"), new Filter.Value(\"A\"));\n            Filter.Expression complexFilter = new Filter.Expression(Filter.ExpressionType.AND, typeFilter, priorityFilter);\n            store.delete(complexFilter);\n            var results = store.similaritySearch(SearchRequest.builder().query(\"Content\").topK(5).similarityThresholdAll().build());\n            assertThat(results).hasSize(2);\n            assertThat(results.stream().map(doc -> doc.getMetadata().get(\"type\")).collect(Collectors.toList())).containsExactlyInAnyOrder(\"A\", \"B\");\n            assertThat(results.stream().map(doc -> ((Short) doc.getMetadata().get(\"priority\")).intValue()).collect(Collectors.toList())).containsExactlyInAnyOrder(1, 1);\n        }\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraRichSchemaVectorStoreIT.java" : {
              "storeBuilder" : {
                "definition" : "static CassandraVectorStore.Builder storeBuilder(ApplicationContext context, List<CassandraVectorStore.SchemaColumn> columnOverrides) throws IOException {\n    Optional<CassandraVectorStore.SchemaColumn> wikiOverride = columnOverrides.stream().filter(f -> \"wiki\".equals(f.name())).findFirst();\n    Optional<CassandraVectorStore.SchemaColumn> langOverride = columnOverrides.stream().filter(f -> \"language\".equals(f.name())).findFirst();\n    Optional<CassandraVectorStore.SchemaColumn> titleOverride = columnOverrides.stream().filter(f -> \"title\".equals(f.name())).findFirst();\n    Optional<CassandraVectorStore.SchemaColumn> chunkNoOverride = columnOverrides.stream().filter(f -> \"chunk_no\".equals(f.name())).findFirst();\n    var wikiSC = wikiOverride.orElse(new CassandraVectorStore.SchemaColumn(\"wiki\", DataTypes.TEXT));\n    var langSC = langOverride.orElse(new CassandraVectorStore.SchemaColumn(\"language\", DataTypes.TEXT));\n    var titleSC = titleOverride.orElse(new CassandraVectorStore.SchemaColumn(\"title\", DataTypes.TEXT));\n    var chunkNoSC = chunkNoOverride.orElse(new CassandraVectorStore.SchemaColumn(\"chunk_no\", DataTypes.INT));\n    List<CassandraVectorStore.SchemaColumn> partitionKeys = List.of(wikiSC, langSC, titleSC);\n    List<CassandraVectorStore.SchemaColumn> clusteringKeys = List.of(chunkNoSC);\n    return CassandraVectorStore.builder(context.getBean(EmbeddingModel.class)).session(context.getBean(CqlSession.class)).keyspace(\"test_wikidata\").table(\"articles\").partitionKeys(partitionKeys).clusteringKeys(clusteringKeys).contentColumnName(\"body\").embeddingColumnName(\"all_minilm_l6_v2_embedding\").indexName(\"all_minilm_l6_v2_ann\").addMetadataColumns(new CassandraVectorStore.SchemaColumn(\"revision\", DataTypes.INT), new CassandraVectorStore.SchemaColumn(\"id\", DataTypes.INT, CassandraVectorStore.SchemaColumnTags.INDEXED)).\n    \n    primaryKeyTranslator((List<Object> primaryKeys) -> {\n        if (primaryKeys.isEmpty()) {\n            return \"test§¶0\";\n        }\n        return String.format(\"%s§¶%s\", primaryKeys.get(2), primaryKeys.get(3));\n    }).documentIdTranslator(id -> {\n        String[] parts = id.split(\"§¶\");\n        String title = parts[0];\n        int chunk_no = 0 < parts.length ? Integer.parseInt(parts[1]) : 0;\n        return List.of(\"simplewiki\", \"en\", title, chunk_no);\n    });\n}"
              },
              "addAndSearch" : {
                "definition" : "@Test\nvoid addAndSearch() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Neptunes gravity makes its atmosphere\").topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents.get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Neptunes gravity makes its atmosphere\");\n            assertThat(resultDoc.getMetadata()).hasSize(3);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"id\", \"revision\", DocumentMetadata.DISTANCE.value());\n            \n            store.delete(documents.stream().map(doc -> doc.getId()).toList());\n            results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).isEmpty();\n        }\n    });\n}"
              },
              "searchWithPartitionFilter" : {
                "definition" : "@Test\nvoid searchWithPartitionFilter() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"wiki == 'simplewiki' && language == 'en' && title == 'Neptune'\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            results = store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"wiki == 'simplewiki' && language == 'en' && title == 'Neptune' && id == 558\").build());\n            assertThat(results).hasSize(3);\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"NOT(wiki == 'simplewiki' && language == 'en' && title == 'Neptune' && id == 1)\").build()));\n        }\n    });\n}"
              },
              "searchWithFilters" : {
                "definition" : "@Test\nvoid searchWithFilters() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id == 558\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id > 557\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id >= 558\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            \n            \n            \n            \n            \n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id > 557 && \\\"chunk_no\\\" == 1\").build()));\n            \n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"id == 558 || revision == 2020\").build()));\n            \n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"NOT(id == 557 || revision == 2020)\").build()));\n        }\n    });\n}"
              },
              "searchWithFilterOnPrimaryKeys" : {
                "definition" : "@Test\nvoid searchWithFilterOnPrimaryKeys() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        List<SchemaColumn> overrides = List.of(new SchemaColumn(\"title\", DataTypes.TEXT, CassandraVectorStore.SchemaColumnTags.INDEXED), new SchemaColumn(\"chunk_no\", DataTypes.INT, CassandraVectorStore.SchemaColumnTags.INDEXED));\n        try (CassandraVectorStore store = createStore(context, overrides, false, true)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).build());\n            assertThat(results).hasSize(3);\n            store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id > 557 && \\\"chunk_no\\\" == 1\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            \n            \n            \n            \n            \n            \n            \n            \n            \n        }\n    });\n}"
              },
              "documentUpdate" : {
                "definition" : "@Test\nvoid documentUpdate() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getText()).contains(URANUS_ORBIT_QUERY);\n            assertThat(resultDoc.getMetadata()).containsKey(\"revision\");\n            String newContent = \"The World is Big and Salvation Lurks Around the Corner\";\n            Document sameIdDocument = new Document(documents.get(1).getId(), newContent, Collections.emptyMap());\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            store.delete(List.of(sameIdDocument.getId()));\n            results = store.similaritySearch(SearchRequest.builder().query(newContent).topK(1).build());\n            assertThat(results).hasSize(1);\n            resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isNotEqualTo(sameIdDocument.getId());\n            assertThat(resultDoc.getText()).doesNotContain(newContent);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"id\", \"revision\", DocumentMetadata.DISTANCE.value());\n        }\n    });\n}"
              },
              "searchWithThreshold" : {
                "definition" : "@Test\nvoid searchWithThreshold() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> fullResult = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().build());\n            List<Double> scores = fullResult.stream().map(Document::getScore).toList();\n            assertThat(scores).hasSize(3);\n            double similarityThreshold = (scores.get(0) + scores.get(1)) / 2;\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThreshold(similarityThreshold).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents.get(1).getId());\n            assertThat(resultDoc.getText()).contains(URANUS_ORBIT_QUERY);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"id\", \"revision\", DocumentMetadata.DISTANCE.value());\n            assertThat(resultDoc.getScore()).isGreaterThanOrEqualTo(similarityThreshold);\n        }\n    });\n}"
              }
            }
          }
        }, {
          "name" : "prepareAddStmt",
          "arguments" : [ "String column" ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "insertInto",
            "arguments" : [ "this.conf.schema.keyspace()", "this.conf.schema.table()" ],
            "body" : ""
          }, {
            "name" : "keyspace",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "table",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "partitionKeys",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "value",
            "arguments" : [ "c.name()", "QueryBuilder.bindMarker(c.name())" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "bindMarker",
            "arguments" : [ "c.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "clusteringKeys",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "value",
            "arguments" : [ "c.name()", "QueryBuilder.bindMarker(c.name())" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "bindMarker",
            "arguments" : [ "c.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "value",
            "arguments" : [ "column", "QueryBuilder.bindMarker(\"message\")" ],
            "body" : ""
          }, {
            "name" : "bindMarker",
            "arguments" : [ "\"message\"" ],
            "body" : ""
          }, {
            "name" : "prepare",
            "arguments" : [ "stmt.build()" ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "QueryBuilder", "stmt", "stmtStart", "c", "column" ],
          "annotations" : [ ],
          "returnType" : "PreparedStatement",
          "comments" : null,
          "methodDefinition" : "private PreparedStatement prepareAddStmt(String column) {\n    RegularInsert stmt = null;\n    InsertInto stmtStart = QueryBuilder.insertInto(this.conf.schema.keyspace(), this.conf.schema.table());\n    for (var c : this.conf.schema.partitionKeys()) {\n        stmt = (null != stmt ? stmt : stmtStart).value(c.name(), QueryBuilder.bindMarker(c.name()));\n    }\n    for (var c : this.conf.schema.clusteringKeys()) {\n        stmt = stmt.value(c.name(), QueryBuilder.bindMarker(c.name()));\n    }\n    stmt = stmt.value(column, QueryBuilder.bindMarker(\"message\"));\n    return this.conf.session.prepare(stmt.build());\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemory.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "prepareGetStatement",
          "arguments" : [ ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "all",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "selectFrom",
            "arguments" : [ "this.conf.schema.keyspace()", "this.conf.schema.table()" ],
            "body" : ""
          }, {
            "name" : "keyspace",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "table",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "partitionKeys",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "isEqualTo",
            "arguments" : [ "QueryBuilder.bindMarker(c.name())" ],
            "body" : ""
          }, {
            "name" : "whereColumn",
            "arguments" : [ "c.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "bindMarker",
            "arguments" : [ "c.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "size",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "clusteringKeys",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "i" ],
            "body" : "@Override\npublic List<Message> get(String sessionId, int lastN) {\n    List<Object> primaryKeys = this.conf.primaryKeyTranslator.apply(sessionId);\n    BoundStatementBuilder builder = this.getStmt.boundStatementBuilder().setInt(\"lastN\", lastN);\n    for (int k = 0; k < primaryKeys.size(); ++k) {\n        SchemaColumn keyColumn = this.conf.getPrimaryKeyColumn(k);\n        builder = builder.set(keyColumn.name(), primaryKeys.get(k), keyColumn.javaType());\n    }\n    List<Message> messages = new ArrayList<>();\n    for (Row r : this.conf.session.execute(builder.build())) {\n        String assistant = r.getString(this.conf.assistantColumn);\n        String user = r.getString(this.conf.userColumn);\n        if (null != assistant) {\n            messages.add(new AssistantMessage(assistant));\n        }\n        if (null != user) {\n            messages.add(new UserMessage(user));\n        }\n    }\n    return messages;\n}"
          }, {
            "name" : "clusteringKeys",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "isEqualTo",
            "arguments" : [ "QueryBuilder.bindMarker(columnName)" ],
            "body" : ""
          }, {
            "name" : "whereColumn",
            "arguments" : [ "columnName" ],
            "body" : ""
          }, {
            "name" : "bindMarker",
            "arguments" : [ "columnName" ],
            "body" : ""
          }, {
            "name" : "limit",
            "arguments" : [ "QueryBuilder.bindMarker(\"lastN\")" ],
            "body" : ""
          }, {
            "name" : "bindMarker",
            "arguments" : [ "\"lastN\"" ],
            "body" : ""
          }, {
            "name" : "prepare",
            "arguments" : [ "stmt.build()" ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "QueryBuilder", "stmt", "c", "i", "columnName" ],
          "annotations" : [ ],
          "returnType" : "PreparedStatement",
          "comments" : null,
          "methodDefinition" : "private PreparedStatement prepareGetStatement() {\n    Select stmt = QueryBuilder.selectFrom(this.conf.schema.keyspace(), this.conf.schema.table()).all();\n    for (var c : this.conf.schema.partitionKeys()) {\n        stmt = stmt.whereColumn(c.name()).isEqualTo(QueryBuilder.bindMarker(c.name()));\n    }\n    for (int i = 0; i + 1 < this.conf.schema.clusteringKeys().size(); ++i) {\n        String columnName = this.conf.schema.clusteringKeys().get(i).name();\n        stmt = stmt.whereColumn(columnName).isEqualTo(QueryBuilder.bindMarker(columnName));\n    }\n    stmt = stmt.limit(QueryBuilder.bindMarker(\"lastN\"));\n    return this.conf.session.prepare(stmt.build());\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemory.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "prepareDeleteStmt",
          "arguments" : [ ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "deleteFrom",
            "arguments" : [ "this.conf.schema.keyspace()", "this.conf.schema.table()" ],
            "body" : ""
          }, {
            "name" : "keyspace",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "table",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "partitionKeys",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "isEqualTo",
            "arguments" : [ "QueryBuilder.bindMarker(c.name())" ],
            "body" : ""
          }, {
            "name" : "whereColumn",
            "arguments" : [ "c.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "bindMarker",
            "arguments" : [ "c.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "size",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "clusteringKeys",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "i" ],
            "body" : "@Override\npublic List<Message> get(String sessionId, int lastN) {\n    List<Object> primaryKeys = this.conf.primaryKeyTranslator.apply(sessionId);\n    BoundStatementBuilder builder = this.getStmt.boundStatementBuilder().setInt(\"lastN\", lastN);\n    for (int k = 0; k < primaryKeys.size(); ++k) {\n        SchemaColumn keyColumn = this.conf.getPrimaryKeyColumn(k);\n        builder = builder.set(keyColumn.name(), primaryKeys.get(k), keyColumn.javaType());\n    }\n    List<Message> messages = new ArrayList<>();\n    for (Row r : this.conf.session.execute(builder.build())) {\n        String assistant = r.getString(this.conf.assistantColumn);\n        String user = r.getString(this.conf.userColumn);\n        if (null != assistant) {\n            messages.add(new AssistantMessage(assistant));\n        }\n        if (null != user) {\n            messages.add(new UserMessage(user));\n        }\n    }\n    return messages;\n}"
          }, {
            "name" : "clusteringKeys",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "isEqualTo",
            "arguments" : [ "QueryBuilder.bindMarker(columnName)" ],
            "body" : ""
          }, {
            "name" : "whereColumn",
            "arguments" : [ "columnName" ],
            "body" : ""
          }, {
            "name" : "bindMarker",
            "arguments" : [ "columnName" ],
            "body" : ""
          }, {
            "name" : "prepare",
            "arguments" : [ "stmt.build()" ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "QueryBuilder", "stmt", "stmtStart", "c", "i", "columnName" ],
          "annotations" : [ ],
          "returnType" : "PreparedStatement",
          "comments" : null,
          "methodDefinition" : "private PreparedStatement prepareDeleteStmt() {\n    Delete stmt = null;\n    DeleteSelection stmtStart = QueryBuilder.deleteFrom(this.conf.schema.keyspace(), this.conf.schema.table());\n    for (var c : this.conf.schema.partitionKeys()) {\n        stmt = (null != stmt ? stmt : stmtStart).whereColumn(c.name()).isEqualTo(QueryBuilder.bindMarker(c.name()));\n    }\n    for (int i = 0; i + 1 < this.conf.schema.clusteringKeys().size(); ++i) {\n        String columnName = this.conf.schema.clusteringKeys().get(i).name();\n        stmt = stmt.whereColumn(columnName).isEqualTo(QueryBuilder.bindMarker(columnName));\n    }\n    return this.conf.session.prepare(stmt.build());\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemory.java",
          "test_exists" : false,
          "test_functions" : { }
        } ],
        "fields" : [ {
          "name" : "CONVERSATION_TS",
          "accessModifier" : "public,static,final",
          "value" : "CassandraChatMemory.class.getSimpleName() + \"_message_timestamp\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "conf",
          "accessModifier" : "final",
          "value" : null,
          "type" : "CassandraChatMemoryConfig",
          "comments" : null
        }, {
          "name" : "addUserStmt",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "PreparedStatement",
          "comments" : null
        }, {
          "name" : "addAssistantStmt",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "PreparedStatement",
          "comments" : null
        }, {
          "name" : "getStmt",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "PreparedStatement",
          "comments" : null
        }, {
          "name" : "deleteStmt",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "PreparedStatement",
          "comments" : null
        } ],
        "constructors" : [ {
          "name" : "CassandraChatMemory",
          "arguments" : [ "CassandraChatMemoryConfig config" ],
          "accessModifier" : "public",
          "methodsCalled" : [ {
            "name" : "ensureSchemaExists",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "prepareAddStmt",
            "arguments" : [ "this.conf.userColumn" ],
            "body" : "private PreparedStatement prepareAddStmt(String column) {\n    RegularInsert stmt = null;\n    InsertInto stmtStart = QueryBuilder.insertInto(this.conf.schema.keyspace(), this.conf.schema.table());\n    for (var c : this.conf.schema.partitionKeys()) {\n        stmt = (null != stmt ? stmt : stmtStart).value(c.name(), QueryBuilder.bindMarker(c.name()));\n    }\n    for (var c : this.conf.schema.clusteringKeys()) {\n        stmt = stmt.value(c.name(), QueryBuilder.bindMarker(c.name()));\n    }\n    stmt = stmt.value(column, QueryBuilder.bindMarker(\"message\"));\n    return this.conf.session.prepare(stmt.build());\n}"
          }, {
            "name" : "prepareAddStmt",
            "arguments" : [ "this.conf.assistantColumn" ],
            "body" : "private PreparedStatement prepareAddStmt(String column) {\n    RegularInsert stmt = null;\n    InsertInto stmtStart = QueryBuilder.insertInto(this.conf.schema.keyspace(), this.conf.schema.table());\n    for (var c : this.conf.schema.partitionKeys()) {\n        stmt = (null != stmt ? stmt : stmtStart).value(c.name(), QueryBuilder.bindMarker(c.name()));\n    }\n    for (var c : this.conf.schema.clusteringKeys()) {\n        stmt = stmt.value(c.name(), QueryBuilder.bindMarker(c.name()));\n    }\n    stmt = stmt.value(column, QueryBuilder.bindMarker(\"message\"));\n    return this.conf.session.prepare(stmt.build());\n}"
          }, {
            "name" : "prepareGetStatement",
            "arguments" : [ ],
            "body" : "private PreparedStatement prepareGetStatement() {\n    Select stmt = QueryBuilder.selectFrom(this.conf.schema.keyspace(), this.conf.schema.table()).all();\n    for (var c : this.conf.schema.partitionKeys()) {\n        stmt = stmt.whereColumn(c.name()).isEqualTo(QueryBuilder.bindMarker(c.name()));\n    }\n    for (int i = 0; i + 1 < this.conf.schema.clusteringKeys().size(); ++i) {\n        String columnName = this.conf.schema.clusteringKeys().get(i).name();\n        stmt = stmt.whereColumn(columnName).isEqualTo(QueryBuilder.bindMarker(columnName));\n    }\n    stmt = stmt.limit(QueryBuilder.bindMarker(\"lastN\"));\n    return this.conf.session.prepare(stmt.build());\n}"
          }, {
            "name" : "prepareDeleteStmt",
            "arguments" : [ ],
            "body" : "private PreparedStatement prepareDeleteStmt() {\n    Delete stmt = null;\n    DeleteSelection stmtStart = QueryBuilder.deleteFrom(this.conf.schema.keyspace(), this.conf.schema.table());\n    for (var c : this.conf.schema.partitionKeys()) {\n        stmt = (null != stmt ? stmt : stmtStart).whereColumn(c.name()).isEqualTo(QueryBuilder.bindMarker(c.name()));\n    }\n    for (int i = 0; i + 1 < this.conf.schema.clusteringKeys().size(); ++i) {\n        String columnName = this.conf.schema.clusteringKeys().get(i).name();\n        stmt = stmt.whereColumn(columnName).isEqualTo(QueryBuilder.bindMarker(columnName));\n    }\n    return this.conf.session.prepare(stmt.build());\n}"
          } ],
          "usedEntities" : [ "config" ],
          "annotations" : [ ],
          "comments" : null,
          "methodDefinition" : "public CassandraChatMemory(CassandraChatMemoryConfig config) {\n    this.conf = config;\n    this.conf.ensureSchemaExists();\n    this.addUserStmt = prepareAddStmt(this.conf.userColumn);\n    this.addAssistantStmt = prepareAddStmt(this.conf.assistantColumn);\n    this.getStmt = prepareGetStatement();\n    this.deleteStmt = prepareDeleteStmt();\n}"
        } ],
        "extends" : [ ],
        "implements" : [ "ChatMemory" ],
        "nestedClass" : null,
        "accessSpecifier" : "public , final",
        "records" : [ ]
      } ],
      "records" : [ ],
      "samePackageClasses" : [ {
        "imports" : [ {
          "dereferencedParts" : [ ],
          "name" : "java.net.InetSocketAddress"
        }, {
          "dereferencedParts" : [ ],
          "name" : "java.time.Duration"
        }, {
          "dereferencedParts" : [ ],
          "name" : "java.util.List"
        }, {
          "dereferencedParts" : [ ],
          "name" : "java.util.Map"
        }, {
          "dereferencedParts" : [ ],
          "name" : "java.util.UUID"
        }, {
          "dereferencedParts" : [ ],
          "name" : "java.util.function.Function"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.api.core.CqlSession"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.api.core.CqlSessionBuilder"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.api.core.cql.SimpleStatement"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.api.core.metadata.schema.ClusteringOrder"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.api.core.metadata.schema.TableMetadata"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.api.core.type.DataType"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.api.core.type.DataTypes"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.api.core.type.codec.registry.CodecRegistry"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.api.core.type.reflect.GenericType"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.api.querybuilder.SchemaBuilder"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.api.querybuilder.schema.AlterTableAddColumn"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.api.querybuilder.schema.AlterTableAddColumnEnd"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.api.querybuilder.schema.CreateTable"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.api.querybuilder.schema.CreateTableStart"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.api.querybuilder.schema.CreateTableWithOptions"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.shaded.guava.common.annotations.VisibleForTesting"
        }, {
          "dereferencedParts" : [ ],
          "name" : "com.datastax.oss.driver.shaded.guava.common.base.Preconditions"
        }, {
          "dereferencedParts" : [ ],
          "name" : "org.slf4j.Logger"
        }, {
          "dereferencedParts" : [ ],
          "name" : "org.slf4j.LoggerFactory"
        }, {
          "dereferencedParts" : [ {
            "name" : "SchemaUtil",
            "comments" : "Utility class for working with Cassandra schema.",
            "annotations" : [ ],
            "methods" : [ {
              "name" : "checkSchemaAgreement",
              "arguments" : [ "CqlSession session" ],
              "accessModifier" : "public,static",
              "methodsCalled" : [ {
                "name" : "checkSchemaAgreement",
                "arguments" : [ ],
                "body" : "public static void checkSchemaAgreement(CqlSession session) throws IllegalStateException {\n    if (!session.checkSchemaAgreement()) {\n        logger.warn(\"Waiting for cluster schema agreement, sleeping 10s…\");\n        try {\n            Thread.sleep(Duration.ofSeconds(10).toMillis());\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n            throw new IllegalStateException(ex);\n        }\n        if (!session.checkSchemaAgreement()) {\n            logger.error(\"no cluster schema agreement still, continuing, let's hope this works…\");\n        }\n    }\n}"
              }, {
                "name" : "warn",
                "arguments" : [ "\"Waiting for cluster schema agreement, sleeping 10s…\"" ],
                "body" : ""
              }, {
                "name" : "sleep",
                "arguments" : [ "Duration.ofSeconds(10).toMillis()" ],
                "body" : ""
              }, {
                "name" : "toMillis",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "ofSeconds",
                "arguments" : [ "10" ],
                "body" : ""
              }, {
                "name" : "interrupt",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "currentThread",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "checkSchemaAgreement",
                "arguments" : [ ],
                "body" : "public static void checkSchemaAgreement(CqlSession session) throws IllegalStateException {\n    if (!session.checkSchemaAgreement()) {\n        logger.warn(\"Waiting for cluster schema agreement, sleeping 10s…\");\n        try {\n            Thread.sleep(Duration.ofSeconds(10).toMillis());\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n            throw new IllegalStateException(ex);\n        }\n        if (!session.checkSchemaAgreement()) {\n            logger.error(\"no cluster schema agreement still, continuing, let's hope this works…\");\n        }\n    }\n}"
              }, {
                "name" : "error",
                "arguments" : [ "\"no cluster schema agreement still, continuing, let's hope this works…\"" ],
                "body" : ""
              } ],
              "usedEntities" : [ "session", "logger", "Thread", "Duration", "ex" ],
              "annotations" : [ ],
              "returnType" : "void",
              "comments" : null,
              "methodDefinition" : "public static void checkSchemaAgreement(CqlSession session) throws IllegalStateException {\n    if (!session.checkSchemaAgreement()) {\n        logger.warn(\"Waiting for cluster schema agreement, sleeping 10s…\");\n        try {\n            Thread.sleep(Duration.ofSeconds(10).toMillis());\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n            throw new IllegalStateException(ex);\n        }\n        if (!session.checkSchemaAgreement()) {\n            logger.error(\"no cluster schema agreement still, continuing, let's hope this works…\");\n        }\n    }\n}"
            }, {
              "name" : "ensureKeyspaceExists",
              "arguments" : [ "CqlSession session", "String keyspaceName" ],
              "accessModifier" : "public,static",
              "methodsCalled" : [ {
                "name" : "isEmpty",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "getKeyspace",
                "arguments" : [ "keyspaceName" ],
                "body" : ""
              }, {
                "name" : "getMetadata",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "build",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "withSimpleStrategy",
                "arguments" : [ "1" ],
                "body" : ""
              }, {
                "name" : "ifNotExists",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "createKeyspace",
                "arguments" : [ "keyspaceName" ],
                "body" : ""
              }, {
                "name" : "debug",
                "arguments" : [ "\"Executing {}\"", "keyspaceStmt.getQuery()" ],
                "body" : ""
              }, {
                "name" : "getQuery",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "execute",
                "arguments" : [ "keyspaceStmt" ],
                "body" : ""
              } ],
              "usedEntities" : [ "session", "keyspaceName", "SchemaBuilder", "logger", "keyspaceStmt" ],
              "annotations" : [ ],
              "returnType" : "void",
              "comments" : null,
              "methodDefinition" : "public static void ensureKeyspaceExists(CqlSession session, String keyspaceName) {\n    if (session.getMetadata().getKeyspace(keyspaceName).isEmpty()) {\n        SimpleStatement keyspaceStmt = SchemaBuilder.createKeyspace(keyspaceName).ifNotExists().withSimpleStrategy(1).build();\n        logger.debug(\"Executing {}\", keyspaceStmt.getQuery());\n        session.execute(keyspaceStmt);\n    }\n}"
            } ],
            "fields" : [ {
              "name" : "logger",
              "accessModifier" : "private,static,final",
              "value" : "LoggerFactory.getLogger(SchemaUtil.class)",
              "type" : "Logger",
              "comments" : null
            } ],
            "constructors" : [ {
              "name" : "SchemaUtil",
              "arguments" : [ ],
              "accessModifier" : "private",
              "methodsCalled" : [ ],
              "usedEntities" : [ ],
              "annotations" : [ ],
              "comments" : null,
              "methodDefinition" : "private SchemaUtil() {\n}"
            } ],
            "extends" : [ ],
            "implements" : [ ],
            "nestedClass" : null,
            "accessSpecifier" : "public , final",
            "records" : null,
            "imports" : [ {
              "dereferencedParts" : [ ],
              "name" : "java.time.Duration"
            }, {
              "dereferencedParts" : [ ],
              "name" : "com.datastax.oss.driver.api.core.CqlSession"
            }, {
              "dereferencedParts" : [ ],
              "name" : "com.datastax.oss.driver.api.core.cql.SimpleStatement"
            }, {
              "dereferencedParts" : [ ],
              "name" : "com.datastax.oss.driver.api.querybuilder.SchemaBuilder"
            }, {
              "dereferencedParts" : [ ],
              "name" : "org.slf4j.Logger"
            }, {
              "dereferencedParts" : [ ],
              "name" : "org.slf4j.LoggerFactory"
            } ]
          } ],
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/cassandra/SchemaUtil.java",
          "name" : "org.springframework.ai.cassandra.SchemaUtil"
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemoryConfig.java",
        "classes" : [ {
          "name" : "CassandraChatMemoryConfig",
          "comments" : "Configuration for the Cassandra Chat Memory store.",
          "annotations" : [ ],
          "methods" : [ {
            "name" : "builder",
            "arguments" : [ ],
            "accessModifier" : "public,static",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public static Builder builder() {\n    return new Builder();\n}"
          }, {
            "name" : "getPrimaryKeyColumn",
            "arguments" : [ "int index" ],
            "accessModifier" : "",
            "methodsCalled" : [ {
              "name" : "size",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "partitionKeys",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "get",
              "arguments" : [ "index" ],
              "body" : ""
            }, {
              "name" : "partitionKeys",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "get",
              "arguments" : [ "index - this.schema.partitionKeys().size()" ],
              "body" : ""
            }, {
              "name" : "clusteringKeys",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "size",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "partitionKeys",
              "arguments" : [ ],
              "body" : ""
            } ],
            "usedEntities" : [ "index" ],
            "annotations" : [ ],
            "returnType" : "SchemaColumn",
            "comments" : null,
            "methodDefinition" : "SchemaColumn getPrimaryKeyColumn(int index) {\n    return index < this.schema.partitionKeys().size() ? this.schema.partitionKeys().get(index) : this.schema.clusteringKeys().get(index - this.schema.partitionKeys().size());\n}"
          }, {
            "name" : "dropKeyspace",
            "arguments" : [ ],
            "accessModifier" : "",
            "methodsCalled" : [ {
              "name" : "checkState",
              "arguments" : [ "this.schema.keyspace.startsWith(\"test_\")", "\"Only test keyspaces can be dropped\"" ],
              "body" : ""
            }, {
              "name" : "startsWith",
              "arguments" : [ "\"test_\"" ],
              "body" : ""
            }, {
              "name" : "execute",
              "arguments" : [ "SchemaBuilder.dropKeyspace(this.schema.keyspace).ifExists().build()" ],
              "body" : ""
            }, {
              "name" : "build",
              "arguments" : [ ],
              "body" : "public CassandraChatMemoryConfig build() {\n    int primaryKeyColumns = this.partitionKeys.size() + this.clusteringKeys.size();\n    int primaryKeysToBind = this.primaryKeyTranslator.apply(UUID.randomUUID().toString()).size();\n    Preconditions.checkArgument(primaryKeyColumns == primaryKeysToBind + 1, \"The primaryKeyTranslator must always return one less element than the number of primary keys in total. The last clustering key remains undefined, expecting to be the timestamp for messages within sessionId. The sessionId can map to any primary key column (though it should map to a partition key column).\");\n    Preconditions.checkArgument(this.clusteringKeys.get(this.clusteringKeys.size() - 1).name().equals(DEFAULT_EXCHANGE_ID_NAME), \"last clustering key must be the exchangeIdColumn\");\n    return new CassandraChatMemoryConfig(this);\n}"
            }, {
              "name" : "ifExists",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "dropKeyspace",
              "arguments" : [ "this.schema.keyspace" ],
              "body" : "@VisibleForTesting\nvoid dropKeyspace() {\n    Preconditions.checkState(this.schema.keyspace.startsWith(\"test_\"), \"Only test keyspaces can be dropped\");\n    this.session.execute(SchemaBuilder.dropKeyspace(this.schema.keyspace).ifExists().build());\n}"
            } ],
            "usedEntities" : [ "Preconditions", "SchemaBuilder" ],
            "annotations" : [ "VisibleForTesting" ],
            "returnType" : "void",
            "comments" : null,
            "methodDefinition" : "@VisibleForTesting\nvoid dropKeyspace() {\n    Preconditions.checkState(this.schema.keyspace.startsWith(\"test_\"), \"Only test keyspaces can be dropped\");\n    this.session.execute(SchemaBuilder.dropKeyspace(this.schema.keyspace).ifExists().build());\n}"
          }, {
            "name" : "ensureSchemaExists",
            "arguments" : [ ],
            "accessModifier" : "",
            "methodsCalled" : [ {
              "name" : "ensureKeyspaceExists",
              "arguments" : [ "this.session", "this.schema.keyspace" ],
              "body" : ""
            }, {
              "name" : "ensureTableExists",
              "arguments" : [ ],
              "body" : "private void ensureTableExists() {\n    if (this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).isEmpty()) {\n        CreateTable createTable = null;\n        CreateTableStart createTableStart = SchemaBuilder.createTable(this.schema.keyspace, this.schema.table).ifNotExists();\n        for (SchemaColumn partitionKey : this.schema.partitionKeys) {\n            createTable = (null != createTable ? createTable : createTableStart).withPartitionKey(partitionKey.name, partitionKey.type);\n        }\n        for (SchemaColumn clusteringKey : this.schema.clusteringKeys) {\n            createTable = createTable.withClusteringColumn(clusteringKey.name, clusteringKey.type);\n        }\n        String lastClusteringColumn = this.schema.clusteringKeys.get(this.schema.clusteringKeys.size() - 1).name();\n        CreateTableWithOptions createTableWithOptions = createTable.withColumn(this.userColumn, DataTypes.TEXT).withClusteringOrder(lastClusteringColumn, ClusteringOrder.DESC).\n        withOption(\"compaction\", Map.of(\"class\", \"UnifiedCompactionStrategy\"));\n        if (null != this.timeToLiveSeconds) {\n            createTableWithOptions = createTableWithOptions.withDefaultTimeToLiveSeconds(this.timeToLiveSeconds);\n        }\n        this.session.execute(createTableWithOptions.build());\n    }\n}"
            }, {
              "name" : "ensureTableColumnsExist",
              "arguments" : [ ],
              "body" : "private void ensureTableColumnsExist() {\n    TableMetadata tableMetadata = this.session.getMetadata().getKeyspace(this.schema.keyspace()).get().getTable(this.schema.table()).get();\n    boolean addAssistantColumn = tableMetadata.getColumn(this.assistantColumn).isEmpty();\n    boolean addUserColumn = tableMetadata.getColumn(this.userColumn).isEmpty();\n    if (addAssistantColumn || addUserColumn) {\n        AlterTableAddColumn alterTable = SchemaBuilder.alterTable(this.schema.keyspace(), this.schema.table());\n        if (addAssistantColumn) {\n            alterTable = alterTable.addColumn(this.assistantColumn, DataTypes.TEXT);\n        }\n        if (addUserColumn) {\n            alterTable = alterTable.addColumn(this.userColumn, DataTypes.TEXT);\n        }\n        SimpleStatement stmt = ((AlterTableAddColumnEnd) alterTable).build();\n        logger.debug(\"Executing {}\", stmt.getQuery());\n        this.session.execute(stmt);\n    }\n}"
            }, {
              "name" : "checkSchemaAgreement",
              "arguments" : [ "this.session" ],
              "body" : ""
            }, {
              "name" : "checkSchemaValid",
              "arguments" : [ ],
              "body" : "void checkSchemaValid() {\n    Preconditions.checkState(this.session.getMetadata().getKeyspace(this.schema.keyspace).isPresent(), \"keyspace %s does not exist\", this.schema.keyspace);\n    Preconditions.checkState(this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).isPresent(), \"table %s does not exist\");\n    TableMetadata tableMetadata = this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).get();\n    Preconditions.checkState(tableMetadata.getColumn(this.assistantColumn).isPresent(), \"column %s does not exist\", this.assistantColumn);\n    Preconditions.checkState(tableMetadata.getColumn(this.userColumn).isPresent(), \"column %s does not exist\", this.userColumn);\n}"
            } ],
            "usedEntities" : [ "SchemaUtil" ],
            "annotations" : [ ],
            "returnType" : "void",
            "comments" : null,
            "methodDefinition" : "void ensureSchemaExists() {\n    if (!this.disallowSchemaChanges) {\n        SchemaUtil.ensureKeyspaceExists(this.session, this.schema.keyspace);\n        ensureTableExists();\n        ensureTableColumnsExist();\n        SchemaUtil.checkSchemaAgreement(this.session);\n    } else {\n        checkSchemaValid();\n    }\n}"
          }, {
            "name" : "checkSchemaValid",
            "arguments" : [ ],
            "accessModifier" : "",
            "methodsCalled" : [ {
              "name" : "checkState",
              "arguments" : [ "this.session.getMetadata().getKeyspace(this.schema.keyspace).isPresent()", "\"keyspace %s does not exist\"", "this.schema.keyspace" ],
              "body" : ""
            }, {
              "name" : "isPresent",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getKeyspace",
              "arguments" : [ "this.schema.keyspace" ],
              "body" : ""
            }, {
              "name" : "getMetadata",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "checkState",
              "arguments" : [ "this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).isPresent()", "\"table %s does not exist\"" ],
              "body" : ""
            }, {
              "name" : "isPresent",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getTable",
              "arguments" : [ "this.schema.table" ],
              "body" : ""
            }, {
              "name" : "get",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getKeyspace",
              "arguments" : [ "this.schema.keyspace" ],
              "body" : ""
            }, {
              "name" : "getMetadata",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "get",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getTable",
              "arguments" : [ "this.schema.table" ],
              "body" : ""
            }, {
              "name" : "get",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getKeyspace",
              "arguments" : [ "this.schema.keyspace" ],
              "body" : ""
            }, {
              "name" : "getMetadata",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "checkState",
              "arguments" : [ "tableMetadata.getColumn(this.assistantColumn).isPresent()", "\"column %s does not exist\"", "this.assistantColumn" ],
              "body" : ""
            }, {
              "name" : "isPresent",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getColumn",
              "arguments" : [ "this.assistantColumn" ],
              "body" : ""
            }, {
              "name" : "checkState",
              "arguments" : [ "tableMetadata.getColumn(this.userColumn).isPresent()", "\"column %s does not exist\"", "this.userColumn" ],
              "body" : ""
            }, {
              "name" : "isPresent",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getColumn",
              "arguments" : [ "this.userColumn" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Preconditions", "tableMetadata" ],
            "annotations" : [ ],
            "returnType" : "void",
            "comments" : null,
            "methodDefinition" : "void checkSchemaValid() {\n    Preconditions.checkState(this.session.getMetadata().getKeyspace(this.schema.keyspace).isPresent(), \"keyspace %s does not exist\", this.schema.keyspace);\n    Preconditions.checkState(this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).isPresent(), \"table %s does not exist\");\n    TableMetadata tableMetadata = this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).get();\n    Preconditions.checkState(tableMetadata.getColumn(this.assistantColumn).isPresent(), \"column %s does not exist\", this.assistantColumn);\n    Preconditions.checkState(tableMetadata.getColumn(this.userColumn).isPresent(), \"column %s does not exist\", this.userColumn);\n}"
          }, {
            "name" : "ensureTableExists",
            "arguments" : [ ],
            "accessModifier" : "private",
            "methodsCalled" : [ {
              "name" : "isEmpty",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getTable",
              "arguments" : [ "this.schema.table" ],
              "body" : ""
            }, {
              "name" : "get",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getKeyspace",
              "arguments" : [ "this.schema.keyspace" ],
              "body" : ""
            }, {
              "name" : "getMetadata",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "ifNotExists",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "createTable",
              "arguments" : [ "this.schema.keyspace", "this.schema.table" ],
              "body" : ""
            }, {
              "name" : "withPartitionKey",
              "arguments" : [ "partitionKey.name", "partitionKey.type" ],
              "body" : ""
            }, {
              "name" : "withClusteringColumn",
              "arguments" : [ "clusteringKey.name", "clusteringKey.type" ],
              "body" : ""
            }, {
              "name" : "name",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "get",
              "arguments" : [ "this.schema.clusteringKeys.size() - 1" ],
              "body" : ""
            }, {
              "name" : "size",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "withOption",
              "arguments" : [ "\"compaction\"", "Map.of(\"class\", \"UnifiedCompactionStrategy\")" ],
              "body" : ""
            }, {
              "name" : "withClusteringOrder",
              "arguments" : [ "lastClusteringColumn", "ClusteringOrder.DESC" ],
              "body" : ""
            }, {
              "name" : "withColumn",
              "arguments" : [ "this.userColumn", "DataTypes.TEXT" ],
              "body" : ""
            }, {
              "name" : "of",
              "arguments" : [ "\"class\"", "\"UnifiedCompactionStrategy\"" ],
              "body" : ""
            }, {
              "name" : "withDefaultTimeToLiveSeconds",
              "arguments" : [ "this.timeToLiveSeconds" ],
              "body" : ""
            }, {
              "name" : "execute",
              "arguments" : [ "createTableWithOptions.build()" ],
              "body" : ""
            }, {
              "name" : "build",
              "arguments" : [ ],
              "body" : "public CassandraChatMemoryConfig build() {\n    int primaryKeyColumns = this.partitionKeys.size() + this.clusteringKeys.size();\n    int primaryKeysToBind = this.primaryKeyTranslator.apply(UUID.randomUUID().toString()).size();\n    Preconditions.checkArgument(primaryKeyColumns == primaryKeysToBind + 1, \"The primaryKeyTranslator must always return one less element than the number of primary keys in total. The last clustering key remains undefined, expecting to be the timestamp for messages within sessionId. The sessionId can map to any primary key column (though it should map to a partition key column).\");\n    Preconditions.checkArgument(this.clusteringKeys.get(this.clusteringKeys.size() - 1).name().equals(DEFAULT_EXCHANGE_ID_NAME), \"last clustering key must be the exchangeIdColumn\");\n    return new CassandraChatMemoryConfig(this);\n}"
            } ],
            "usedEntities" : [ "SchemaBuilder", "createTable", "createTableStart", "partitionKey", "clusteringKey", "DataTypes", "lastClusteringColumn", "ClusteringOrder", "Map", "createTableWithOptions" ],
            "annotations" : [ ],
            "returnType" : "void",
            "comments" : null,
            "methodDefinition" : "private void ensureTableExists() {\n    if (this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).isEmpty()) {\n        CreateTable createTable = null;\n        CreateTableStart createTableStart = SchemaBuilder.createTable(this.schema.keyspace, this.schema.table).ifNotExists();\n        for (SchemaColumn partitionKey : this.schema.partitionKeys) {\n            createTable = (null != createTable ? createTable : createTableStart).withPartitionKey(partitionKey.name, partitionKey.type);\n        }\n        for (SchemaColumn clusteringKey : this.schema.clusteringKeys) {\n            createTable = createTable.withClusteringColumn(clusteringKey.name, clusteringKey.type);\n        }\n        String lastClusteringColumn = this.schema.clusteringKeys.get(this.schema.clusteringKeys.size() - 1).name();\n        CreateTableWithOptions createTableWithOptions = createTable.withColumn(this.userColumn, DataTypes.TEXT).withClusteringOrder(lastClusteringColumn, ClusteringOrder.DESC).\n        withOption(\"compaction\", Map.of(\"class\", \"UnifiedCompactionStrategy\"));\n        if (null != this.timeToLiveSeconds) {\n            createTableWithOptions = createTableWithOptions.withDefaultTimeToLiveSeconds(this.timeToLiveSeconds);\n        }\n        this.session.execute(createTableWithOptions.build());\n    }\n}"
          }, {
            "name" : "ensureTableColumnsExist",
            "arguments" : [ ],
            "accessModifier" : "private",
            "methodsCalled" : [ {
              "name" : "get",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getTable",
              "arguments" : [ "this.schema.table()" ],
              "body" : ""
            }, {
              "name" : "get",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getKeyspace",
              "arguments" : [ "this.schema.keyspace()" ],
              "body" : ""
            }, {
              "name" : "getMetadata",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "keyspace",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "table",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "isEmpty",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getColumn",
              "arguments" : [ "this.assistantColumn" ],
              "body" : ""
            }, {
              "name" : "isEmpty",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getColumn",
              "arguments" : [ "this.userColumn" ],
              "body" : ""
            }, {
              "name" : "alterTable",
              "arguments" : [ "this.schema.keyspace()", "this.schema.table()" ],
              "body" : ""
            }, {
              "name" : "keyspace",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "table",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "addColumn",
              "arguments" : [ "this.assistantColumn", "DataTypes.TEXT" ],
              "body" : ""
            }, {
              "name" : "addColumn",
              "arguments" : [ "this.userColumn", "DataTypes.TEXT" ],
              "body" : ""
            }, {
              "name" : "build",
              "arguments" : [ ],
              "body" : "public CassandraChatMemoryConfig build() {\n    int primaryKeyColumns = this.partitionKeys.size() + this.clusteringKeys.size();\n    int primaryKeysToBind = this.primaryKeyTranslator.apply(UUID.randomUUID().toString()).size();\n    Preconditions.checkArgument(primaryKeyColumns == primaryKeysToBind + 1, \"The primaryKeyTranslator must always return one less element than the number of primary keys in total. The last clustering key remains undefined, expecting to be the timestamp for messages within sessionId. The sessionId can map to any primary key column (though it should map to a partition key column).\");\n    Preconditions.checkArgument(this.clusteringKeys.get(this.clusteringKeys.size() - 1).name().equals(DEFAULT_EXCHANGE_ID_NAME), \"last clustering key must be the exchangeIdColumn\");\n    return new CassandraChatMemoryConfig(this);\n}"
            }, {
              "name" : "debug",
              "arguments" : [ "\"Executing {}\"", "stmt.getQuery()" ],
              "body" : ""
            }, {
              "name" : "getQuery",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "execute",
              "arguments" : [ "stmt" ],
              "body" : ""
            } ],
            "usedEntities" : [ "tableMetadata", "addAssistantColumn", "addUserColumn", "SchemaBuilder", "alterTable", "DataTypes", "logger", "stmt" ],
            "annotations" : [ ],
            "returnType" : "void",
            "comments" : null,
            "methodDefinition" : "private void ensureTableColumnsExist() {\n    TableMetadata tableMetadata = this.session.getMetadata().getKeyspace(this.schema.keyspace()).get().getTable(this.schema.table()).get();\n    boolean addAssistantColumn = tableMetadata.getColumn(this.assistantColumn).isEmpty();\n    boolean addUserColumn = tableMetadata.getColumn(this.userColumn).isEmpty();\n    if (addAssistantColumn || addUserColumn) {\n        AlterTableAddColumn alterTable = SchemaBuilder.alterTable(this.schema.keyspace(), this.schema.table());\n        if (addAssistantColumn) {\n            alterTable = alterTable.addColumn(this.assistantColumn, DataTypes.TEXT);\n        }\n        if (addUserColumn) {\n            alterTable = alterTable.addColumn(this.userColumn, DataTypes.TEXT);\n        }\n        SimpleStatement stmt = ((AlterTableAddColumnEnd) alterTable).build();\n        logger.debug(\"Executing {}\", stmt.getQuery());\n        this.session.execute(stmt);\n    }\n}"
          } ],
          "fields" : [ {
            "name" : "DEFAULT_KEYSPACE_NAME",
            "accessModifier" : "public,static,final",
            "value" : "\"springframework\"",
            "type" : "String",
            "comments" : null
          }, {
            "name" : "DEFAULT_TABLE_NAME",
            "accessModifier" : "public,static,final",
            "value" : "\"ai_chat_memory\"",
            "type" : "String",
            "comments" : null
          }, {
            "name" : "DEFAULT_SESSION_ID_NAME",
            "accessModifier" : "public,static,final",
            "value" : "\"session_id\"",
            "type" : "String",
            "comments" : null
          }, {
            "name" : "DEFAULT_EXCHANGE_ID_NAME",
            "accessModifier" : "public,static,final",
            "value" : "\"message_timestamp\"",
            "type" : "String",
            "comments" : null
          }, {
            "name" : "DEFAULT_ASSISTANT_COLUMN_NAME",
            "accessModifier" : "public,static,final",
            "value" : "\"assistant\"",
            "type" : "String",
            "comments" : null
          }, {
            "name" : "DEFAULT_USER_COLUMN_NAME",
            "accessModifier" : "public,static,final",
            "value" : "\"user\"",
            "type" : "String",
            "comments" : null
          }, {
            "name" : "logger",
            "accessModifier" : "private,static,final",
            "value" : "LoggerFactory.getLogger(CassandraChatMemoryConfig.class)",
            "type" : "Logger",
            "comments" : null
          }, {
            "name" : "session",
            "accessModifier" : "final",
            "value" : null,
            "type" : "CqlSession",
            "comments" : null
          }, {
            "name" : "schema",
            "accessModifier" : "final",
            "value" : null,
            "type" : "Schema",
            "comments" : null
          }, {
            "name" : "assistantColumn",
            "accessModifier" : "final",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "userColumn",
            "accessModifier" : "final",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "primaryKeyTranslator",
            "accessModifier" : "final",
            "value" : null,
            "type" : "SessionIdToPrimaryKeysTranslator",
            "comments" : null
          }, {
            "name" : "timeToLiveSeconds",
            "accessModifier" : "private,final",
            "value" : null,
            "type" : "Integer",
            "comments" : null
          }, {
            "name" : "disallowSchemaChanges",
            "accessModifier" : "private,final",
            "value" : null,
            "type" : "boolean",
            "comments" : null
          } ],
          "constructors" : [ {
            "name" : "CassandraChatMemoryConfig",
            "arguments" : [ "Builder builder" ],
            "accessModifier" : "private",
            "methodsCalled" : [ ],
            "usedEntities" : [ "builder" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "private CassandraChatMemoryConfig(Builder builder) {\n    this.session = builder.session;\n    this.schema = new Schema(builder.keyspace, builder.table, builder.partitionKeys, builder.clusteringKeys);\n    this.assistantColumn = builder.assistantColumn;\n    this.userColumn = builder.userColumn;\n    this.timeToLiveSeconds = builder.timeToLiveSeconds;\n    this.disallowSchemaChanges = builder.disallowSchemaChanges;\n    this.primaryKeyTranslator = builder.primaryKeyTranslator;\n}"
          } ],
          "extends" : [ ],
          "implements" : [ ],
          "nestedClass" : [ {
            "name" : "SessionIdToPrimaryKeysTranslator",
            "comments" : "Given a string sessionId, return the value for each primary key column.",
            "annotations" : [ ],
            "methods" : [ ],
            "fields" : [ ],
            "constructors" : [ ],
            "extends" : null,
            "implements" : null,
            "nestedClass" : null,
            "accessSpecifier" : "public",
            "records" : null
          }, {
            "name" : "Builder",
            "comments" : null,
            "annotations" : [ ],
            "methods" : [ {
              "name" : "withCqlSession",
              "arguments" : [ "CqlSession session" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "checkState",
                "arguments" : [ "null == this.sessionBuilder", "\"Cannot call withContactPoint(..) or withLocalDatacenter(..) and this method\"" ],
                "body" : ""
              } ],
              "usedEntities" : [ "Preconditions", "session" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder withCqlSession(CqlSession session) {\n    Preconditions.checkState(null == this.sessionBuilder, \"Cannot call withContactPoint(..) or withLocalDatacenter(..) and this method\");\n    this.session = session;\n    return this;\n}"
            }, {
              "name" : "addContactPoint",
              "arguments" : [ "InetSocketAddress contactPoint" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "checkState",
                "arguments" : [ "null == this.session", "\"Cannot call withCqlSession(..) and this method\"" ],
                "body" : ""
              }, {
                "name" : "addContactPoint",
                "arguments" : [ "contactPoint" ],
                "body" : "public Builder addContactPoint(InetSocketAddress contactPoint) {\n    Preconditions.checkState(null == this.session, \"Cannot call withCqlSession(..) and this method\");\n    if (null == this.sessionBuilder) {\n        this.sessionBuilder = new CqlSessionBuilder();\n    }\n    this.sessionBuilder.addContactPoint(contactPoint);\n    return this;\n}"
              } ],
              "usedEntities" : [ "Preconditions", "contactPoint" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder addContactPoint(InetSocketAddress contactPoint) {\n    Preconditions.checkState(null == this.session, \"Cannot call withCqlSession(..) and this method\");\n    if (null == this.sessionBuilder) {\n        this.sessionBuilder = new CqlSessionBuilder();\n    }\n    this.sessionBuilder.addContactPoint(contactPoint);\n    return this;\n}"
            }, {
              "name" : "withLocalDatacenter",
              "arguments" : [ "String localDC" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "checkState",
                "arguments" : [ "null == this.session", "\"Cannot call withCqlSession(..) and this method\"" ],
                "body" : ""
              }, {
                "name" : "withLocalDatacenter",
                "arguments" : [ "localDC" ],
                "body" : "public Builder withLocalDatacenter(String localDC) {\n    Preconditions.checkState(null == this.session, \"Cannot call withCqlSession(..) and this method\");\n    if (null == this.sessionBuilder) {\n        this.sessionBuilder = new CqlSessionBuilder();\n    }\n    this.sessionBuilder.withLocalDatacenter(localDC);\n    return this;\n}"
              } ],
              "usedEntities" : [ "Preconditions", "localDC" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder withLocalDatacenter(String localDC) {\n    Preconditions.checkState(null == this.session, \"Cannot call withCqlSession(..) and this method\");\n    if (null == this.sessionBuilder) {\n        this.sessionBuilder = new CqlSessionBuilder();\n    }\n    this.sessionBuilder.withLocalDatacenter(localDC);\n    return this;\n}"
            }, {
              "name" : "withKeyspaceName",
              "arguments" : [ "String keyspace" ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ "keyspace" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder withKeyspaceName(String keyspace) {\n    this.keyspace = keyspace;\n    return this;\n}"
            }, {
              "name" : "withTableName",
              "arguments" : [ "String table" ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ "table" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder withTableName(String table) {\n    this.table = table;\n    return this;\n}"
            }, {
              "name" : "withPartitionKeys",
              "arguments" : [ "List<SchemaColumn> partitionKeys" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "checkArgument",
                "arguments" : [ "!partitionKeys.isEmpty()" ],
                "body" : ""
              }, {
                "name" : "isEmpty",
                "arguments" : [ ],
                "body" : ""
              } ],
              "usedEntities" : [ "Preconditions", "partitionKeys" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder withPartitionKeys(List<SchemaColumn> partitionKeys) {\n    Preconditions.checkArgument(!partitionKeys.isEmpty());\n    this.partitionKeys = partitionKeys;\n    return this;\n}"
            }, {
              "name" : "withClusteringKeys",
              "arguments" : [ "List<SchemaColumn> clusteringKeys" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "checkArgument",
                "arguments" : [ "!clusteringKeys.isEmpty()" ],
                "body" : ""
              }, {
                "name" : "isEmpty",
                "arguments" : [ ],
                "body" : ""
              } ],
              "usedEntities" : [ "Preconditions", "clusteringKeys" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder withClusteringKeys(List<SchemaColumn> clusteringKeys) {\n    Preconditions.checkArgument(!clusteringKeys.isEmpty());\n    this.clusteringKeys = clusteringKeys;\n    return this;\n}"
            }, {
              "name" : "withAssistantColumnName",
              "arguments" : [ "String name" ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ "name" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder withAssistantColumnName(String name) {\n    this.assistantColumn = name;\n    return this;\n}"
            }, {
              "name" : "withUserColumnName",
              "arguments" : [ "String name" ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ "name" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder withUserColumnName(String name) {\n    this.userColumn = name;\n    return this;\n}"
            }, {
              "name" : "withTimeToLive",
              "arguments" : [ "Duration timeToLive" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "checkArgument",
                "arguments" : [ "0 < timeToLive.getSeconds()" ],
                "body" : ""
              }, {
                "name" : "getSeconds",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "toSeconds",
                "arguments" : [ ],
                "body" : ""
              } ],
              "usedEntities" : [ "Preconditions", "timeToLive" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : "How long are messages kept for",
              "methodDefinition" : "public Builder withTimeToLive(Duration timeToLive) {\n    Preconditions.checkArgument(0 < timeToLive.getSeconds());\n    this.timeToLiveSeconds = (int) timeToLive.toSeconds();\n    return this;\n}"
            }, {
              "name" : "disallowSchemaChanges",
              "arguments" : [ ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder disallowSchemaChanges() {\n    this.disallowSchemaChanges = true;\n    return this;\n}"
            }, {
              "name" : "withChatExchangeToPrimaryKeyTranslator",
              "arguments" : [ "SessionIdToPrimaryKeysTranslator primaryKeyTranslator" ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ "primaryKeyTranslator" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder withChatExchangeToPrimaryKeyTranslator(SessionIdToPrimaryKeysTranslator primaryKeyTranslator) {\n    this.primaryKeyTranslator = primaryKeyTranslator;\n    return this;\n}"
            }, {
              "name" : "build",
              "arguments" : [ ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "size",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "size",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "size",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "apply",
                "arguments" : [ "UUID.randomUUID().toString()" ],
                "body" : ""
              }, {
                "name" : "toString",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "randomUUID",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "checkArgument",
                "arguments" : [ "primaryKeyColumns == primaryKeysToBind + 1", "\"The primaryKeyTranslator must always return one less element than the number of primary keys in total. The last clustering key remains undefined, expecting to be the timestamp for messages within sessionId. The sessionId can map to any primary key column (though it should map to a partition key column).\"" ],
                "body" : ""
              }, {
                "name" : "checkArgument",
                "arguments" : [ "this.clusteringKeys.get(this.clusteringKeys.size() - 1).name().equals(DEFAULT_EXCHANGE_ID_NAME)", "\"last clustering key must be the exchangeIdColumn\"" ],
                "body" : ""
              }, {
                "name" : "equals",
                "arguments" : [ "DEFAULT_EXCHANGE_ID_NAME" ],
                "body" : ""
              }, {
                "name" : "name",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "get",
                "arguments" : [ "this.clusteringKeys.size() - 1" ],
                "body" : ""
              }, {
                "name" : "size",
                "arguments" : [ ],
                "body" : ""
              } ],
              "usedEntities" : [ "UUID", "Preconditions", "primaryKeyColumns", "primaryKeysToBind", "DEFAULT_EXCHANGE_ID_NAME" ],
              "annotations" : [ ],
              "returnType" : "CassandraChatMemoryConfig",
              "comments" : null,
              "methodDefinition" : "public CassandraChatMemoryConfig build() {\n    int primaryKeyColumns = this.partitionKeys.size() + this.clusteringKeys.size();\n    int primaryKeysToBind = this.primaryKeyTranslator.apply(UUID.randomUUID().toString()).size();\n    Preconditions.checkArgument(primaryKeyColumns == primaryKeysToBind + 1, \"The primaryKeyTranslator must always return one less element than the number of primary keys in total. The last clustering key remains undefined, expecting to be the timestamp for messages within sessionId. The sessionId can map to any primary key column (though it should map to a partition key column).\");\n    Preconditions.checkArgument(this.clusteringKeys.get(this.clusteringKeys.size() - 1).name().equals(DEFAULT_EXCHANGE_ID_NAME), \"last clustering key must be the exchangeIdColumn\");\n    return new CassandraChatMemoryConfig(this);\n}"
            } ],
            "fields" : [ {
              "name" : "session",
              "accessModifier" : "private",
              "value" : "null",
              "type" : "CqlSession",
              "comments" : null
            }, {
              "name" : "sessionBuilder",
              "accessModifier" : "private",
              "value" : "null",
              "type" : "CqlSessionBuilder",
              "comments" : null
            }, {
              "name" : "keyspace",
              "accessModifier" : "private",
              "value" : "DEFAULT_KEYSPACE_NAME",
              "type" : "String",
              "comments" : null
            }, {
              "name" : "table",
              "accessModifier" : "private",
              "value" : "DEFAULT_TABLE_NAME",
              "type" : "String",
              "comments" : null
            }, {
              "name" : "partitionKeys",
              "accessModifier" : "private",
              "value" : "List.of(new SchemaColumn(DEFAULT_SESSION_ID_NAME, DataTypes.TEXT))",
              "type" : "List<SchemaColumn>",
              "comments" : null
            }, {
              "name" : "clusteringKeys",
              "accessModifier" : "private",
              "value" : "List.of(new SchemaColumn(DEFAULT_EXCHANGE_ID_NAME, DataTypes.TIMESTAMP))",
              "type" : "List<SchemaColumn>",
              "comments" : null
            }, {
              "name" : "assistantColumn",
              "accessModifier" : "private",
              "value" : "DEFAULT_ASSISTANT_COLUMN_NAME",
              "type" : "String",
              "comments" : null
            }, {
              "name" : "userColumn",
              "accessModifier" : "private",
              "value" : "DEFAULT_USER_COLUMN_NAME",
              "type" : "String",
              "comments" : null
            }, {
              "name" : "timeToLiveSeconds",
              "accessModifier" : "private",
              "value" : "null",
              "type" : "Integer",
              "comments" : null
            }, {
              "name" : "disallowSchemaChanges",
              "accessModifier" : "private",
              "value" : "false",
              "type" : "boolean",
              "comments" : null
            }, {
              "name" : "primaryKeyTranslator",
              "accessModifier" : "private",
              "value" : "List::of",
              "type" : "SessionIdToPrimaryKeysTranslator",
              "comments" : null
            } ],
            "constructors" : [ {
              "name" : "Builder",
              "arguments" : [ ],
              "accessModifier" : "private",
              "methodsCalled" : [ ],
              "usedEntities" : [ ],
              "annotations" : [ ],
              "comments" : null,
              "methodDefinition" : "private Builder() {\n}"
            } ],
            "extends" : null,
            "implements" : null,
            "nestedClass" : null,
            "accessSpecifier" : "public , static , final",
            "records" : null
          } ],
          "accessSpecifier" : "public , final",
          "records" : [ {
            "name" : "Schema",
            "comments" : null,
            "annotations" : [ ],
            "methods" : [ ],
            "fields" : [ {
              "name" : "keyspace",
              "accessModifier" : "public",
              "value" : null,
              "type" : "String",
              "comments" : null
            }, {
              "name" : "table",
              "accessModifier" : "public",
              "value" : null,
              "type" : "String",
              "comments" : null
            }, {
              "name" : "partitionKeys",
              "accessModifier" : "public",
              "value" : null,
              "type" : "List<SchemaColumn>",
              "comments" : null
            }, {
              "name" : "clusteringKeys",
              "accessModifier" : "public",
              "value" : null,
              "type" : "List<SchemaColumn>",
              "comments" : null
            } ],
            "constructors" : [ ],
            "extends" : null,
            "implements" : null,
            "nestedClass" : null,
            "accessSpecifier" : "",
            "records" : null
          }, {
            "name" : "SchemaColumn",
            "comments" : null,
            "annotations" : [ ],
            "methods" : [ {
              "name" : "javaType",
              "arguments" : [ ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "getJavaType",
                "arguments" : [ ],
                "body" : ""
              }, {
                "name" : "codecFor",
                "arguments" : [ "this.type" ],
                "body" : ""
              } ],
              "usedEntities" : [ "CodecRegistry" ],
              "annotations" : [ ],
              "returnType" : "GenericType<Object>",
              "comments" : null,
              "methodDefinition" : "public GenericType<Object> javaType() {\n    return CodecRegistry.DEFAULT.codecFor(this.type).getJavaType();\n}"
            } ],
            "fields" : [ {
              "name" : "name",
              "accessModifier" : "public",
              "value" : null,
              "type" : "String",
              "comments" : null
            }, {
              "name" : "type",
              "accessModifier" : "public",
              "value" : null,
              "type" : "DataType",
              "comments" : null
            } ],
            "constructors" : [ ],
            "extends" : null,
            "implements" : null,
            "nestedClass" : null,
            "accessSpecifier" : "public",
            "records" : null
          } ]
        } ]
      } ]
    },
    "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemoryConfig.java" : {
      "imports" : [ {
        "dereferencedParts" : [ ],
        "name" : "java.net.InetSocketAddress"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.time.Duration"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.List"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.Map"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.UUID"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.function.Function"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.CqlSession"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.CqlSessionBuilder"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.cql.SimpleStatement"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.metadata.schema.ClusteringOrder"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.metadata.schema.TableMetadata"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.type.DataType"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.type.DataTypes"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.type.codec.registry.CodecRegistry"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.type.reflect.GenericType"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.SchemaBuilder"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.schema.AlterTableAddColumn"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.schema.AlterTableAddColumnEnd"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.schema.CreateTable"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.schema.CreateTableStart"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.schema.CreateTableWithOptions"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.shaded.guava.common.annotations.VisibleForTesting"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.shaded.guava.common.base.Preconditions"
      }, {
        "dereferencedParts" : [ ],
        "name" : "org.slf4j.Logger"
      }, {
        "dereferencedParts" : [ ],
        "name" : "org.slf4j.LoggerFactory"
      }, {
        "dereferencedParts" : [ {
          "name" : "SchemaUtil",
          "comments" : "Utility class for working with Cassandra schema.",
          "annotations" : [ ],
          "methods" : [ {
            "name" : "checkSchemaAgreement",
            "arguments" : [ "CqlSession session" ],
            "accessModifier" : "public,static",
            "methodsCalled" : [ {
              "name" : "checkSchemaAgreement",
              "arguments" : [ ],
              "body" : "public static void checkSchemaAgreement(CqlSession session) throws IllegalStateException {\n    if (!session.checkSchemaAgreement()) {\n        logger.warn(\"Waiting for cluster schema agreement, sleeping 10s…\");\n        try {\n            Thread.sleep(Duration.ofSeconds(10).toMillis());\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n            throw new IllegalStateException(ex);\n        }\n        if (!session.checkSchemaAgreement()) {\n            logger.error(\"no cluster schema agreement still, continuing, let's hope this works…\");\n        }\n    }\n}"
            }, {
              "name" : "warn",
              "arguments" : [ "\"Waiting for cluster schema agreement, sleeping 10s…\"" ],
              "body" : ""
            }, {
              "name" : "sleep",
              "arguments" : [ "Duration.ofSeconds(10).toMillis()" ],
              "body" : ""
            }, {
              "name" : "toMillis",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "ofSeconds",
              "arguments" : [ "10" ],
              "body" : ""
            }, {
              "name" : "interrupt",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "currentThread",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "checkSchemaAgreement",
              "arguments" : [ ],
              "body" : "public static void checkSchemaAgreement(CqlSession session) throws IllegalStateException {\n    if (!session.checkSchemaAgreement()) {\n        logger.warn(\"Waiting for cluster schema agreement, sleeping 10s…\");\n        try {\n            Thread.sleep(Duration.ofSeconds(10).toMillis());\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n            throw new IllegalStateException(ex);\n        }\n        if (!session.checkSchemaAgreement()) {\n            logger.error(\"no cluster schema agreement still, continuing, let's hope this works…\");\n        }\n    }\n}"
            }, {
              "name" : "error",
              "arguments" : [ "\"no cluster schema agreement still, continuing, let's hope this works…\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "session", "logger", "Thread", "Duration", "ex" ],
            "annotations" : [ ],
            "returnType" : "void",
            "comments" : null,
            "methodDefinition" : "public static void checkSchemaAgreement(CqlSession session) throws IllegalStateException {\n    if (!session.checkSchemaAgreement()) {\n        logger.warn(\"Waiting for cluster schema agreement, sleeping 10s…\");\n        try {\n            Thread.sleep(Duration.ofSeconds(10).toMillis());\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n            throw new IllegalStateException(ex);\n        }\n        if (!session.checkSchemaAgreement()) {\n            logger.error(\"no cluster schema agreement still, continuing, let's hope this works…\");\n        }\n    }\n}"
          }, {
            "name" : "ensureKeyspaceExists",
            "arguments" : [ "CqlSession session", "String keyspaceName" ],
            "accessModifier" : "public,static",
            "methodsCalled" : [ {
              "name" : "isEmpty",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getKeyspace",
              "arguments" : [ "keyspaceName" ],
              "body" : ""
            }, {
              "name" : "getMetadata",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "build",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "withSimpleStrategy",
              "arguments" : [ "1" ],
              "body" : ""
            }, {
              "name" : "ifNotExists",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "createKeyspace",
              "arguments" : [ "keyspaceName" ],
              "body" : ""
            }, {
              "name" : "debug",
              "arguments" : [ "\"Executing {}\"", "keyspaceStmt.getQuery()" ],
              "body" : ""
            }, {
              "name" : "getQuery",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "execute",
              "arguments" : [ "keyspaceStmt" ],
              "body" : ""
            } ],
            "usedEntities" : [ "session", "keyspaceName", "SchemaBuilder", "logger", "keyspaceStmt" ],
            "annotations" : [ ],
            "returnType" : "void",
            "comments" : null,
            "methodDefinition" : "public static void ensureKeyspaceExists(CqlSession session, String keyspaceName) {\n    if (session.getMetadata().getKeyspace(keyspaceName).isEmpty()) {\n        SimpleStatement keyspaceStmt = SchemaBuilder.createKeyspace(keyspaceName).ifNotExists().withSimpleStrategy(1).build();\n        logger.debug(\"Executing {}\", keyspaceStmt.getQuery());\n        session.execute(keyspaceStmt);\n    }\n}"
          } ],
          "fields" : [ {
            "name" : "logger",
            "accessModifier" : "private,static,final",
            "value" : "LoggerFactory.getLogger(SchemaUtil.class)",
            "type" : "Logger",
            "comments" : null
          } ],
          "constructors" : [ {
            "name" : "SchemaUtil",
            "arguments" : [ ],
            "accessModifier" : "private",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "private SchemaUtil() {\n}"
          } ],
          "extends" : [ ],
          "implements" : [ ],
          "nestedClass" : null,
          "accessSpecifier" : "public , final",
          "records" : null,
          "imports" : [ {
            "dereferencedParts" : [ ],
            "name" : "java.time.Duration"
          }, {
            "dereferencedParts" : [ ],
            "name" : "com.datastax.oss.driver.api.core.CqlSession"
          }, {
            "dereferencedParts" : [ ],
            "name" : "com.datastax.oss.driver.api.core.cql.SimpleStatement"
          }, {
            "dereferencedParts" : [ ],
            "name" : "com.datastax.oss.driver.api.querybuilder.SchemaBuilder"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.slf4j.Logger"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.slf4j.LoggerFactory"
          } ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/cassandra/SchemaUtil.java",
        "name" : "org.springframework.ai.cassandra.SchemaUtil"
      } ],
      "classes" : [ {
        "name" : "CassandraChatMemoryConfig",
        "comments" : "Configuration for the Cassandra Chat Memory store.",
        "annotations" : [ ],
        "methods" : [ {
          "name" : "builder",
          "arguments" : [ ],
          "accessModifier" : "public,static",
          "methodsCalled" : [ ],
          "usedEntities" : [ ],
          "annotations" : [ ],
          "returnType" : "Builder",
          "comments" : null,
          "methodDefinition" : "public static Builder builder() {\n    return new Builder();\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemoryConfig.java",
          "test_exists" : true,
          "test_functions" : {
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreObservationIT.java" : {
              "observationVectorStoreAddAndQueryOperations" : {
                "definition" : "@Test\nvoid observationVectorStoreAddAndQueryOperations() {\n    this.contextRunner.run(context -> {\n        VectorStore vectorStore = context.getBean(VectorStore.class);\n        TestObservationRegistry observationRegistry = context.getBean(TestObservationRegistry.class);\n        vectorStore.add(this.documents);\n        TestObservationRegistryAssert.assertThat(observationRegistry).doesNotHaveAnyRemainingCurrentObservation().hasObservationWithNameEqualTo(DefaultVectorStoreObservationConvention.DEFAULT_NAME).that().hasContextualNameEqualTo(\"%s add\".formatted(VectorStoreProvider.CASSANDRA.value())).hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_OPERATION_NAME.asString(), \"add\").hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_SYSTEM.asString(), VectorStoreProvider.CASSANDRA.value()).hasLowCardinalityKeyValue(LowCardinalityKeyNames.SPRING_AI_KIND.asString(), SpringAiKind.VECTOR_STORE.value()).doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_QUERY_CONTENT.asString()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_DIMENSION_COUNT.asString(), \"384\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_COLLECTION_NAME.asString(), CassandraVectorStore.DEFAULT_TABLE_NAME).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_NAMESPACE.asString(), \"test_springframework\").doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_FIELD_NAME.asString()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_SEARCH_SIMILARITY_METRIC.asString(), VectorStoreSimilarityMetric.COSINE.value()).doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_QUERY_TOP_K.asString()).doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_QUERY_SIMILARITY_THRESHOLD.asString()).hasBeenStarted().hasBeenStopped();\n        observationRegistry.clear();\n        List<Document> results = vectorStore.similaritySearch(SearchRequest.builder().query(\"What is Great Depression\").topK(1).build());\n        assertThat(results).isNotEmpty();\n        TestObservationRegistryAssert.assertThat(observationRegistry).doesNotHaveAnyRemainingCurrentObservation().hasObservationWithNameEqualTo(DefaultVectorStoreObservationConvention.DEFAULT_NAME).that().hasContextualNameEqualTo(\"%s query\".formatted(VectorStoreProvider.CASSANDRA.value())).hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_OPERATION_NAME.asString(), \"query\").hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_SYSTEM.asString(), VectorStoreProvider.CASSANDRA.value()).hasLowCardinalityKeyValue(LowCardinalityKeyNames.SPRING_AI_KIND.asString(), SpringAiKind.VECTOR_STORE.value()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_QUERY_CONTENT.asString(), \"What is Great Depression\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_DIMENSION_COUNT.asString(), \"384\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_COLLECTION_NAME.asString(), CassandraVectorStore.DEFAULT_TABLE_NAME).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_NAMESPACE.asString(), \"test_springframework\").doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_FIELD_NAME.asString()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_SEARCH_SIMILARITY_METRIC.asString(), VectorStoreSimilarityMetric.COSINE.value()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_QUERY_TOP_K.asString(), \"1\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_QUERY_SIMILARITY_THRESHOLD.asString(), \"0.0\").hasBeenStarted().hasBeenStopped();\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/WikiVectorStoreExample.java" : {
              "ensureBeanGetsCreated" : {
                "definition" : "@Test\nvoid ensureBeanGetsCreated() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore store = context.getBean(CassandraVectorStore.class);\n        Assertions.assertNotNull(store);\n        store.checkSchemaValid();\n        store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n    });\n}"
              },
              "search" : {
                "definition" : "@Test\nvoid search() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore store = context.getBean(CassandraVectorStore.class);\n        Assertions.assertNotNull(store);\n        store.checkSchemaValid();\n        var results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n        assertThat(results).hasSize(1);\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreIT.java" : {
              "storeBuilder" : {
                "definition" : "private static CassandraVectorStore.Builder storeBuilder(CqlSession cqlSession, EmbeddingModel embeddingModel) {\n    return CassandraVectorStore.builder(embeddingModel).session(cqlSession).keyspace(\"test_\" + CassandraVectorStore.DEFAULT_KEYSPACE_NAME);\n}"
              },
              "addAndSearch" : {
                "definition" : "@Test\nvoid addAndSearch() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"meta1\", DataTypes.TEXT), new SchemaColumn(\"meta2\", DataTypes.TEXT))) {\n            List<Document> documents = documents();\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents().get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Spring AI provides abstractions that serve as the foundation for developing AI applications.\");\n            assertThat(resultDoc.getMetadata()).hasSize(2);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"meta1\", DocumentMetadata.DISTANCE.value());\n            \n            store.delete(documents().stream().map(doc -> doc.getId()).toList());\n            results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).isEmpty();\n        }\n    });\n}"
              },
              "addAndSearchReturnEmbeddings" : {
                "definition" : "@Test\nvoid addAndSearchReturnEmbeddings() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore.Builder builder = storeBuilder(context.getBean(CqlSession.class), context.getBean(EmbeddingModel.class)).returnEmbeddings(true);\n        try (CassandraVectorStore store = createTestStore(context, builder)) {\n            List<Document> documents = documents();\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents().get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Spring AI provides abstractions that serve as the foundation for developing AI applications.\");\n            assertThat(resultDoc.getMetadata()).hasSize(1);\n            assertThat(resultDoc.getMetadata()).containsKey(DocumentMetadata.DISTANCE.value());\n            \n            store.delete(documents().stream().map(doc -> doc.getId()).toList());\n            results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).isEmpty();\n        }\n    });\n}"
              },
              "searchWithPartitionFilter" : {
                "definition" : "@Test\nvoid searchWithPartitionFilter() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"BG\", \"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"year\", (short) 2020));\n            var nlDocument = new Document(\"NL\", \"The World is Big and Salvation Lurks Around the Corner\", java.util.Collections.emptyMap());\n            var bgDocument2 = new Document(\"BG2\", \"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"%s == 'NL'\", CassandraVectorStore.DEFAULT_ID_NAME)).build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(nlDocument.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"%s == 'BG2'\", CassandraVectorStore.DEFAULT_ID_NAME)).build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(bgDocument2.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"%s == 'BG' && year == 2020\", CassandraVectorStore.DEFAULT_ID_NAME)).build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(bgDocument.getId());\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"NOT(%s == 'BG' && year == 2020)\", CassandraVectorStore.DEFAULT_ID_NAME)).build()));\n        }\n    });\n}"
              },
              "unsearchableFilters" : {
                "definition" : "@Test\nvoid unsearchableFilters() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'NL'\").build()));\n        }\n    });\n}"
              },
              "searchWithFilters" : {
                "definition" : "@Test\nvoid searchWithFilters() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"country\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'NL'\").build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(nlDocument.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'BG'\").build());\n            assertThat(results).hasSize(2);\n            assertThat(results.get(0).getId()).isIn(bgDocument.getId(), bgDocument2.getId());\n            assertThat(results.get(1).getId()).isIn(bgDocument.getId(), bgDocument2.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'BG' && year == 2020\").build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(bgDocument.getId());\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'BG' || year == 2020\").build()));\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"NOT(country == 'BG' && year == 2020)\").build()));\n        }\n    });\n}"
              },
              "documentUpdate" : {
                "definition" : "@Test\nvoid documentUpdate() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            Document document = new Document(UUID.randomUUID().toString(), \"Spring AI rocks!!\", Collections.singletonMap(\"meta1\", \"meta1\"));\n            store.add(List.of(document));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(5).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(document.getId());\n            assertThat(resultDoc.getText()).isEqualTo(\"Spring AI rocks!!\");\n            assertThat(resultDoc.getMetadata()).containsKey(\"meta1\");\n            Document sameIdDocument = new Document(document.getId(), \"The World is Big and Salvation Lurks Around the Corner\", Collections.singletonMap(\"meta2\", \"meta2\"));\n            store.add(List.of(sameIdDocument));\n            results = store.similaritySearch(SearchRequest.builder().query(\"FooBar\").topK(5).build());\n            assertThat(results).hasSize(1);\n            resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(document.getId());\n            assertThat(resultDoc.getText()).isEqualTo(\"The World is Big and Salvation Lurks Around the Corner\");\n            assertThat(resultDoc.getMetadata()).containsKeys(\"meta2\", DocumentMetadata.DISTANCE.value());\n            store.delete(List.of(document.getId()));\n        }\n    });\n}"
              },
              "searchWithThreshold" : {
                "definition" : "@Test\nvoid searchWithThreshold() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            store.add(documents());\n            List<Document> fullResult = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(5).similarityThresholdAll().build());\n            List<Double> scores = fullResult.stream().map(Document::getScore).toList();\n            assertThat(scores).hasSize(3);\n            double similarityThreshold = (scores.get(0) + scores.get(1)) / 2;\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(5).similarityThreshold(similarityThreshold).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents().get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Spring AI provides abstractions that serve as the foundation for developing AI applications.\");\n            assertThat(resultDoc.getMetadata()).containsKeys(\"meta1\", DocumentMetadata.DISTANCE.value());\n            assertThat(resultDoc.getScore()).isGreaterThanOrEqualTo(similarityThreshold);\n        }\n    });\n}"
              },
              "deleteByFilter" : {
                "definition" : "@Test\nprotected void deleteByFilter() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"country\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            \n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            \n            Filter.Expression filterExpression = new Filter.Expression(Filter.ExpressionType.EQ, new Filter.Key(\"country\"), new Filter.Value(\"BG\"));\n            store.delete(filterExpression);\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getMetadata()).containsEntry(\"country\", \"NL\");\n        }\n    });\n}"
              },
              "deleteWithStringFilterExpression" : {
                "definition" : "@Test\nprotected void deleteWithStringFilterExpression() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"country\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            \n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            store.delete(\"country == 'BG'\");\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getMetadata()).containsEntry(\"country\", \"NL\");\n        }\n    });\n}"
              },
              "deleteWithComplexFilterExpression" : {
                "definition" : "@Test\nvoid deleteWithComplexFilterExpression() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"type\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"priority\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var doc1 = new Document(\"Content 1\", Map.of(\"type\", \"A\", \"priority\", (short) 1));\n            var doc2 = new Document(\"Content 2\", Map.of(\"type\", \"A\", \"priority\", (short) 2));\n            var doc3 = new Document(\"Content 3\", Map.of(\"type\", \"B\", \"priority\", (short) 1));\n            store.add(List.of(doc1, doc2, doc3));\n            \n            Filter.Expression priorityFilter = new Filter.Expression(Filter.ExpressionType.GT, new Filter.Key(\"priority\"), new Filter.Value((short) 1));\n            Filter.Expression typeFilter = new Filter.Expression(Filter.ExpressionType.EQ, new Filter.Key(\"type\"), new Filter.Value(\"A\"));\n            Filter.Expression complexFilter = new Filter.Expression(Filter.ExpressionType.AND, typeFilter, priorityFilter);\n            store.delete(complexFilter);\n            var results = store.similaritySearch(SearchRequest.builder().query(\"Content\").topK(5).similarityThresholdAll().build());\n            assertThat(results).hasSize(2);\n            assertThat(results.stream().map(doc -> doc.getMetadata().get(\"type\")).collect(Collectors.toList())).containsExactlyInAnyOrder(\"A\", \"B\");\n            assertThat(results.stream().map(doc -> ((Short) doc.getMetadata().get(\"priority\")).intValue()).collect(Collectors.toList())).containsExactlyInAnyOrder(1, 1);\n        }\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraRichSchemaVectorStoreIT.java" : {
              "storeBuilder" : {
                "definition" : "static CassandraVectorStore.Builder storeBuilder(ApplicationContext context, List<CassandraVectorStore.SchemaColumn> columnOverrides) throws IOException {\n    Optional<CassandraVectorStore.SchemaColumn> wikiOverride = columnOverrides.stream().filter(f -> \"wiki\".equals(f.name())).findFirst();\n    Optional<CassandraVectorStore.SchemaColumn> langOverride = columnOverrides.stream().filter(f -> \"language\".equals(f.name())).findFirst();\n    Optional<CassandraVectorStore.SchemaColumn> titleOverride = columnOverrides.stream().filter(f -> \"title\".equals(f.name())).findFirst();\n    Optional<CassandraVectorStore.SchemaColumn> chunkNoOverride = columnOverrides.stream().filter(f -> \"chunk_no\".equals(f.name())).findFirst();\n    var wikiSC = wikiOverride.orElse(new CassandraVectorStore.SchemaColumn(\"wiki\", DataTypes.TEXT));\n    var langSC = langOverride.orElse(new CassandraVectorStore.SchemaColumn(\"language\", DataTypes.TEXT));\n    var titleSC = titleOverride.orElse(new CassandraVectorStore.SchemaColumn(\"title\", DataTypes.TEXT));\n    var chunkNoSC = chunkNoOverride.orElse(new CassandraVectorStore.SchemaColumn(\"chunk_no\", DataTypes.INT));\n    List<CassandraVectorStore.SchemaColumn> partitionKeys = List.of(wikiSC, langSC, titleSC);\n    List<CassandraVectorStore.SchemaColumn> clusteringKeys = List.of(chunkNoSC);\n    return CassandraVectorStore.builder(context.getBean(EmbeddingModel.class)).session(context.getBean(CqlSession.class)).keyspace(\"test_wikidata\").table(\"articles\").partitionKeys(partitionKeys).clusteringKeys(clusteringKeys).contentColumnName(\"body\").embeddingColumnName(\"all_minilm_l6_v2_embedding\").indexName(\"all_minilm_l6_v2_ann\").addMetadataColumns(new CassandraVectorStore.SchemaColumn(\"revision\", DataTypes.INT), new CassandraVectorStore.SchemaColumn(\"id\", DataTypes.INT, CassandraVectorStore.SchemaColumnTags.INDEXED)).\n    \n    primaryKeyTranslator((List<Object> primaryKeys) -> {\n        if (primaryKeys.isEmpty()) {\n            return \"test§¶0\";\n        }\n        return String.format(\"%s§¶%s\", primaryKeys.get(2), primaryKeys.get(3));\n    }).documentIdTranslator(id -> {\n        String[] parts = id.split(\"§¶\");\n        String title = parts[0];\n        int chunk_no = 0 < parts.length ? Integer.parseInt(parts[1]) : 0;\n        return List.of(\"simplewiki\", \"en\", title, chunk_no);\n    });\n}"
              },
              "ensureSchemaCreation" : {
                "definition" : "@Test\nvoid ensureSchemaCreation() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            Assertions.assertNotNull(store);\n            store.checkSchemaValid();\n            store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n        }\n    });\n}"
              },
              "ensureSchemaNoCreation" : {
                "definition" : "@Test\nvoid ensureSchemaNoCreation() {\n    this.contextRunner.run(context -> {\n        executeCqlFile(context, \"test_wiki_full_schema.cql\");\n        var builder = createBuilder(context, List.of(), true, false);\n        Assertions.assertNotNull(builder);\n        var store = new CassandraVectorStore(builder);\n        try {\n            store.checkSchemaValid();\n            store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            CassandraVectorStore.dropKeyspace(builder);\n            executeCqlFile(context, \"test_wiki_partial_3_schema.cql\");\n            \n            IllegalStateException ise = Assertions.assertThrows(IllegalStateException.class, () -> createStore(context, List.of(), true, false));\n            Assertions.assertEquals(\"column all_minilm_l6_v2_embedding does not exist\", ise.getMessage());\n        } finally {\n            CassandraVectorStore.dropKeyspace(builder);\n            store.close();\n        }\n    });\n}"
              },
              "ensureSchemaPartialCreation" : {
                "definition" : "@Test\nvoid ensureSchemaPartialCreation() {\n    this.contextRunner.run(context -> {\n        int PARTIAL_FILES = 5;\n        for (int i = 0; i < PARTIAL_FILES; ++i) {\n            executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", i));\n            var builder = createBuilder(context, List.of(), false, false);\n            Assertions.assertNotNull(builder);\n            CassandraVectorStore.dropKeyspace(builder);\n            var store = builder.build();\n            try {\n                store.checkSchemaValid();\n                store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            } finally {\n                CassandraVectorStore.dropKeyspace(builder);\n                store.close();\n            }\n        }\n        \n        Assertions.assertThrows(IOException.class, () -> executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", PARTIAL_FILES)));\n    });\n}"
              },
              "addAndSearch" : {
                "definition" : "@Test\nvoid addAndSearch() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Neptunes gravity makes its atmosphere\").topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents.get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Neptunes gravity makes its atmosphere\");\n            assertThat(resultDoc.getMetadata()).hasSize(3);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"id\", \"revision\", DocumentMetadata.DISTANCE.value());\n            \n            store.delete(documents.stream().map(doc -> doc.getId()).toList());\n            results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).isEmpty();\n        }\n    });\n}"
              },
              "addAndSearchPoormansBench" : {
                "definition" : "@Test\nvoid addAndSearchPoormansBench() {\n    \n    int nThreads = CassandraVectorStore.DEFAULT_ADD_CONCURRENCY;\n    \n    int runs = 10;\n    \n    int docsPerAdd = 12;\n    int rounds = 3;\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = storeBuilder(context, List.of()).fixedThreadPoolExecutorSize(nThreads).build()) {\n            var executor = Executors.newFixedThreadPool((int) (nThreads * 1.2));\n            for (int k = 0; k < rounds; ++k) {\n                long start = System.nanoTime();\n                var futures = new CompletableFuture[runs];\n                for (int j = 0; j < runs; ++j) {\n                    futures[j] = CompletableFuture.runAsync(() -> {\n                        List<Document> documents = new ArrayList<>();\n                        for (int i = docsPerAdd; i >= 0; --i) {\n                            documents.add(new Document(RandomStringUtils.randomAlphanumeric(4) + \"§¶\" + ThreadLocalRandom.current().nextInt(1, 10), RandomStringUtils.randomAlphanumeric(1024), Map.of(\"revision\", ThreadLocalRandom.current().nextInt(1, 100000), \"id\", 1000)));\n                        }\n                        store.add(documents);\n                        var results = store.similaritySearch(SearchRequest.builder().query(RandomStringUtils.randomAlphanumeric(20)).topK(10).build());\n                        assertThat(results).hasSize(10);\n                    }, executor);\n                }\n                CompletableFuture.allOf(futures).join();\n                long time = System.nanoTime() - start;\n                logger.info(\"add+search took an average of {} ms\", Duration.ofNanos(time / runs).toMillis());\n            }\n        }\n    });\n}"
              },
              "searchWithPartitionFilter" : {
                "definition" : "@Test\nvoid searchWithPartitionFilter() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"wiki == 'simplewiki' && language == 'en' && title == 'Neptune'\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            results = store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"wiki == 'simplewiki' && language == 'en' && title == 'Neptune' && id == 558\").build());\n            assertThat(results).hasSize(3);\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"NOT(wiki == 'simplewiki' && language == 'en' && title == 'Neptune' && id == 1)\").build()));\n        }\n    });\n}"
              },
              "unsearchableFilters" : {
                "definition" : "@Test\nvoid unsearchableFilters() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).build());\n            assertThat(results).hasSize(3);\n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"revision == 9385813\").build()));\n        }\n    });\n}"
              },
              "searchWithFilters" : {
                "definition" : "@Test\nvoid searchWithFilters() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id == 558\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id > 557\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id >= 558\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            \n            \n            \n            \n            \n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id > 557 && \\\"chunk_no\\\" == 1\").build()));\n            \n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"id == 558 || revision == 2020\").build()));\n            \n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"NOT(id == 557 || revision == 2020)\").build()));\n        }\n    });\n}"
              },
              "searchWithFilterOnPrimaryKeys" : {
                "definition" : "@Test\nvoid searchWithFilterOnPrimaryKeys() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        List<SchemaColumn> overrides = List.of(new SchemaColumn(\"title\", DataTypes.TEXT, CassandraVectorStore.SchemaColumnTags.INDEXED), new SchemaColumn(\"chunk_no\", DataTypes.INT, CassandraVectorStore.SchemaColumnTags.INDEXED));\n        try (CassandraVectorStore store = createStore(context, overrides, false, true)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).build());\n            assertThat(results).hasSize(3);\n            store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id > 557 && \\\"chunk_no\\\" == 1\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            \n            \n            \n            \n            \n            \n            \n            \n            \n        }\n    });\n}"
              },
              "documentUpdate" : {
                "definition" : "@Test\nvoid documentUpdate() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getText()).contains(URANUS_ORBIT_QUERY);\n            assertThat(resultDoc.getMetadata()).containsKey(\"revision\");\n            String newContent = \"The World is Big and Salvation Lurks Around the Corner\";\n            Document sameIdDocument = new Document(documents.get(1).getId(), newContent, Collections.emptyMap());\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            store.delete(List.of(sameIdDocument.getId()));\n            results = store.similaritySearch(SearchRequest.builder().query(newContent).topK(1).build());\n            assertThat(results).hasSize(1);\n            resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isNotEqualTo(sameIdDocument.getId());\n            assertThat(resultDoc.getText()).doesNotContain(newContent);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"id\", \"revision\", DocumentMetadata.DISTANCE.value());\n        }\n    });\n}"
              },
              "searchWithThreshold" : {
                "definition" : "@Test\nvoid searchWithThreshold() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> fullResult = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().build());\n            List<Double> scores = fullResult.stream().map(Document::getScore).toList();\n            assertThat(scores).hasSize(3);\n            double similarityThreshold = (scores.get(0) + scores.get(1)) / 2;\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThreshold(similarityThreshold).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents.get(1).getId());\n            assertThat(resultDoc.getText()).contains(URANUS_ORBIT_QUERY);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"id\", \"revision\", DocumentMetadata.DISTANCE.value());\n            assertThat(resultDoc.getScore()).isGreaterThanOrEqualTo(similarityThreshold);\n        }\n    });\n}"
              }
            }
          }
        }, {
          "name" : "getPrimaryKeyColumn",
          "arguments" : [ "int index" ],
          "accessModifier" : "",
          "methodsCalled" : [ {
            "name" : "size",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "partitionKeys",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "index" ],
            "body" : ""
          }, {
            "name" : "partitionKeys",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "index - this.schema.partitionKeys().size()" ],
            "body" : ""
          }, {
            "name" : "clusteringKeys",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "size",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "partitionKeys",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "index" ],
          "annotations" : [ ],
          "returnType" : "SchemaColumn",
          "comments" : null,
          "methodDefinition" : "SchemaColumn getPrimaryKeyColumn(int index) {\n    return index < this.schema.partitionKeys().size() ? this.schema.partitionKeys().get(index) : this.schema.clusteringKeys().get(index - this.schema.partitionKeys().size());\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemoryConfig.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "dropKeyspace",
          "arguments" : [ ],
          "accessModifier" : "",
          "methodsCalled" : [ {
            "name" : "checkState",
            "arguments" : [ "this.schema.keyspace.startsWith(\"test_\")", "\"Only test keyspaces can be dropped\"" ],
            "body" : ""
          }, {
            "name" : "startsWith",
            "arguments" : [ "\"test_\"" ],
            "body" : ""
          }, {
            "name" : "execute",
            "arguments" : [ "SchemaBuilder.dropKeyspace(this.schema.keyspace).ifExists().build()" ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : "public CassandraChatMemoryConfig build() {\n    int primaryKeyColumns = this.partitionKeys.size() + this.clusteringKeys.size();\n    int primaryKeysToBind = this.primaryKeyTranslator.apply(UUID.randomUUID().toString()).size();\n    Preconditions.checkArgument(primaryKeyColumns == primaryKeysToBind + 1, \"The primaryKeyTranslator must always return one less element than the number of primary keys in total. The last clustering key remains undefined, expecting to be the timestamp for messages within sessionId. The sessionId can map to any primary key column (though it should map to a partition key column).\");\n    Preconditions.checkArgument(this.clusteringKeys.get(this.clusteringKeys.size() - 1).name().equals(DEFAULT_EXCHANGE_ID_NAME), \"last clustering key must be the exchangeIdColumn\");\n    return new CassandraChatMemoryConfig(this);\n}"
          }, {
            "name" : "ifExists",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "dropKeyspace",
            "arguments" : [ "this.schema.keyspace" ],
            "body" : "@VisibleForTesting\nvoid dropKeyspace() {\n    Preconditions.checkState(this.schema.keyspace.startsWith(\"test_\"), \"Only test keyspaces can be dropped\");\n    this.session.execute(SchemaBuilder.dropKeyspace(this.schema.keyspace).ifExists().build());\n}"
          } ],
          "usedEntities" : [ "Preconditions", "SchemaBuilder" ],
          "annotations" : [ "VisibleForTesting" ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "@VisibleForTesting\nvoid dropKeyspace() {\n    Preconditions.checkState(this.schema.keyspace.startsWith(\"test_\"), \"Only test keyspaces can be dropped\");\n    this.session.execute(SchemaBuilder.dropKeyspace(this.schema.keyspace).ifExists().build());\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemoryConfig.java",
          "test_exists" : true,
          "test_functions" : {
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreIT.java" : {
              "createTestStore" : {
                "definition" : "private static CassandraVectorStore createTestStore(ApplicationContext context, CassandraVectorStore.Builder builder) {\n    CassandraVectorStore.dropKeyspace(builder);\n    CassandraVectorStore store = builder.build();\n    return store;\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraRichSchemaVectorStoreIT.java" : {
              "ensureSchemaNoCreation" : {
                "definition" : "@Test\nvoid ensureSchemaNoCreation() {\n    this.contextRunner.run(context -> {\n        executeCqlFile(context, \"test_wiki_full_schema.cql\");\n        var builder = createBuilder(context, List.of(), true, false);\n        Assertions.assertNotNull(builder);\n        var store = new CassandraVectorStore(builder);\n        try {\n            store.checkSchemaValid();\n            store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            CassandraVectorStore.dropKeyspace(builder);\n            executeCqlFile(context, \"test_wiki_partial_3_schema.cql\");\n            \n            IllegalStateException ise = Assertions.assertThrows(IllegalStateException.class, () -> createStore(context, List.of(), true, false));\n            Assertions.assertEquals(\"column all_minilm_l6_v2_embedding does not exist\", ise.getMessage());\n        } finally {\n            CassandraVectorStore.dropKeyspace(builder);\n            store.close();\n        }\n    });\n}"
              },
              "ensureSchemaPartialCreation" : {
                "definition" : "@Test\nvoid ensureSchemaPartialCreation() {\n    this.contextRunner.run(context -> {\n        int PARTIAL_FILES = 5;\n        for (int i = 0; i < PARTIAL_FILES; ++i) {\n            executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", i));\n            var builder = createBuilder(context, List.of(), false, false);\n            Assertions.assertNotNull(builder);\n            CassandraVectorStore.dropKeyspace(builder);\n            var store = builder.build();\n            try {\n                store.checkSchemaValid();\n                store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            } finally {\n                CassandraVectorStore.dropKeyspace(builder);\n                store.close();\n            }\n        }\n        \n        Assertions.assertThrows(IOException.class, () -> executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", PARTIAL_FILES)));\n    });\n}"
              },
              "createStore" : {
                "definition" : "private CassandraVectorStore createStore(ApplicationContext context, List<SchemaColumn> columnOverrides, boolean disallowSchemaCreation, boolean dropKeyspaceFirst) throws IOException {\n    CassandraVectorStore.Builder builder = storeBuilder(context, columnOverrides);\n    if (disallowSchemaCreation) {\n        builder = builder.disallowSchemaChanges(true);\n    }\n    if (dropKeyspaceFirst) {\n        CassandraVectorStore.dropKeyspace(builder);\n    }\n    return new CassandraVectorStore(builder);\n}"
              },
              "createBuilder" : {
                "definition" : "private CassandraVectorStore.Builder createBuilder(ApplicationContext context, List<SchemaColumn> columnOverrides, boolean disallowSchemaCreation, boolean dropKeyspaceFirst) throws IOException {\n    CassandraVectorStore.Builder builder = storeBuilder(context, columnOverrides);\n    if (disallowSchemaCreation) {\n        builder = builder.disallowSchemaChanges(true);\n    }\n    if (dropKeyspaceFirst) {\n        CassandraVectorStore.dropKeyspace(builder);\n    }\n    return builder;\n}"
              }
            }
          }
        }, {
          "name" : "ensureSchemaExists",
          "arguments" : [ ],
          "accessModifier" : "",
          "methodsCalled" : [ {
            "name" : "ensureKeyspaceExists",
            "arguments" : [ "this.session", "this.schema.keyspace" ],
            "body" : ""
          }, {
            "name" : "ensureTableExists",
            "arguments" : [ ],
            "body" : "private void ensureTableExists() {\n    if (this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).isEmpty()) {\n        CreateTable createTable = null;\n        CreateTableStart createTableStart = SchemaBuilder.createTable(this.schema.keyspace, this.schema.table).ifNotExists();\n        for (SchemaColumn partitionKey : this.schema.partitionKeys) {\n            createTable = (null != createTable ? createTable : createTableStart).withPartitionKey(partitionKey.name, partitionKey.type);\n        }\n        for (SchemaColumn clusteringKey : this.schema.clusteringKeys) {\n            createTable = createTable.withClusteringColumn(clusteringKey.name, clusteringKey.type);\n        }\n        String lastClusteringColumn = this.schema.clusteringKeys.get(this.schema.clusteringKeys.size() - 1).name();\n        CreateTableWithOptions createTableWithOptions = createTable.withColumn(this.userColumn, DataTypes.TEXT).withClusteringOrder(lastClusteringColumn, ClusteringOrder.DESC).\n        withOption(\"compaction\", Map.of(\"class\", \"UnifiedCompactionStrategy\"));\n        if (null != this.timeToLiveSeconds) {\n            createTableWithOptions = createTableWithOptions.withDefaultTimeToLiveSeconds(this.timeToLiveSeconds);\n        }\n        this.session.execute(createTableWithOptions.build());\n    }\n}"
          }, {
            "name" : "ensureTableColumnsExist",
            "arguments" : [ ],
            "body" : "private void ensureTableColumnsExist() {\n    TableMetadata tableMetadata = this.session.getMetadata().getKeyspace(this.schema.keyspace()).get().getTable(this.schema.table()).get();\n    boolean addAssistantColumn = tableMetadata.getColumn(this.assistantColumn).isEmpty();\n    boolean addUserColumn = tableMetadata.getColumn(this.userColumn).isEmpty();\n    if (addAssistantColumn || addUserColumn) {\n        AlterTableAddColumn alterTable = SchemaBuilder.alterTable(this.schema.keyspace(), this.schema.table());\n        if (addAssistantColumn) {\n            alterTable = alterTable.addColumn(this.assistantColumn, DataTypes.TEXT);\n        }\n        if (addUserColumn) {\n            alterTable = alterTable.addColumn(this.userColumn, DataTypes.TEXT);\n        }\n        SimpleStatement stmt = ((AlterTableAddColumnEnd) alterTable).build();\n        logger.debug(\"Executing {}\", stmt.getQuery());\n        this.session.execute(stmt);\n    }\n}"
          }, {
            "name" : "checkSchemaAgreement",
            "arguments" : [ "this.session" ],
            "body" : ""
          }, {
            "name" : "checkSchemaValid",
            "arguments" : [ ],
            "body" : "void checkSchemaValid() {\n    Preconditions.checkState(this.session.getMetadata().getKeyspace(this.schema.keyspace).isPresent(), \"keyspace %s does not exist\", this.schema.keyspace);\n    Preconditions.checkState(this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).isPresent(), \"table %s does not exist\");\n    TableMetadata tableMetadata = this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).get();\n    Preconditions.checkState(tableMetadata.getColumn(this.assistantColumn).isPresent(), \"column %s does not exist\", this.assistantColumn);\n    Preconditions.checkState(tableMetadata.getColumn(this.userColumn).isPresent(), \"column %s does not exist\", this.userColumn);\n}"
          } ],
          "usedEntities" : [ "SchemaUtil" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "void ensureSchemaExists() {\n    if (!this.disallowSchemaChanges) {\n        SchemaUtil.ensureKeyspaceExists(this.session, this.schema.keyspace);\n        ensureTableExists();\n        ensureTableColumnsExist();\n        SchemaUtil.checkSchemaAgreement(this.session);\n    } else {\n        checkSchemaValid();\n    }\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemoryConfig.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "checkSchemaValid",
          "arguments" : [ ],
          "accessModifier" : "",
          "methodsCalled" : [ {
            "name" : "checkState",
            "arguments" : [ "this.session.getMetadata().getKeyspace(this.schema.keyspace).isPresent()", "\"keyspace %s does not exist\"", "this.schema.keyspace" ],
            "body" : ""
          }, {
            "name" : "isPresent",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getKeyspace",
            "arguments" : [ "this.schema.keyspace" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "checkState",
            "arguments" : [ "this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).isPresent()", "\"table %s does not exist\"" ],
            "body" : ""
          }, {
            "name" : "isPresent",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getTable",
            "arguments" : [ "this.schema.table" ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getKeyspace",
            "arguments" : [ "this.schema.keyspace" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getTable",
            "arguments" : [ "this.schema.table" ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getKeyspace",
            "arguments" : [ "this.schema.keyspace" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "checkState",
            "arguments" : [ "tableMetadata.getColumn(this.assistantColumn).isPresent()", "\"column %s does not exist\"", "this.assistantColumn" ],
            "body" : ""
          }, {
            "name" : "isPresent",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getColumn",
            "arguments" : [ "this.assistantColumn" ],
            "body" : ""
          }, {
            "name" : "checkState",
            "arguments" : [ "tableMetadata.getColumn(this.userColumn).isPresent()", "\"column %s does not exist\"", "this.userColumn" ],
            "body" : ""
          }, {
            "name" : "isPresent",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getColumn",
            "arguments" : [ "this.userColumn" ],
            "body" : ""
          } ],
          "usedEntities" : [ "Preconditions", "tableMetadata" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "void checkSchemaValid() {\n    Preconditions.checkState(this.session.getMetadata().getKeyspace(this.schema.keyspace).isPresent(), \"keyspace %s does not exist\", this.schema.keyspace);\n    Preconditions.checkState(this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).isPresent(), \"table %s does not exist\");\n    TableMetadata tableMetadata = this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).get();\n    Preconditions.checkState(tableMetadata.getColumn(this.assistantColumn).isPresent(), \"column %s does not exist\", this.assistantColumn);\n    Preconditions.checkState(tableMetadata.getColumn(this.userColumn).isPresent(), \"column %s does not exist\", this.userColumn);\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemoryConfig.java",
          "test_exists" : true,
          "test_functions" : {
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemoryIT.java" : {
              "ensureBeanGetsCreated" : {
                "definition" : "@Test\nvoid ensureBeanGetsCreated() {\n    this.contextRunner.run(context -> {\n        CassandraChatMemory memory = context.getBean(CassandraChatMemory.class);\n        Assertions.assertNotNull(memory);\n        memory.conf.checkSchemaValid();\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/WikiVectorStoreExample.java" : {
              "ensureBeanGetsCreated" : {
                "definition" : "@Test\nvoid ensureBeanGetsCreated() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore store = context.getBean(CassandraVectorStore.class);\n        Assertions.assertNotNull(store);\n        store.checkSchemaValid();\n        store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n    });\n}"
              },
              "search" : {
                "definition" : "@Test\nvoid search() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore store = context.getBean(CassandraVectorStore.class);\n        Assertions.assertNotNull(store);\n        store.checkSchemaValid();\n        var results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n        assertThat(results).hasSize(1);\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreIT.java" : {
              "ensureBeanGetsCreated" : {
                "definition" : "@Test\nvoid ensureBeanGetsCreated() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            Assertions.assertNotNull(store);\n            store.checkSchemaValid();\n        }\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraRichSchemaVectorStoreIT.java" : {
              "ensureSchemaCreation" : {
                "definition" : "@Test\nvoid ensureSchemaCreation() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            Assertions.assertNotNull(store);\n            store.checkSchemaValid();\n            store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n        }\n    });\n}"
              },
              "ensureSchemaNoCreation" : {
                "definition" : "@Test\nvoid ensureSchemaNoCreation() {\n    this.contextRunner.run(context -> {\n        executeCqlFile(context, \"test_wiki_full_schema.cql\");\n        var builder = createBuilder(context, List.of(), true, false);\n        Assertions.assertNotNull(builder);\n        var store = new CassandraVectorStore(builder);\n        try {\n            store.checkSchemaValid();\n            store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            CassandraVectorStore.dropKeyspace(builder);\n            executeCqlFile(context, \"test_wiki_partial_3_schema.cql\");\n            \n            IllegalStateException ise = Assertions.assertThrows(IllegalStateException.class, () -> createStore(context, List.of(), true, false));\n            Assertions.assertEquals(\"column all_minilm_l6_v2_embedding does not exist\", ise.getMessage());\n        } finally {\n            CassandraVectorStore.dropKeyspace(builder);\n            store.close();\n        }\n    });\n}"
              },
              "ensureSchemaPartialCreation" : {
                "definition" : "@Test\nvoid ensureSchemaPartialCreation() {\n    this.contextRunner.run(context -> {\n        int PARTIAL_FILES = 5;\n        for (int i = 0; i < PARTIAL_FILES; ++i) {\n            executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", i));\n            var builder = createBuilder(context, List.of(), false, false);\n            Assertions.assertNotNull(builder);\n            CassandraVectorStore.dropKeyspace(builder);\n            var store = builder.build();\n            try {\n                store.checkSchemaValid();\n                store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            } finally {\n                CassandraVectorStore.dropKeyspace(builder);\n                store.close();\n            }\n        }\n        \n        Assertions.assertThrows(IOException.class, () -> executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", PARTIAL_FILES)));\n    });\n}"
              }
            }
          }
        }, {
          "name" : "ensureTableExists",
          "arguments" : [ ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "isEmpty",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getTable",
            "arguments" : [ "this.schema.table" ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getKeyspace",
            "arguments" : [ "this.schema.keyspace" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "ifNotExists",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "createTable",
            "arguments" : [ "this.schema.keyspace", "this.schema.table" ],
            "body" : ""
          }, {
            "name" : "withPartitionKey",
            "arguments" : [ "partitionKey.name", "partitionKey.type" ],
            "body" : ""
          }, {
            "name" : "withClusteringColumn",
            "arguments" : [ "clusteringKey.name", "clusteringKey.type" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "this.schema.clusteringKeys.size() - 1" ],
            "body" : ""
          }, {
            "name" : "size",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "withOption",
            "arguments" : [ "\"compaction\"", "Map.of(\"class\", \"UnifiedCompactionStrategy\")" ],
            "body" : ""
          }, {
            "name" : "withClusteringOrder",
            "arguments" : [ "lastClusteringColumn", "ClusteringOrder.DESC" ],
            "body" : ""
          }, {
            "name" : "withColumn",
            "arguments" : [ "this.userColumn", "DataTypes.TEXT" ],
            "body" : ""
          }, {
            "name" : "of",
            "arguments" : [ "\"class\"", "\"UnifiedCompactionStrategy\"" ],
            "body" : ""
          }, {
            "name" : "withDefaultTimeToLiveSeconds",
            "arguments" : [ "this.timeToLiveSeconds" ],
            "body" : ""
          }, {
            "name" : "execute",
            "arguments" : [ "createTableWithOptions.build()" ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : "public CassandraChatMemoryConfig build() {\n    int primaryKeyColumns = this.partitionKeys.size() + this.clusteringKeys.size();\n    int primaryKeysToBind = this.primaryKeyTranslator.apply(UUID.randomUUID().toString()).size();\n    Preconditions.checkArgument(primaryKeyColumns == primaryKeysToBind + 1, \"The primaryKeyTranslator must always return one less element than the number of primary keys in total. The last clustering key remains undefined, expecting to be the timestamp for messages within sessionId. The sessionId can map to any primary key column (though it should map to a partition key column).\");\n    Preconditions.checkArgument(this.clusteringKeys.get(this.clusteringKeys.size() - 1).name().equals(DEFAULT_EXCHANGE_ID_NAME), \"last clustering key must be the exchangeIdColumn\");\n    return new CassandraChatMemoryConfig(this);\n}"
          } ],
          "usedEntities" : [ "SchemaBuilder", "createTable", "createTableStart", "partitionKey", "clusteringKey", "DataTypes", "lastClusteringColumn", "ClusteringOrder", "Map", "createTableWithOptions" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "private void ensureTableExists() {\n    if (this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).isEmpty()) {\n        CreateTable createTable = null;\n        CreateTableStart createTableStart = SchemaBuilder.createTable(this.schema.keyspace, this.schema.table).ifNotExists();\n        for (SchemaColumn partitionKey : this.schema.partitionKeys) {\n            createTable = (null != createTable ? createTable : createTableStart).withPartitionKey(partitionKey.name, partitionKey.type);\n        }\n        for (SchemaColumn clusteringKey : this.schema.clusteringKeys) {\n            createTable = createTable.withClusteringColumn(clusteringKey.name, clusteringKey.type);\n        }\n        String lastClusteringColumn = this.schema.clusteringKeys.get(this.schema.clusteringKeys.size() - 1).name();\n        CreateTableWithOptions createTableWithOptions = createTable.withColumn(this.userColumn, DataTypes.TEXT).withClusteringOrder(lastClusteringColumn, ClusteringOrder.DESC).\n        withOption(\"compaction\", Map.of(\"class\", \"UnifiedCompactionStrategy\"));\n        if (null != this.timeToLiveSeconds) {\n            createTableWithOptions = createTableWithOptions.withDefaultTimeToLiveSeconds(this.timeToLiveSeconds);\n        }\n        this.session.execute(createTableWithOptions.build());\n    }\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemoryConfig.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "ensureTableColumnsExist",
          "arguments" : [ ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getTable",
            "arguments" : [ "this.schema.table()" ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getKeyspace",
            "arguments" : [ "this.schema.keyspace()" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "keyspace",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "table",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "isEmpty",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getColumn",
            "arguments" : [ "this.assistantColumn" ],
            "body" : ""
          }, {
            "name" : "isEmpty",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getColumn",
            "arguments" : [ "this.userColumn" ],
            "body" : ""
          }, {
            "name" : "alterTable",
            "arguments" : [ "this.schema.keyspace()", "this.schema.table()" ],
            "body" : ""
          }, {
            "name" : "keyspace",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "table",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "addColumn",
            "arguments" : [ "this.assistantColumn", "DataTypes.TEXT" ],
            "body" : ""
          }, {
            "name" : "addColumn",
            "arguments" : [ "this.userColumn", "DataTypes.TEXT" ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : "public CassandraChatMemoryConfig build() {\n    int primaryKeyColumns = this.partitionKeys.size() + this.clusteringKeys.size();\n    int primaryKeysToBind = this.primaryKeyTranslator.apply(UUID.randomUUID().toString()).size();\n    Preconditions.checkArgument(primaryKeyColumns == primaryKeysToBind + 1, \"The primaryKeyTranslator must always return one less element than the number of primary keys in total. The last clustering key remains undefined, expecting to be the timestamp for messages within sessionId. The sessionId can map to any primary key column (though it should map to a partition key column).\");\n    Preconditions.checkArgument(this.clusteringKeys.get(this.clusteringKeys.size() - 1).name().equals(DEFAULT_EXCHANGE_ID_NAME), \"last clustering key must be the exchangeIdColumn\");\n    return new CassandraChatMemoryConfig(this);\n}"
          }, {
            "name" : "debug",
            "arguments" : [ "\"Executing {}\"", "stmt.getQuery()" ],
            "body" : ""
          }, {
            "name" : "getQuery",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "execute",
            "arguments" : [ "stmt" ],
            "body" : ""
          } ],
          "usedEntities" : [ "tableMetadata", "addAssistantColumn", "addUserColumn", "SchemaBuilder", "alterTable", "DataTypes", "logger", "stmt" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "private void ensureTableColumnsExist() {\n    TableMetadata tableMetadata = this.session.getMetadata().getKeyspace(this.schema.keyspace()).get().getTable(this.schema.table()).get();\n    boolean addAssistantColumn = tableMetadata.getColumn(this.assistantColumn).isEmpty();\n    boolean addUserColumn = tableMetadata.getColumn(this.userColumn).isEmpty();\n    if (addAssistantColumn || addUserColumn) {\n        AlterTableAddColumn alterTable = SchemaBuilder.alterTable(this.schema.keyspace(), this.schema.table());\n        if (addAssistantColumn) {\n            alterTable = alterTable.addColumn(this.assistantColumn, DataTypes.TEXT);\n        }\n        if (addUserColumn) {\n            alterTable = alterTable.addColumn(this.userColumn, DataTypes.TEXT);\n        }\n        SimpleStatement stmt = ((AlterTableAddColumnEnd) alterTable).build();\n        logger.debug(\"Executing {}\", stmt.getQuery());\n        this.session.execute(stmt);\n    }\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemoryConfig.java",
          "test_exists" : false,
          "test_functions" : { }
        } ],
        "fields" : [ {
          "name" : "DEFAULT_KEYSPACE_NAME",
          "accessModifier" : "public,static,final",
          "value" : "\"springframework\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "DEFAULT_TABLE_NAME",
          "accessModifier" : "public,static,final",
          "value" : "\"ai_chat_memory\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "DEFAULT_SESSION_ID_NAME",
          "accessModifier" : "public,static,final",
          "value" : "\"session_id\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "DEFAULT_EXCHANGE_ID_NAME",
          "accessModifier" : "public,static,final",
          "value" : "\"message_timestamp\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "DEFAULT_ASSISTANT_COLUMN_NAME",
          "accessModifier" : "public,static,final",
          "value" : "\"assistant\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "DEFAULT_USER_COLUMN_NAME",
          "accessModifier" : "public,static,final",
          "value" : "\"user\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "logger",
          "accessModifier" : "private,static,final",
          "value" : "LoggerFactory.getLogger(CassandraChatMemoryConfig.class)",
          "type" : "Logger",
          "comments" : null
        }, {
          "name" : "session",
          "accessModifier" : "final",
          "value" : null,
          "type" : "CqlSession",
          "comments" : null
        }, {
          "name" : "schema",
          "accessModifier" : "final",
          "value" : null,
          "type" : "Schema",
          "comments" : null
        }, {
          "name" : "assistantColumn",
          "accessModifier" : "final",
          "value" : null,
          "type" : "String",
          "comments" : null
        }, {
          "name" : "userColumn",
          "accessModifier" : "final",
          "value" : null,
          "type" : "String",
          "comments" : null
        }, {
          "name" : "primaryKeyTranslator",
          "accessModifier" : "final",
          "value" : null,
          "type" : "SessionIdToPrimaryKeysTranslator",
          "comments" : null
        }, {
          "name" : "timeToLiveSeconds",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "Integer",
          "comments" : null
        }, {
          "name" : "disallowSchemaChanges",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "boolean",
          "comments" : null
        } ],
        "constructors" : [ {
          "name" : "CassandraChatMemoryConfig",
          "arguments" : [ "Builder builder" ],
          "accessModifier" : "private",
          "methodsCalled" : [ ],
          "usedEntities" : [ "builder" ],
          "annotations" : [ ],
          "comments" : null,
          "methodDefinition" : "private CassandraChatMemoryConfig(Builder builder) {\n    this.session = builder.session;\n    this.schema = new Schema(builder.keyspace, builder.table, builder.partitionKeys, builder.clusteringKeys);\n    this.assistantColumn = builder.assistantColumn;\n    this.userColumn = builder.userColumn;\n    this.timeToLiveSeconds = builder.timeToLiveSeconds;\n    this.disallowSchemaChanges = builder.disallowSchemaChanges;\n    this.primaryKeyTranslator = builder.primaryKeyTranslator;\n}"
        } ],
        "extends" : [ ],
        "implements" : [ ],
        "nestedClass" : [ {
          "name" : "SessionIdToPrimaryKeysTranslator",
          "comments" : "Given a string sessionId, return the value for each primary key column.",
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ ],
          "constructors" : [ ],
          "extends" : null,
          "implements" : null,
          "nestedClass" : null,
          "accessSpecifier" : "public",
          "records" : null
        }, {
          "name" : "Builder",
          "comments" : null,
          "annotations" : [ ],
          "methods" : [ {
            "name" : "withCqlSession",
            "arguments" : [ "CqlSession session" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "checkState",
              "arguments" : [ "null == this.sessionBuilder", "\"Cannot call withContactPoint(..) or withLocalDatacenter(..) and this method\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Preconditions", "session" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder withCqlSession(CqlSession session) {\n    Preconditions.checkState(null == this.sessionBuilder, \"Cannot call withContactPoint(..) or withLocalDatacenter(..) and this method\");\n    this.session = session;\n    return this;\n}"
          }, {
            "name" : "addContactPoint",
            "arguments" : [ "InetSocketAddress contactPoint" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "checkState",
              "arguments" : [ "null == this.session", "\"Cannot call withCqlSession(..) and this method\"" ],
              "body" : ""
            }, {
              "name" : "addContactPoint",
              "arguments" : [ "contactPoint" ],
              "body" : "public Builder addContactPoint(InetSocketAddress contactPoint) {\n    Preconditions.checkState(null == this.session, \"Cannot call withCqlSession(..) and this method\");\n    if (null == this.sessionBuilder) {\n        this.sessionBuilder = new CqlSessionBuilder();\n    }\n    this.sessionBuilder.addContactPoint(contactPoint);\n    return this;\n}"
            } ],
            "usedEntities" : [ "Preconditions", "contactPoint" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder addContactPoint(InetSocketAddress contactPoint) {\n    Preconditions.checkState(null == this.session, \"Cannot call withCqlSession(..) and this method\");\n    if (null == this.sessionBuilder) {\n        this.sessionBuilder = new CqlSessionBuilder();\n    }\n    this.sessionBuilder.addContactPoint(contactPoint);\n    return this;\n}"
          }, {
            "name" : "withLocalDatacenter",
            "arguments" : [ "String localDC" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "checkState",
              "arguments" : [ "null == this.session", "\"Cannot call withCqlSession(..) and this method\"" ],
              "body" : ""
            }, {
              "name" : "withLocalDatacenter",
              "arguments" : [ "localDC" ],
              "body" : "public Builder withLocalDatacenter(String localDC) {\n    Preconditions.checkState(null == this.session, \"Cannot call withCqlSession(..) and this method\");\n    if (null == this.sessionBuilder) {\n        this.sessionBuilder = new CqlSessionBuilder();\n    }\n    this.sessionBuilder.withLocalDatacenter(localDC);\n    return this;\n}"
            } ],
            "usedEntities" : [ "Preconditions", "localDC" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder withLocalDatacenter(String localDC) {\n    Preconditions.checkState(null == this.session, \"Cannot call withCqlSession(..) and this method\");\n    if (null == this.sessionBuilder) {\n        this.sessionBuilder = new CqlSessionBuilder();\n    }\n    this.sessionBuilder.withLocalDatacenter(localDC);\n    return this;\n}"
          }, {
            "name" : "withKeyspaceName",
            "arguments" : [ "String keyspace" ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ "keyspace" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder withKeyspaceName(String keyspace) {\n    this.keyspace = keyspace;\n    return this;\n}"
          }, {
            "name" : "withTableName",
            "arguments" : [ "String table" ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ "table" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder withTableName(String table) {\n    this.table = table;\n    return this;\n}"
          }, {
            "name" : "withPartitionKeys",
            "arguments" : [ "List<SchemaColumn> partitionKeys" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "checkArgument",
              "arguments" : [ "!partitionKeys.isEmpty()" ],
              "body" : ""
            }, {
              "name" : "isEmpty",
              "arguments" : [ ],
              "body" : ""
            } ],
            "usedEntities" : [ "Preconditions", "partitionKeys" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder withPartitionKeys(List<SchemaColumn> partitionKeys) {\n    Preconditions.checkArgument(!partitionKeys.isEmpty());\n    this.partitionKeys = partitionKeys;\n    return this;\n}"
          }, {
            "name" : "withClusteringKeys",
            "arguments" : [ "List<SchemaColumn> clusteringKeys" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "checkArgument",
              "arguments" : [ "!clusteringKeys.isEmpty()" ],
              "body" : ""
            }, {
              "name" : "isEmpty",
              "arguments" : [ ],
              "body" : ""
            } ],
            "usedEntities" : [ "Preconditions", "clusteringKeys" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder withClusteringKeys(List<SchemaColumn> clusteringKeys) {\n    Preconditions.checkArgument(!clusteringKeys.isEmpty());\n    this.clusteringKeys = clusteringKeys;\n    return this;\n}"
          }, {
            "name" : "withAssistantColumnName",
            "arguments" : [ "String name" ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ "name" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder withAssistantColumnName(String name) {\n    this.assistantColumn = name;\n    return this;\n}"
          }, {
            "name" : "withUserColumnName",
            "arguments" : [ "String name" ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ "name" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder withUserColumnName(String name) {\n    this.userColumn = name;\n    return this;\n}"
          }, {
            "name" : "withTimeToLive",
            "arguments" : [ "Duration timeToLive" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "checkArgument",
              "arguments" : [ "0 < timeToLive.getSeconds()" ],
              "body" : ""
            }, {
              "name" : "getSeconds",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "toSeconds",
              "arguments" : [ ],
              "body" : ""
            } ],
            "usedEntities" : [ "Preconditions", "timeToLive" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : "How long are messages kept for",
            "methodDefinition" : "public Builder withTimeToLive(Duration timeToLive) {\n    Preconditions.checkArgument(0 < timeToLive.getSeconds());\n    this.timeToLiveSeconds = (int) timeToLive.toSeconds();\n    return this;\n}"
          }, {
            "name" : "disallowSchemaChanges",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder disallowSchemaChanges() {\n    this.disallowSchemaChanges = true;\n    return this;\n}"
          }, {
            "name" : "withChatExchangeToPrimaryKeyTranslator",
            "arguments" : [ "SessionIdToPrimaryKeysTranslator primaryKeyTranslator" ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ "primaryKeyTranslator" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder withChatExchangeToPrimaryKeyTranslator(SessionIdToPrimaryKeysTranslator primaryKeyTranslator) {\n    this.primaryKeyTranslator = primaryKeyTranslator;\n    return this;\n}"
          }, {
            "name" : "build",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "size",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "size",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "size",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "apply",
              "arguments" : [ "UUID.randomUUID().toString()" ],
              "body" : ""
            }, {
              "name" : "toString",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "randomUUID",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "checkArgument",
              "arguments" : [ "primaryKeyColumns == primaryKeysToBind + 1", "\"The primaryKeyTranslator must always return one less element than the number of primary keys in total. The last clustering key remains undefined, expecting to be the timestamp for messages within sessionId. The sessionId can map to any primary key column (though it should map to a partition key column).\"" ],
              "body" : ""
            }, {
              "name" : "checkArgument",
              "arguments" : [ "this.clusteringKeys.get(this.clusteringKeys.size() - 1).name().equals(DEFAULT_EXCHANGE_ID_NAME)", "\"last clustering key must be the exchangeIdColumn\"" ],
              "body" : ""
            }, {
              "name" : "equals",
              "arguments" : [ "DEFAULT_EXCHANGE_ID_NAME" ],
              "body" : ""
            }, {
              "name" : "name",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "get",
              "arguments" : [ "this.clusteringKeys.size() - 1" ],
              "body" : ""
            }, {
              "name" : "size",
              "arguments" : [ ],
              "body" : ""
            } ],
            "usedEntities" : [ "UUID", "Preconditions", "primaryKeyColumns", "primaryKeysToBind", "DEFAULT_EXCHANGE_ID_NAME" ],
            "annotations" : [ ],
            "returnType" : "CassandraChatMemoryConfig",
            "comments" : null,
            "methodDefinition" : "public CassandraChatMemoryConfig build() {\n    int primaryKeyColumns = this.partitionKeys.size() + this.clusteringKeys.size();\n    int primaryKeysToBind = this.primaryKeyTranslator.apply(UUID.randomUUID().toString()).size();\n    Preconditions.checkArgument(primaryKeyColumns == primaryKeysToBind + 1, \"The primaryKeyTranslator must always return one less element than the number of primary keys in total. The last clustering key remains undefined, expecting to be the timestamp for messages within sessionId. The sessionId can map to any primary key column (though it should map to a partition key column).\");\n    Preconditions.checkArgument(this.clusteringKeys.get(this.clusteringKeys.size() - 1).name().equals(DEFAULT_EXCHANGE_ID_NAME), \"last clustering key must be the exchangeIdColumn\");\n    return new CassandraChatMemoryConfig(this);\n}"
          } ],
          "fields" : [ {
            "name" : "session",
            "accessModifier" : "private",
            "value" : "null",
            "type" : "CqlSession",
            "comments" : null
          }, {
            "name" : "sessionBuilder",
            "accessModifier" : "private",
            "value" : "null",
            "type" : "CqlSessionBuilder",
            "comments" : null
          }, {
            "name" : "keyspace",
            "accessModifier" : "private",
            "value" : "DEFAULT_KEYSPACE_NAME",
            "type" : "String",
            "comments" : null
          }, {
            "name" : "table",
            "accessModifier" : "private",
            "value" : "DEFAULT_TABLE_NAME",
            "type" : "String",
            "comments" : null
          }, {
            "name" : "partitionKeys",
            "accessModifier" : "private",
            "value" : "List.of(new SchemaColumn(DEFAULT_SESSION_ID_NAME, DataTypes.TEXT))",
            "type" : "List<SchemaColumn>",
            "comments" : null
          }, {
            "name" : "clusteringKeys",
            "accessModifier" : "private",
            "value" : "List.of(new SchemaColumn(DEFAULT_EXCHANGE_ID_NAME, DataTypes.TIMESTAMP))",
            "type" : "List<SchemaColumn>",
            "comments" : null
          }, {
            "name" : "assistantColumn",
            "accessModifier" : "private",
            "value" : "DEFAULT_ASSISTANT_COLUMN_NAME",
            "type" : "String",
            "comments" : null
          }, {
            "name" : "userColumn",
            "accessModifier" : "private",
            "value" : "DEFAULT_USER_COLUMN_NAME",
            "type" : "String",
            "comments" : null
          }, {
            "name" : "timeToLiveSeconds",
            "accessModifier" : "private",
            "value" : "null",
            "type" : "Integer",
            "comments" : null
          }, {
            "name" : "disallowSchemaChanges",
            "accessModifier" : "private",
            "value" : "false",
            "type" : "boolean",
            "comments" : null
          }, {
            "name" : "primaryKeyTranslator",
            "accessModifier" : "private",
            "value" : "List::of",
            "type" : "SessionIdToPrimaryKeysTranslator",
            "comments" : null
          } ],
          "constructors" : [ {
            "name" : "Builder",
            "arguments" : [ ],
            "accessModifier" : "private",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "private Builder() {\n}"
          } ],
          "extends" : null,
          "implements" : null,
          "nestedClass" : null,
          "accessSpecifier" : "public , static , final",
          "records" : null
        } ],
        "accessSpecifier" : "public , final",
        "records" : [ {
          "name" : "Schema",
          "comments" : null,
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ {
            "name" : "keyspace",
            "accessModifier" : "public",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "table",
            "accessModifier" : "public",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "partitionKeys",
            "accessModifier" : "public",
            "value" : null,
            "type" : "List<SchemaColumn>",
            "comments" : null
          }, {
            "name" : "clusteringKeys",
            "accessModifier" : "public",
            "value" : null,
            "type" : "List<SchemaColumn>",
            "comments" : null
          } ],
          "constructors" : [ ],
          "extends" : null,
          "implements" : null,
          "nestedClass" : null,
          "accessSpecifier" : "",
          "records" : null
        }, {
          "name" : "SchemaColumn",
          "comments" : null,
          "annotations" : [ ],
          "methods" : [ {
            "name" : "javaType",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "getJavaType",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "codecFor",
              "arguments" : [ "this.type" ],
              "body" : ""
            } ],
            "usedEntities" : [ "CodecRegistry" ],
            "annotations" : [ ],
            "returnType" : "GenericType<Object>",
            "comments" : null,
            "methodDefinition" : "public GenericType<Object> javaType() {\n    return CodecRegistry.DEFAULT.codecFor(this.type).getJavaType();\n}"
          } ],
          "fields" : [ {
            "name" : "name",
            "accessModifier" : "public",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "type",
            "accessModifier" : "public",
            "value" : null,
            "type" : "DataType",
            "comments" : null
          } ],
          "constructors" : [ ],
          "extends" : null,
          "implements" : null,
          "nestedClass" : null,
          "accessSpecifier" : "public",
          "records" : null
        } ]
      } ],
      "records" : [ ],
      "samePackageClasses" : [ ]
    }
  },
  "org.springframework.ai.cassandra" : {
    "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/cassandra/SchemaUtil.java" : {
      "imports" : [ {
        "dereferencedParts" : [ ],
        "name" : "java.time.Duration"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.CqlSession"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.cql.SimpleStatement"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.SchemaBuilder"
      }, {
        "dereferencedParts" : [ ],
        "name" : "org.slf4j.Logger"
      }, {
        "dereferencedParts" : [ ],
        "name" : "org.slf4j.LoggerFactory"
      } ],
      "classes" : [ {
        "name" : "SchemaUtil",
        "comments" : "Utility class for working with Cassandra schema.",
        "annotations" : [ ],
        "methods" : [ {
          "name" : "checkSchemaAgreement",
          "arguments" : [ "CqlSession session" ],
          "accessModifier" : "public,static",
          "methodsCalled" : [ {
            "name" : "checkSchemaAgreement",
            "arguments" : [ ],
            "body" : "public static void checkSchemaAgreement(CqlSession session) throws IllegalStateException {\n    if (!session.checkSchemaAgreement()) {\n        logger.warn(\"Waiting for cluster schema agreement, sleeping 10s…\");\n        try {\n            Thread.sleep(Duration.ofSeconds(10).toMillis());\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n            throw new IllegalStateException(ex);\n        }\n        if (!session.checkSchemaAgreement()) {\n            logger.error(\"no cluster schema agreement still, continuing, let's hope this works…\");\n        }\n    }\n}"
          }, {
            "name" : "warn",
            "arguments" : [ "\"Waiting for cluster schema agreement, sleeping 10s…\"" ],
            "body" : ""
          }, {
            "name" : "sleep",
            "arguments" : [ "Duration.ofSeconds(10).toMillis()" ],
            "body" : ""
          }, {
            "name" : "toMillis",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "ofSeconds",
            "arguments" : [ "10" ],
            "body" : ""
          }, {
            "name" : "interrupt",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "currentThread",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "checkSchemaAgreement",
            "arguments" : [ ],
            "body" : "public static void checkSchemaAgreement(CqlSession session) throws IllegalStateException {\n    if (!session.checkSchemaAgreement()) {\n        logger.warn(\"Waiting for cluster schema agreement, sleeping 10s…\");\n        try {\n            Thread.sleep(Duration.ofSeconds(10).toMillis());\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n            throw new IllegalStateException(ex);\n        }\n        if (!session.checkSchemaAgreement()) {\n            logger.error(\"no cluster schema agreement still, continuing, let's hope this works…\");\n        }\n    }\n}"
          }, {
            "name" : "error",
            "arguments" : [ "\"no cluster schema agreement still, continuing, let's hope this works…\"" ],
            "body" : ""
          } ],
          "usedEntities" : [ "session", "logger", "Thread", "Duration", "ex" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "public static void checkSchemaAgreement(CqlSession session) throws IllegalStateException {\n    if (!session.checkSchemaAgreement()) {\n        logger.warn(\"Waiting for cluster schema agreement, sleeping 10s…\");\n        try {\n            Thread.sleep(Duration.ofSeconds(10).toMillis());\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n            throw new IllegalStateException(ex);\n        }\n        if (!session.checkSchemaAgreement()) {\n            logger.error(\"no cluster schema agreement still, continuing, let's hope this works…\");\n        }\n    }\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/cassandra/SchemaUtil.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "ensureKeyspaceExists",
          "arguments" : [ "CqlSession session", "String keyspaceName" ],
          "accessModifier" : "public,static",
          "methodsCalled" : [ {
            "name" : "isEmpty",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getKeyspace",
            "arguments" : [ "keyspaceName" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "withSimpleStrategy",
            "arguments" : [ "1" ],
            "body" : ""
          }, {
            "name" : "ifNotExists",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "createKeyspace",
            "arguments" : [ "keyspaceName" ],
            "body" : ""
          }, {
            "name" : "debug",
            "arguments" : [ "\"Executing {}\"", "keyspaceStmt.getQuery()" ],
            "body" : ""
          }, {
            "name" : "getQuery",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "execute",
            "arguments" : [ "keyspaceStmt" ],
            "body" : ""
          } ],
          "usedEntities" : [ "session", "keyspaceName", "SchemaBuilder", "logger", "keyspaceStmt" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "public static void ensureKeyspaceExists(CqlSession session, String keyspaceName) {\n    if (session.getMetadata().getKeyspace(keyspaceName).isEmpty()) {\n        SimpleStatement keyspaceStmt = SchemaBuilder.createKeyspace(keyspaceName).ifNotExists().withSimpleStrategy(1).build();\n        logger.debug(\"Executing {}\", keyspaceStmt.getQuery());\n        session.execute(keyspaceStmt);\n    }\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/cassandra/SchemaUtil.java",
          "test_exists" : false,
          "test_functions" : { }
        } ],
        "fields" : [ {
          "name" : "logger",
          "accessModifier" : "private,static,final",
          "value" : "LoggerFactory.getLogger(SchemaUtil.class)",
          "type" : "Logger",
          "comments" : null
        } ],
        "constructors" : [ {
          "name" : "SchemaUtil",
          "arguments" : [ ],
          "accessModifier" : "private",
          "methodsCalled" : [ ],
          "usedEntities" : [ ],
          "annotations" : [ ],
          "comments" : null,
          "methodDefinition" : "private SchemaUtil() {\n}"
        } ],
        "extends" : [ ],
        "implements" : [ ],
        "nestedClass" : null,
        "accessSpecifier" : "public , final",
        "records" : [ ]
      } ],
      "records" : [ ],
      "samePackageClasses" : [ ]
    }
  },
  "org.springframework.ai.vectorstore.cassandra" : {
    "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/package-info.java" : {
      "imports" : [ {
        "dereferencedParts" : [ ],
        "name" : "org.springframework.lang.NonNullApi"
      }, {
        "dereferencedParts" : [ ],
        "name" : "org.springframework.lang.NonNullFields"
      } ],
      "classes" : [ ],
      "records" : [ ],
      "samePackageClasses" : [ ]
    },
    "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java" : {
      "imports" : [ {
        "dereferencedParts" : [ ],
        "name" : "java.net.InetSocketAddress"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.ArrayList"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.Collections"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.HashMap"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.HashSet"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.List"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.Map"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.Optional"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.Set"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.concurrent.CompletableFuture"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.concurrent.ConcurrentHashMap"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.concurrent.ConcurrentMap"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.concurrent.Executor"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.concurrent.Executors"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.function.Function"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.stream.Collectors"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.stream.Stream"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.CqlSession"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.CqlSessionBuilder"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.cql.BoundStatement"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.cql.BoundStatementBuilder"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.cql.PreparedStatement"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.cql.Row"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.cql.SimpleStatement"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.data.CqlVector"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.metadata.schema.ColumnMetadata"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.metadata.schema.TableMetadata"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.type.DataType"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.type.DataTypes"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.type.codec.registry.CodecRegistry"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.type.reflect.GenericType"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.BuildableQuery"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.QueryBuilder"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.SchemaBuilder"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.delete.Delete"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.delete.DeleteSelection"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.insert.InsertInto"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.insert.RegularInsert"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.schema.AlterTableAddColumn"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.schema.AlterTableAddColumnEnd"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.schema.CreateTable"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.querybuilder.schema.CreateTableStart"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.shaded.guava.common.annotations.VisibleForTesting"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.shaded.guava.common.base.Preconditions"
      }, {
        "dereferencedParts" : [ ],
        "name" : "org.slf4j.Logger"
      }, {
        "dereferencedParts" : [ ],
        "name" : "org.slf4j.LoggerFactory"
      }, {
        "dereferencedParts" : [ {
          "name" : "SchemaUtil",
          "comments" : "Utility class for working with Cassandra schema.",
          "annotations" : [ ],
          "methods" : [ {
            "name" : "checkSchemaAgreement",
            "arguments" : [ "CqlSession session" ],
            "accessModifier" : "public,static",
            "methodsCalled" : [ {
              "name" : "checkSchemaAgreement",
              "arguments" : [ ],
              "body" : "public static void checkSchemaAgreement(CqlSession session) throws IllegalStateException {\n    if (!session.checkSchemaAgreement()) {\n        logger.warn(\"Waiting for cluster schema agreement, sleeping 10s…\");\n        try {\n            Thread.sleep(Duration.ofSeconds(10).toMillis());\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n            throw new IllegalStateException(ex);\n        }\n        if (!session.checkSchemaAgreement()) {\n            logger.error(\"no cluster schema agreement still, continuing, let's hope this works…\");\n        }\n    }\n}"
            }, {
              "name" : "warn",
              "arguments" : [ "\"Waiting for cluster schema agreement, sleeping 10s…\"" ],
              "body" : ""
            }, {
              "name" : "sleep",
              "arguments" : [ "Duration.ofSeconds(10).toMillis()" ],
              "body" : ""
            }, {
              "name" : "toMillis",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "ofSeconds",
              "arguments" : [ "10" ],
              "body" : ""
            }, {
              "name" : "interrupt",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "currentThread",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "checkSchemaAgreement",
              "arguments" : [ ],
              "body" : "public static void checkSchemaAgreement(CqlSession session) throws IllegalStateException {\n    if (!session.checkSchemaAgreement()) {\n        logger.warn(\"Waiting for cluster schema agreement, sleeping 10s…\");\n        try {\n            Thread.sleep(Duration.ofSeconds(10).toMillis());\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n            throw new IllegalStateException(ex);\n        }\n        if (!session.checkSchemaAgreement()) {\n            logger.error(\"no cluster schema agreement still, continuing, let's hope this works…\");\n        }\n    }\n}"
            }, {
              "name" : "error",
              "arguments" : [ "\"no cluster schema agreement still, continuing, let's hope this works…\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "session", "logger", "Thread", "Duration", "ex" ],
            "annotations" : [ ],
            "returnType" : "void",
            "comments" : null,
            "methodDefinition" : "public static void checkSchemaAgreement(CqlSession session) throws IllegalStateException {\n    if (!session.checkSchemaAgreement()) {\n        logger.warn(\"Waiting for cluster schema agreement, sleeping 10s…\");\n        try {\n            Thread.sleep(Duration.ofSeconds(10).toMillis());\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n            throw new IllegalStateException(ex);\n        }\n        if (!session.checkSchemaAgreement()) {\n            logger.error(\"no cluster schema agreement still, continuing, let's hope this works…\");\n        }\n    }\n}"
          }, {
            "name" : "ensureKeyspaceExists",
            "arguments" : [ "CqlSession session", "String keyspaceName" ],
            "accessModifier" : "public,static",
            "methodsCalled" : [ {
              "name" : "isEmpty",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getKeyspace",
              "arguments" : [ "keyspaceName" ],
              "body" : ""
            }, {
              "name" : "getMetadata",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "build",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "withSimpleStrategy",
              "arguments" : [ "1" ],
              "body" : ""
            }, {
              "name" : "ifNotExists",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "createKeyspace",
              "arguments" : [ "keyspaceName" ],
              "body" : ""
            }, {
              "name" : "debug",
              "arguments" : [ "\"Executing {}\"", "keyspaceStmt.getQuery()" ],
              "body" : ""
            }, {
              "name" : "getQuery",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "execute",
              "arguments" : [ "keyspaceStmt" ],
              "body" : ""
            } ],
            "usedEntities" : [ "session", "keyspaceName", "SchemaBuilder", "logger", "keyspaceStmt" ],
            "annotations" : [ ],
            "returnType" : "void",
            "comments" : null,
            "methodDefinition" : "public static void ensureKeyspaceExists(CqlSession session, String keyspaceName) {\n    if (session.getMetadata().getKeyspace(keyspaceName).isEmpty()) {\n        SimpleStatement keyspaceStmt = SchemaBuilder.createKeyspace(keyspaceName).ifNotExists().withSimpleStrategy(1).build();\n        logger.debug(\"Executing {}\", keyspaceStmt.getQuery());\n        session.execute(keyspaceStmt);\n    }\n}"
          } ],
          "fields" : [ {
            "name" : "logger",
            "accessModifier" : "private,static,final",
            "value" : "LoggerFactory.getLogger(SchemaUtil.class)",
            "type" : "Logger",
            "comments" : null
          } ],
          "constructors" : [ {
            "name" : "SchemaUtil",
            "arguments" : [ ],
            "accessModifier" : "private",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "private SchemaUtil() {\n}"
          } ],
          "extends" : [ ],
          "implements" : [ ],
          "nestedClass" : null,
          "accessSpecifier" : "public , final",
          "records" : null,
          "imports" : [ {
            "dereferencedParts" : [ ],
            "name" : "java.time.Duration"
          }, {
            "dereferencedParts" : [ ],
            "name" : "com.datastax.oss.driver.api.core.CqlSession"
          }, {
            "dereferencedParts" : [ ],
            "name" : "com.datastax.oss.driver.api.core.cql.SimpleStatement"
          }, {
            "dereferencedParts" : [ ],
            "name" : "com.datastax.oss.driver.api.querybuilder.SchemaBuilder"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.slf4j.Logger"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.slf4j.LoggerFactory"
          } ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/cassandra/SchemaUtil.java",
        "name" : "org.springframework.ai.cassandra.SchemaUtil"
      }, {
        "dereferencedParts" : [ {
          "name" : "Document",
          "comments" : "A document is a container for the content and metadata of a document. It also contains\nthe document's unique ID.\n\nA Document can hold either text content or media content, but not both.\n\nIt is intended to be used to take data from external sources as part of spring-ai's ETL\npipeline.\n\n<p>\nExample of creating a text document: <pre>{@code\n// Using constructor\nDocument textDoc = new Document(\"Sample text content\", Map.of(\"source\", \"user-input\"));\n\n// Using builder\nDocument textDoc = Document.builder()\n    .text(\"Sample text content\")\n    .metadata(\"source\", \"user-input\")\n    .build();\n}</pre>\n\n<p>\nExample of creating a media document: <pre>{@code\n// Using constructor\nMedia imageContent = new Media(MediaType.IMAGE_PNG, new byte[] {...});\nDocument mediaDoc = new Document(imageContent, Map.of(\"filename\", \"sample.png\"));\n\n// Using builder\nDocument mediaDoc = Document.builder()\n    .media(new Media(MediaType.IMAGE_PNG, new byte[] {...}))\n    .metadata(\"filename\", \"sample.png\")\n    .build();\n}</pre>\n\n<p>\nExample of checking content type and accessing content: <pre>{@code\nif (document.isText()) {\n    String textContent = document.getText();\n    // Process text content\n} else {\n    Media mediaContent = document.getMedia();\n    // Process media content\n}\n}</pre>",
          "annotations" : [ "JsonIgnoreProperties" ],
          "methods" : [ {
            "name" : "builder",
            "arguments" : [ ],
            "accessModifier" : "public,static",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public static Builder builder() {\n    return new Builder();\n}"
          }, {
            "name" : "getId",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "returnType" : "String",
            "comments" : "Returns the unique identifier for this document.\n<p>\nThis ID is either explicitly provided during document creation or generated using\nthe configured {@link IdGenerator} (defaults to {@link RandomIdGenerator}).",
            "methodDefinition" : "public String getId() {\n    return this.id;\n}"
          }, {
            "name" : "getText",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ "Nullable" ],
            "returnType" : "String",
            "comments" : "Returns the document's text content, if any.",
            "methodDefinition" : "@Nullable\npublic String getText() {\n    return this.text;\n}"
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "returnType" : "Map<String,Object>",
            "comments" : "Returns the metadata associated with this document.\n<p>\nThe metadata values are restricted to simple types (string, int, float, boolean)\nfor compatibility with Vector Databases.",
            "methodDefinition" : "public Map<String, Object> getMetadata() {\n    return this.metadata;\n}"
          } ],
          "fields" : [ {
            "name" : "DEFAULT_CONTENT_FORMATTER",
            "accessModifier" : "public,static,final",
            "value" : "DefaultContentFormatter.defaultConfig()",
            "type" : "ContentFormatter",
            "comments" : null
          }, {
            "name" : "id",
            "accessModifier" : "private,final",
            "value" : null,
            "type" : "String",
            "comments" : "Unique ID"
          }, {
            "name" : "text",
            "accessModifier" : "private,final",
            "value" : null,
            "type" : "String",
            "comments" : "Document string content."
          }, {
            "name" : "media",
            "accessModifier" : "private,final",
            "value" : null,
            "type" : "Media",
            "comments" : "Document media content"
          }, {
            "name" : "metadata",
            "accessModifier" : "private,final",
            "value" : null,
            "type" : "Map<String,Object>",
            "comments" : "Metadata for the document. It should not be nested and values should be restricted\nto string, int, float, boolean for simple use with Vector Dbs."
          }, {
            "name" : "score",
            "accessModifier" : "private,final",
            "value" : null,
            "type" : "Double",
            "comments" : "A numeric score associated with this document that can represent various types of\nrelevance measures.\n<p>\nCommon uses include:\n<ul>\n<li>Measure of similarity between the embedding value of the document's text/media\nand a query vector, where higher scores indicate greater similarity (opposite of\ndistance measure)\n<li>Text relevancy rankings from retrieval systems\n<li>Custom relevancy metrics from RAG patterns\n</ul>\n<p>\nHigher values typically indicate greater relevance or similarity."
          }, {
            "name" : "contentFormatter",
            "accessModifier" : "private",
            "value" : "DEFAULT_CONTENT_FORMATTER",
            "type" : "ContentFormatter",
            "comments" : "Mutable, ephemeral, content to text formatter. Defaults to Document text."
          } ],
          "constructors" : [ {
            "name" : "Document",
            "arguments" : [ "@JsonProperty(\"content\") String content" ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ "JsonCreator", "content" ],
            "annotations" : [ "JsonCreator" ],
            "comments" : null,
            "methodDefinition" : "@JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\npublic Document(@JsonProperty(\"content\") String content) {\n    this(content, new HashMap<>());\n}"
          }, {
            "name" : "Document",
            "arguments" : [ "String text", "Map<String, Object> metadata" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "generateId",
              "arguments" : [ ],
              "body" : ""
            } ],
            "usedEntities" : [ "text", "metadata" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public Document(String text, Map<String, Object> metadata) {\n    this(new RandomIdGenerator().generateId(), text, null, metadata, null);\n}"
          }, {
            "name" : "Document",
            "arguments" : [ "String id", "String text", "Map<String, Object> metadata" ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ "id", "text", "metadata" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public Document(String id, String text, Map<String, Object> metadata) {\n    this(id, text, null, metadata, null);\n}"
          }, {
            "name" : "Document",
            "arguments" : [ "Media media", "Map<String, Object> metadata" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "generateId",
              "arguments" : [ ],
              "body" : ""
            } ],
            "usedEntities" : [ "media", "metadata" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public Document(Media media, Map<String, Object> metadata) {\n    this(new RandomIdGenerator().generateId(), null, media, metadata, null);\n}"
          }, {
            "name" : "Document",
            "arguments" : [ "String id", "Media media", "Map<String, Object> metadata" ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ "id", "media", "metadata" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public Document(String id, Media media, Map<String, Object> metadata) {\n    this(id, null, media, metadata, null);\n}"
          }, {
            "name" : "Document",
            "arguments" : [ "String id", "String text", "Media media", "Map<String, Object> metadata", "@Nullable Double score" ],
            "accessModifier" : "private",
            "methodsCalled" : [ {
              "name" : "hasText",
              "arguments" : [ "id", "\"id cannot be null or empty\"" ],
              "body" : ""
            }, {
              "name" : "notNull",
              "arguments" : [ "metadata", "\"metadata cannot be null\"" ],
              "body" : ""
            }, {
              "name" : "noNullElements",
              "arguments" : [ "metadata.keySet()", "\"metadata cannot have null keys\"" ],
              "body" : ""
            }, {
              "name" : "keySet",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "noNullElements",
              "arguments" : [ "metadata.values()", "\"metadata cannot have null values\"" ],
              "body" : ""
            }, {
              "name" : "values",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "isTrue",
              "arguments" : [ "text != null ^ media != null", "\"exactly one of text or media must be specified\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Assert", "id", "metadata", "text", "media", "score" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "private Document(String id, String text, Media media, Map<String, Object> metadata, @Nullable Double score) {\n    Assert.hasText(id, \"id cannot be null or empty\");\n    Assert.notNull(metadata, \"metadata cannot be null\");\n    Assert.noNullElements(metadata.keySet(), \"metadata cannot have null keys\");\n    Assert.noNullElements(metadata.values(), \"metadata cannot have null values\");\n    Assert.isTrue(text != null ^ media != null, \"exactly one of text or media must be specified\");\n    this.id = id;\n    this.text = text;\n    this.media = media;\n    this.metadata = new HashMap<>(metadata);\n    this.score = score;\n}"
          } ],
          "extends" : [ ],
          "implements" : [ ],
          "nestedClass" : [ {
            "name" : "Builder",
            "comments" : null,
            "annotations" : [ ],
            "methods" : [ {
              "name" : "idGenerator",
              "arguments" : [ "IdGenerator idGenerator" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "notNull",
                "arguments" : [ "idGenerator", "\"idGenerator cannot be null\"" ],
                "body" : ""
              } ],
              "usedEntities" : [ "Assert", "idGenerator" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder idGenerator(IdGenerator idGenerator) {\n    Assert.notNull(idGenerator, \"idGenerator cannot be null\");\n    this.idGenerator = idGenerator;\n    return this;\n}"
            }, {
              "name" : "id",
              "arguments" : [ "String id" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "hasText",
                "arguments" : [ "id", "\"id cannot be null or empty\"" ],
                "body" : ""
              } ],
              "usedEntities" : [ "Assert", "id" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder id(String id) {\n    Assert.hasText(id, \"id cannot be null or empty\");\n    this.id = id;\n    return this;\n}"
            }, {
              "name" : "text",
              "arguments" : [ "@Nullable String text" ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ "text" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : "Sets the text content of the document.\n<p>\nEither text or media content must be set before building the document, but not\nboth.",
              "methodDefinition" : "public Builder text(@Nullable String text) {\n    this.text = text;\n    return this;\n}"
            }, {
              "name" : "media",
              "arguments" : [ "@Nullable Media media" ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ "media" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : "Sets the media content of the document.\n<p>\nEither text or media content must be set before building the document, but not\nboth.",
              "methodDefinition" : "public Builder media(@Nullable Media media) {\n    this.media = media;\n    return this;\n}"
            }, {
              "name" : "metadata",
              "arguments" : [ "Map<String, Object> metadata" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "notNull",
                "arguments" : [ "metadata", "\"metadata cannot be null\"" ],
                "body" : ""
              } ],
              "usedEntities" : [ "Assert", "metadata" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder metadata(Map<String, Object> metadata) {\n    Assert.notNull(metadata, \"metadata cannot be null\");\n    this.metadata = metadata;\n    return this;\n}"
            }, {
              "name" : "metadata",
              "arguments" : [ "String key", "Object value" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "notNull",
                "arguments" : [ "key", "\"metadata key cannot be null\"" ],
                "body" : ""
              }, {
                "name" : "notNull",
                "arguments" : [ "value", "\"metadata value cannot be null\"" ],
                "body" : ""
              }, {
                "name" : "put",
                "arguments" : [ "key", "value" ],
                "body" : ""
              } ],
              "usedEntities" : [ "Assert", "key", "value" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder metadata(String key, Object value) {\n    Assert.notNull(key, \"metadata key cannot be null\");\n    Assert.notNull(value, \"metadata value cannot be null\");\n    this.metadata.put(key, value);\n    return this;\n}"
            }, {
              "name" : "score",
              "arguments" : [ "@Nullable Double score" ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ "score" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : "Sets a score value for this document.\n<p>\nCommon uses include:\n<ul>\n<li>Measure of similarity between the embedding value of the document's\ntext/media and a query vector, where higher scores indicate greater similarity\n(opposite of distance measure)\n<li>Text relevancy rankings from retrieval systems\n<li>Custom relevancy metrics from RAG patterns\n</ul>\n<p>\nHigher values typically indicate greater relevance or similarity.",
              "methodDefinition" : "public Builder score(@Nullable Double score) {\n    this.score = score;\n    return this;\n}"
            }, {
              "name" : "build",
              "arguments" : [ ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "hasText",
                "arguments" : [ "this.id" ],
                "body" : ""
              }, {
                "name" : "generateId",
                "arguments" : [ "this.text", "this.metadata" ],
                "body" : ""
              } ],
              "usedEntities" : [ "StringUtils" ],
              "annotations" : [ ],
              "returnType" : "Document",
              "comments" : null,
              "methodDefinition" : "public Document build() {\n    if (!StringUtils.hasText(this.id)) {\n        this.id = this.idGenerator.generateId(this.text, this.metadata);\n    }\n    return new Document(this.id, this.text, this.media, this.metadata, this.score);\n}"
            } ],
            "fields" : [ {
              "name" : "id",
              "accessModifier" : "private",
              "value" : null,
              "type" : "String",
              "comments" : null
            }, {
              "name" : "text",
              "accessModifier" : "private",
              "value" : null,
              "type" : "String",
              "comments" : null
            }, {
              "name" : "media",
              "accessModifier" : "private",
              "value" : null,
              "type" : "Media",
              "comments" : null
            }, {
              "name" : "metadata",
              "accessModifier" : "private",
              "value" : "new HashMap<>()",
              "type" : "Map<String,Object>",
              "comments" : null
            }, {
              "name" : "score",
              "accessModifier" : "private",
              "value" : null,
              "type" : "Double",
              "comments" : null
            }, {
              "name" : "idGenerator",
              "accessModifier" : "private",
              "value" : "new RandomIdGenerator()",
              "type" : "IdGenerator",
              "comments" : null
            } ],
            "constructors" : [ ],
            "extends" : null,
            "implements" : null,
            "nestedClass" : null,
            "accessSpecifier" : "public , static",
            "records" : null
          } ],
          "accessSpecifier" : "public",
          "records" : null,
          "imports" : [ {
            "dereferencedParts" : [ ],
            "name" : "java.util.HashMap"
          }, {
            "dereferencedParts" : [ ],
            "name" : "java.util.Map"
          }, {
            "dereferencedParts" : [ ],
            "name" : "java.util.Objects"
          }, {
            "dereferencedParts" : [ ],
            "name" : "com.fasterxml.jackson.annotation.JsonCreator"
          }, {
            "dereferencedParts" : [ ],
            "name" : "com.fasterxml.jackson.annotation.JsonIgnore"
          }, {
            "dereferencedParts" : [ ],
            "name" : "com.fasterxml.jackson.annotation.JsonIgnoreProperties"
          }, {
            "dereferencedParts" : [ ],
            "name" : "com.fasterxml.jackson.annotation.JsonProperty"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.document.id.IdGenerator"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.document.id.RandomIdGenerator"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.model.Media"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.lang.Nullable"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.util.Assert"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.util.StringUtils"
          } ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/document/Document.java",
        "name" : "org.springframework.ai.document.Document"
      }, {
        "dereferencedParts" : [ ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/document/DocumentMetadata.java",
        "name" : "org.springframework.ai.document.DocumentMetadata"
      }, {
        "dereferencedParts" : [ {
          "name" : "EmbeddingModel",
          "comments" : "EmbeddingModel is a generic interface for embedding models.",
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ ],
          "constructors" : [ ],
          "extends" : [ "Model<EmbeddingRequest, EmbeddingResponse>" ],
          "implements" : [ ],
          "nestedClass" : null,
          "accessSpecifier" : "public",
          "records" : null,
          "imports" : [ {
            "dereferencedParts" : [ ],
            "name" : "java.util.ArrayList"
          }, {
            "dereferencedParts" : [ ],
            "name" : "java.util.List"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.document.Document"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.model.Model"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.util.Assert"
          } ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/embedding/EmbeddingModel.java",
        "name" : "org.springframework.ai.embedding.EmbeddingModel"
      }, {
        "dereferencedParts" : [ {
          "name" : "EmbeddingOptionsBuilder",
          "comments" : "Builder for {@link EmbeddingOptions}.",
          "annotations" : [ ],
          "methods" : [ {
            "name" : "builder",
            "arguments" : [ ],
            "accessModifier" : "public,static",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "returnType" : "EmbeddingOptionsBuilder",
            "comments" : null,
            "methodDefinition" : "public static EmbeddingOptionsBuilder builder() {\n    return new EmbeddingOptionsBuilder();\n}"
          } ],
          "fields" : [ {
            "name" : "embeddingOptions",
            "accessModifier" : "private,final",
            "value" : "new DefaultEmbeddingOptions()",
            "type" : "DefaultEmbeddingOptions",
            "comments" : null
          } ],
          "constructors" : [ {
            "name" : "EmbeddingOptionsBuilder",
            "arguments" : [ ],
            "accessModifier" : "private",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "private EmbeddingOptionsBuilder() {\n}"
          } ],
          "extends" : [ ],
          "implements" : [ ],
          "nestedClass" : [ {
            "name" : "DefaultEmbeddingOptions",
            "comments" : null,
            "annotations" : [ ],
            "methods" : [ {
              "name" : "getModel",
              "arguments" : [ ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ ],
              "annotations" : [ "Override" ],
              "returnType" : "String",
              "comments" : null,
              "methodDefinition" : "@Override\npublic String getModel() {\n    return this.model;\n}"
            }, {
              "name" : "setModel",
              "arguments" : [ "String model" ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ "model" ],
              "annotations" : [ ],
              "returnType" : "void",
              "comments" : null,
              "methodDefinition" : "public void setModel(String model) {\n    this.model = model;\n}"
            }, {
              "name" : "getDimensions",
              "arguments" : [ ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ ],
              "annotations" : [ "Override" ],
              "returnType" : "Integer",
              "comments" : null,
              "methodDefinition" : "@Override\npublic Integer getDimensions() {\n    return this.dimensions;\n}"
            }, {
              "name" : "setDimensions",
              "arguments" : [ "Integer dimensions" ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ "dimensions" ],
              "annotations" : [ ],
              "returnType" : "void",
              "comments" : null,
              "methodDefinition" : "public void setDimensions(Integer dimensions) {\n    this.dimensions = dimensions;\n}"
            } ],
            "fields" : [ {
              "name" : "model",
              "accessModifier" : "private",
              "value" : null,
              "type" : "String",
              "comments" : null
            }, {
              "name" : "dimensions",
              "accessModifier" : "private",
              "value" : null,
              "type" : "Integer",
              "comments" : null
            } ],
            "constructors" : [ ],
            "extends" : null,
            "implements" : null,
            "nestedClass" : null,
            "accessSpecifier" : "private , static",
            "records" : null
          } ],
          "accessSpecifier" : "public , final",
          "records" : null,
          "imports" : [ ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/embedding/EmbeddingOptionsBuilder.java",
        "name" : "org.springframework.ai.embedding.EmbeddingOptionsBuilder"
      }, {
        "dereferencedParts" : [ {
          "name" : "EmbeddingUtils",
          "comments" : null,
          "annotations" : [ ],
          "methods" : [ {
            "name" : "toList",
            "arguments" : [ "float[] floats" ],
            "accessModifier" : "public,static",
            "methodsCalled" : [ {
              "name" : "add",
              "arguments" : [ "value" ],
              "body" : ""
            } ],
            "usedEntities" : [ "floats", "output", "value" ],
            "annotations" : [ ],
            "returnType" : "List<Float>",
            "comments" : null,
            "methodDefinition" : "public static List<Float> toList(float[] floats) {\n    List<Float> output = new ArrayList<Float>();\n    for (float value : floats) {\n        output.add(value);\n    }\n    return output;\n}"
          } ],
          "fields" : [ {
            "name" : "EMPTY_FLOAT_ARRAY",
            "accessModifier" : "private,static,final",
            "value" : "new float[0]",
            "type" : "float[]",
            "comments" : null
          } ],
          "constructors" : [ {
            "name" : "EmbeddingUtils",
            "arguments" : [ ],
            "accessModifier" : "private",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "private EmbeddingUtils() {\n}"
          } ],
          "extends" : [ ],
          "implements" : [ ],
          "nestedClass" : null,
          "accessSpecifier" : "public , final",
          "records" : null,
          "imports" : [ {
            "dereferencedParts" : [ ],
            "name" : "java.util.ArrayList"
          }, {
            "dereferencedParts" : [ ],
            "name" : "java.util.List"
          } ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/model/EmbeddingUtils.java",
        "name" : "org.springframework.ai.model.EmbeddingUtils"
      }, {
        "dereferencedParts" : [ ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/observation/conventions/VectorStoreProvider.java",
        "name" : "org.springframework.ai.observation.conventions.VectorStoreProvider"
      }, {
        "dereferencedParts" : [ ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/observation/conventions/VectorStoreSimilarityMetric.java",
        "name" : "org.springframework.ai.observation.conventions.VectorStoreSimilarityMetric"
      }, {
        "dereferencedParts" : [ {
          "name" : "AbstractVectorStoreBuilder",
          "comments" : "Abstract base builder implementing common builder functionality for\n{@link VectorStore}. Provides default implementations for observation-related settings.",
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ {
            "name" : "embeddingModel",
            "accessModifier" : "protected,final",
            "value" : null,
            "type" : "EmbeddingModel",
            "comments" : null
          }, {
            "name" : "observationRegistry",
            "accessModifier" : "protected",
            "value" : "ObservationRegistry.NOOP",
            "type" : "ObservationRegistry",
            "comments" : null
          }, {
            "name" : "customObservationConvention",
            "accessModifier" : "protected",
            "value" : null,
            "type" : "VectorStoreObservationConvention",
            "comments" : null
          }, {
            "name" : "batchingStrategy",
            "accessModifier" : "protected",
            "value" : "new TokenCountBatchingStrategy()",
            "type" : "BatchingStrategy",
            "comments" : null
          } ],
          "constructors" : [ {
            "name" : "AbstractVectorStoreBuilder",
            "arguments" : [ "EmbeddingModel embeddingModel" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "notNull",
              "arguments" : [ "embeddingModel", "\"EmbeddingModel must be configured\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Assert", "embeddingModel" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public AbstractVectorStoreBuilder(EmbeddingModel embeddingModel) {\n    Assert.notNull(embeddingModel, \"EmbeddingModel must be configured\");\n    this.embeddingModel = embeddingModel;\n}"
          } ],
          "extends" : [ ],
          "implements" : [ "VectorStore.Builder<T>" ],
          "nestedClass" : null,
          "accessSpecifier" : "public , abstract",
          "records" : null,
          "imports" : [ {
            "dereferencedParts" : [ ],
            "name" : "io.micrometer.observation.ObservationRegistry"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.embedding.BatchingStrategy"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.embedding.EmbeddingModel"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.embedding.TokenCountBatchingStrategy"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.observation.VectorStoreObservationConvention"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.lang.Nullable"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.util.Assert"
          } ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/vectorstore/AbstractVectorStoreBuilder.java",
        "name" : "org.springframework.ai.vectorstore.AbstractVectorStoreBuilder"
      }, {
        "dereferencedParts" : [ {
          "name" : "SearchRequest",
          "comments" : "Similarity search request. Use the {@link SearchRequest#builder()} to create the\ninstance of a {@link SearchRequest}.",
          "annotations" : [ ],
          "methods" : [ {
            "name" : "getQuery",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "returnType" : "String",
            "comments" : null,
            "methodDefinition" : "public String getQuery() {\n    return this.query;\n}"
          }, {
            "name" : "getTopK",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "returnType" : "int",
            "comments" : null,
            "methodDefinition" : "public int getTopK() {\n    return this.topK;\n}"
          }, {
            "name" : "getSimilarityThreshold",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "returnType" : "double",
            "comments" : null,
            "methodDefinition" : "public double getSimilarityThreshold() {\n    return this.similarityThreshold;\n}"
          }, {
            "name" : "getFilterExpression",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ "Nullable" ],
            "returnType" : "Filter.Expression",
            "comments" : null,
            "methodDefinition" : "@Nullable\npublic Filter.Expression getFilterExpression() {\n    return this.filterExpression;\n}"
          }, {
            "name" : "hasFilterExpression",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "returnType" : "boolean",
            "comments" : null,
            "methodDefinition" : "public boolean hasFilterExpression() {\n    return this.filterExpression != null;\n}"
          }, {
            "name" : "builder",
            "arguments" : [ ],
            "accessModifier" : "public,static",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : "Builder for creating the SearchRequest instance.",
            "methodDefinition" : "public static Builder builder() {\n    return new Builder();\n}"
          } ],
          "fields" : [ {
            "name" : "SIMILARITY_THRESHOLD_ACCEPT_ALL",
            "accessModifier" : "public,static,final",
            "value" : "0.0",
            "type" : "double",
            "comments" : "Similarity threshold that accepts all search scores. A threshold value of 0.0 means\nany similarity is accepted or disable the similarity threshold filtering. A\nthreshold value of 1.0 means an exact match is required."
          }, {
            "name" : "DEFAULT_TOP_K",
            "accessModifier" : "public,static,final",
            "value" : "4",
            "type" : "int",
            "comments" : "Default value for the top 'k' similar results to return."
          }, {
            "name" : "query",
            "accessModifier" : "private",
            "value" : "\"\"",
            "type" : "String",
            "comments" : "Default value is empty string."
          }, {
            "name" : "topK",
            "accessModifier" : "private",
            "value" : "DEFAULT_TOP_K",
            "type" : "int",
            "comments" : null
          }, {
            "name" : "similarityThreshold",
            "accessModifier" : "private",
            "value" : "SIMILARITY_THRESHOLD_ACCEPT_ALL",
            "type" : "double",
            "comments" : null
          }, {
            "name" : "filterExpression",
            "accessModifier" : "private",
            "value" : null,
            "type" : "Filter.Expression",
            "comments" : null
          } ],
          "constructors" : [ {
            "name" : "SearchRequest",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public SearchRequest() {\n}"
          }, {
            "name" : "SearchRequest",
            "arguments" : [ "SearchRequest original" ],
            "accessModifier" : "protected",
            "methodsCalled" : [ ],
            "usedEntities" : [ "original" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "protected SearchRequest(SearchRequest original) {\n    this.query = original.query;\n    this.topK = original.topK;\n    this.similarityThreshold = original.similarityThreshold;\n    this.filterExpression = original.filterExpression;\n}"
          } ],
          "extends" : [ ],
          "implements" : [ ],
          "nestedClass" : [ {
            "name" : "Builder",
            "comments" : "SearchRequest Builder.",
            "annotations" : [ ],
            "methods" : [ {
              "name" : "query",
              "arguments" : [ "String query" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "notNull",
                "arguments" : [ "query", "\"Query can not be null.\"" ],
                "body" : ""
              } ],
              "usedEntities" : [ "Assert", "query" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : "",
              "methodDefinition" : "public Builder query(String query) {\n    Assert.notNull(query, \"Query can not be null.\");\n    this.searchRequest.query = query;\n    return this;\n}"
            }, {
              "name" : "topK",
              "arguments" : [ "int topK" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "isTrue",
                "arguments" : [ "topK >= 0", "\"TopK should be positive.\"" ],
                "body" : ""
              } ],
              "usedEntities" : [ "Assert", "topK" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : "",
              "methodDefinition" : "public Builder topK(int topK) {\n    Assert.isTrue(topK >= 0, \"TopK should be positive.\");\n    this.searchRequest.topK = topK;\n    return this;\n}"
            }, {
              "name" : "similarityThreshold",
              "arguments" : [ "double threshold" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "isTrue",
                "arguments" : [ "threshold >= 0 && threshold <= 1", "\"Similarity threshold must be in [0,1] range.\"" ],
                "body" : ""
              } ],
              "usedEntities" : [ "Assert", "threshold" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : "Similarity threshold score to filter the search response by. Only documents\nwith similarity score equal or greater than the 'threshold' will be returned.\nNote that this is a post-processing step performed on the client not the server\nside. A threshold value of 0.0 means any similarity is accepted or disable the\nsimilarity threshold filtering. A threshold value of 1.0 means an exact match\nis required.",
              "methodDefinition" : "public Builder similarityThreshold(double threshold) {\n    Assert.isTrue(threshold >= 0 && threshold <= 1, \"Similarity threshold must be in [0,1] range.\");\n    this.searchRequest.similarityThreshold = threshold;\n    return this;\n}"
            }, {
              "name" : "similarityThresholdAll",
              "arguments" : [ ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : "Sets disables the similarity threshold by setting it to 0.0 - all results are\naccepted.",
              "methodDefinition" : "public Builder similarityThresholdAll() {\n    this.searchRequest.similarityThreshold = 0.0;\n    return this;\n}"
            }, {
              "name" : "filterExpression",
              "arguments" : [ "@Nullable Filter.Expression expression" ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ "expression" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : "Retrieves documents by query embedding similarity and matching the filters.\nValue of 'null' means that no metadata filters will be applied to the search.\n\nFor example if the {@link Document#getMetadata()} schema is:\n\n<pre>{@code\n&#123;\n\"country\": <Text>,\n\"city\": <Text>,\n\"year\": <Number>,\n\"price\": <Decimal>,\n\"isActive\": <Boolean>\n&#125;\n}</pre>\n\nyou can constrain the search result to only UK countries with isActive=true and\nyear equal or greater 2020. You can build this such metadata filter\nprogrammatically like this:\n\n<pre>{@code\nvar exp = new Filter.Expression(AND,\n\t\tnew Expression(EQ, new Key(\"country\"), new Value(\"UK\")),\n\t\tnew Expression(AND,\n\t\t\t\tnew Expression(GTE, new Key(\"year\"), new Value(2020)),\n\t\t\t\tnew Expression(EQ, new Key(\"isActive\"), new Value(true))));\n}</pre>\n\nThe {@link Filter.Expression} is portable across all vector stores.<br/>\n\n\nThe {@link FilterExpressionBuilder} is a DSL creating expressions\nprogrammatically:\n\n<pre>{@code\nvar b = new FilterExpressionBuilder();\nvar exp = b.and(\n\t\tb.eq(\"country\", \"UK\"),\n\t\tb.and(\n\t\t\tb.gte(\"year\", 2020),\n\t\t\tb.eq(\"isActive\", true)));\n}</pre>\n\nThe {@link FilterExpressionTextParser} converts textual, SQL like filter\nexpression language into {@link Filter.Expression}:\n\n<pre>{@code\nvar parser = new FilterExpressionTextParser();\nvar exp = parser.parse(\"country == 'UK' && isActive == true && year >=2020\");\n}</pre>",
              "methodDefinition" : "public Builder filterExpression(@Nullable Filter.Expression expression) {\n    this.searchRequest.filterExpression = expression;\n    return this;\n}"
            }, {
              "name" : "filterExpression",
              "arguments" : [ "@Nullable String textExpression" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "parse",
                "arguments" : [ "textExpression" ],
                "body" : ""
              } ],
              "usedEntities" : [ "textExpression" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : "Document metadata filter expression. For example if your\n{@link Document#getMetadata()} has a schema like:\n\n<pre>{@code\n&#123;\n\"country\": <Text>,\n\"city\": <Text>,\n\"year\": <Number>,\n\"price\": <Decimal>,\n\"isActive\": <Boolean>\n&#125;\n}</pre>\n\nthen you can constrain the search result with metadata filter expressions like:\n\n<pre>{@code\ncountry == 'UK' && year >= 2020 && isActive == true\nOr\ncountry == 'BG' && (city NOT IN ['Sofia', 'Plovdiv'] || price < 134.34)\n}</pre>\n\nThis ensures that the response contains only embeddings that match the\nspecified filer criteria. <br/>\n\nThe declarative, SQL like, filter syntax is portable across all vector stores\nsupporting the filter search feature.<br/>\n\nThe {@link FilterExpressionTextParser} is used to convert the text filter\nexpression into {@link Filter.Expression}.",
              "methodDefinition" : "public Builder filterExpression(@Nullable String textExpression) {\n    this.searchRequest.filterExpression = (textExpression != null) ? new FilterExpressionTextParser().parse(textExpression) : null;\n    return this;\n}"
            }, {
              "name" : "build",
              "arguments" : [ ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ ],
              "annotations" : [ ],
              "returnType" : "SearchRequest",
              "comments" : null,
              "methodDefinition" : "public SearchRequest build() {\n    return this.searchRequest;\n}"
            } ],
            "fields" : [ {
              "name" : "searchRequest",
              "accessModifier" : "private,final",
              "value" : "new SearchRequest()",
              "type" : "SearchRequest",
              "comments" : null
            } ],
            "constructors" : [ ],
            "extends" : null,
            "implements" : null,
            "nestedClass" : null,
            "accessSpecifier" : "public , static",
            "records" : null
          } ],
          "accessSpecifier" : "public",
          "records" : null,
          "imports" : [ {
            "dereferencedParts" : [ ],
            "name" : "java.util.Objects"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.document.Document"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.filter.Filter"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.filter.FilterExpressionBuilder"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.filter.FilterExpressionTextParser"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.lang.Nullable"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.util.Assert"
          } ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/vectorstore/SearchRequest.java",
        "name" : "org.springframework.ai.vectorstore.SearchRequest"
      }, {
        "dereferencedParts" : [ {
          "name" : "VectorStore",
          "comments" : "The {@code VectorStore} interface defines the operations for managing and querying\ndocuments in a vector database. It extends {@link DocumentWriter} to support document\nwriting operations. Vector databases are specialized for AI applications, performing\nsimilarity searches based on vector representations of data rather than exact matches.\nThis interface allows for adding, deleting, and searching documents based on their\nsimilarity to a given query.",
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ ],
          "constructors" : [ ],
          "extends" : [ "DocumentWriter" ],
          "implements" : [ ],
          "nestedClass" : [ {
            "name" : "Builder",
            "comments" : "Builder interface for creating VectorStore instances. Implements a fluent builder\npattern for configuring observation-related settings.",
            "annotations" : [ ],
            "methods" : [ {
              "name" : "observationRegistry",
              "arguments" : [ "ObservationRegistry observationRegistry" ],
              "accessModifier" : "",
              "methodsCalled" : [ ],
              "usedEntities" : [ ],
              "annotations" : [ ],
              "returnType" : "T",
              "comments" : "Sets the registry for collecting observations and metrics. Defaults to\n{@link ObservationRegistry#NOOP} if not specified.",
              "methodDefinition" : "T observationRegistry(ObservationRegistry observationRegistry);"
            }, {
              "name" : "customObservationConvention",
              "arguments" : [ "VectorStoreObservationConvention convention" ],
              "accessModifier" : "",
              "methodsCalled" : [ ],
              "usedEntities" : [ ],
              "annotations" : [ ],
              "returnType" : "T",
              "comments" : "Sets a custom convention for creating observations. If not specified,\n{@link DefaultVectorStoreObservationConvention} will be used.",
              "methodDefinition" : "T customObservationConvention(VectorStoreObservationConvention convention);"
            }, {
              "name" : "batchingStrategy",
              "arguments" : [ "BatchingStrategy batchingStrategy" ],
              "accessModifier" : "",
              "methodsCalled" : [ ],
              "usedEntities" : [ ],
              "annotations" : [ ],
              "returnType" : "T",
              "comments" : "Sets the batching strategy.",
              "methodDefinition" : "T batchingStrategy(BatchingStrategy batchingStrategy);"
            }, {
              "name" : "build",
              "arguments" : [ ],
              "accessModifier" : "",
              "methodsCalled" : [ ],
              "usedEntities" : [ ],
              "annotations" : [ ],
              "returnType" : "VectorStore",
              "comments" : "Builds and returns a new VectorStore instance with the configured settings.",
              "methodDefinition" : "VectorStore build();"
            } ],
            "fields" : [ ],
            "constructors" : [ ],
            "extends" : null,
            "implements" : null,
            "nestedClass" : null,
            "accessSpecifier" : "",
            "records" : null
          } ],
          "accessSpecifier" : "public",
          "records" : null,
          "imports" : [ {
            "dereferencedParts" : [ ],
            "name" : "java.util.List"
          }, {
            "dereferencedParts" : [ ],
            "name" : "java.util.Optional"
          }, {
            "dereferencedParts" : [ ],
            "name" : "io.micrometer.observation.ObservationRegistry"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.document.Document"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.document.DocumentWriter"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.embedding.BatchingStrategy"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.filter.Filter"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.observation.DefaultVectorStoreObservationConvention"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.observation.VectorStoreObservationConvention"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.lang.Nullable"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.util.Assert"
          } ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/vectorstore/VectorStore.java",
        "name" : "org.springframework.ai.vectorstore.VectorStore"
      }, {
        "dereferencedParts" : [ {
          "name" : "Filter",
          "comments" : "Portable runtime generative for metadata filter expressions. This generic generative is\nused to define store agnostic filter expressions than later can be converted into\nvector-store specific, native, expressions.\n\nThe expression generative supports constant comparison\n{@code (e.g. ==, !=, <, <=, >, >=) }, IN/NON-IN checks and AND and OR to compose\nmultiple expressions.\n\nFor example:\n\n<pre>{@code\n// 1: country == \"BG\"\nnew Expression(EQ, new Key(\"country\"), new Value(\"BG\"));\n\n// 2: genre == \"drama\" AND year >= 2020\nnew Expression(AND, new Expression(EQ, new Key(\"genre\"), new Value(\"drama\")),\n\t\tnew Expression(GTE, new Key(\"year\"), new Value(2020)));\n\n// 3: genre in [\"comedy\", \"documentary\", \"drama\"]\nnew Expression(IN, new Key(\"genre\"), new Value(List.of(\"comedy\", \"documentary\", \"drama\")));\n\n// 4: year >= 2020 OR country == \"BG\" AND city != \"Sofia\"\nnew Expression(OR, new Expression(GTE, new Key(\"year\"), new Value(2020)),\n\t\tnew Expression(AND, new Expression(EQ, new Key(\"country\"), new Value(\"BG\")),\n\t\t\t\tnew Expression(NE, new Key(\"city\"), new Value(\"Sofia\"))));\n\n// 5: (year >= 2020 OR country == \"BG\") AND city NIN [\"Sofia\", \"Plovdiv\"]\nnew Expression(AND,\n\t\tnew Group(new Expression(OR, new Expression(EQ, new Key(\"country\"), new Value(\"BG\")),\n\t\t\t\tnew Expression(GTE, new Key(\"year\"), new Value(2020)))),\n\t\tnew Expression(NIN, new Key(\"city\"), new Value(List.of(\"Sofia\", \"Varna\"))));\n\n// 6: isOpen == true AND year >= 2020 AND country IN [\"BG\", \"NL\", \"US\"]\nnew Expression(AND, new Expression(EQ, new Key(\"isOpen\"), new Value(true)),\n\t\tnew Expression(AND, new Expression(GTE, new Key(\"year\"), new Value(2020)),\n\t\t\t\tnew Expression(IN, new Key(\"country\"), new Value(List.of(\"BG\", \"NL\", \"US\")))));\n\n}</pre>\n\n\nUsually you will not create expression manually but use either the\n{@link FilterExpressionBuilder} DSL or the {@link FilterExpressionTextParser} for\nparsing generic text expressions.",
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ ],
          "constructors" : [ ],
          "extends" : [ ],
          "implements" : [ ],
          "nestedClass" : [ {
            "name" : "Operand",
            "comments" : "Mark interface representing the supported expression types: {@link Key},\n{@link Value}, {@link Expression} and {@link Group}.",
            "annotations" : [ ],
            "methods" : [ ],
            "fields" : [ ],
            "constructors" : [ ],
            "extends" : null,
            "implements" : null,
            "nestedClass" : null,
            "accessSpecifier" : "public",
            "records" : null
          } ],
          "accessSpecifier" : "public",
          "records" : null,
          "imports" : [ ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/vectorstore/filter/Filter.java",
        "name" : "org.springframework.ai.vectorstore.filter.Filter"
      }, {
        "dereferencedParts" : [ {
          "name" : "FilterExpressionConverter",
          "comments" : "Converters a generic, portable {@link Filter.Expression} into a\n{@link org.springframework.ai.vectorstore.VectorStore} specific expression language\nformat.",
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ ],
          "constructors" : [ ],
          "extends" : [ ],
          "implements" : [ ],
          "nestedClass" : null,
          "accessSpecifier" : "public",
          "records" : null,
          "imports" : [ ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/vectorstore/filter/FilterExpressionConverter.java",
        "name" : "org.springframework.ai.vectorstore.filter.FilterExpressionConverter"
      }, {
        "dereferencedParts" : [ {
          "name" : "AbstractObservationVectorStore",
          "comments" : "Abstract base class for {@link VectorStore} implementations that provides observation\ncapabilities.",
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ {
            "name" : "DEFAULT_OBSERVATION_CONVENTION",
            "accessModifier" : "private,static,final",
            "value" : "new DefaultVectorStoreObservationConvention()",
            "type" : "VectorStoreObservationConvention",
            "comments" : null
          }, {
            "name" : "observationRegistry",
            "accessModifier" : "private,final",
            "value" : null,
            "type" : "ObservationRegistry",
            "comments" : null
          }, {
            "name" : "customObservationConvention",
            "accessModifier" : "private,final",
            "value" : null,
            "type" : "VectorStoreObservationConvention",
            "comments" : null
          }, {
            "name" : "embeddingModel",
            "accessModifier" : "protected,final",
            "value" : null,
            "type" : "EmbeddingModel",
            "comments" : null
          }, {
            "name" : "batchingStrategy",
            "accessModifier" : "protected,final",
            "value" : null,
            "type" : "BatchingStrategy",
            "comments" : null
          } ],
          "constructors" : [ {
            "name" : "AbstractObservationVectorStore",
            "arguments" : [ "EmbeddingModel embeddingModel", "ObservationRegistry observationRegistry", "@Nullable VectorStoreObservationConvention customObservationConvention", "BatchingStrategy batchingStrategy" ],
            "accessModifier" : "private",
            "methodsCalled" : [ ],
            "usedEntities" : [ "embeddingModel", "observationRegistry", "customObservationConvention", "batchingStrategy" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "private AbstractObservationVectorStore(EmbeddingModel embeddingModel, ObservationRegistry observationRegistry, @Nullable VectorStoreObservationConvention customObservationConvention, BatchingStrategy batchingStrategy) {\n    this.embeddingModel = embeddingModel;\n    this.observationRegistry = observationRegistry;\n    this.customObservationConvention = customObservationConvention;\n    this.batchingStrategy = batchingStrategy;\n}"
          }, {
            "name" : "AbstractObservationVectorStore",
            "arguments" : [ "AbstractVectorStoreBuilder<?> builder" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "getEmbeddingModel",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getObservationRegistry",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getCustomObservationConvention",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "getBatchingStrategy",
              "arguments" : [ ],
              "body" : ""
            } ],
            "usedEntities" : [ "builder" ],
            "annotations" : [ ],
            "comments" : "Creates a new AbstractObservationVectorStore instance with the specified builder\nsettings. Initializes observation-related components and the embedding model.",
            "methodDefinition" : "public AbstractObservationVectorStore(AbstractVectorStoreBuilder<?> builder) {\n    this(builder.getEmbeddingModel(), builder.getObservationRegistry(), builder.getCustomObservationConvention(), builder.getBatchingStrategy());\n}"
          } ],
          "extends" : [ ],
          "implements" : [ "VectorStore" ],
          "nestedClass" : null,
          "accessSpecifier" : "public , abstract",
          "records" : null,
          "imports" : [ {
            "dereferencedParts" : [ ],
            "name" : "java.util.List"
          }, {
            "dereferencedParts" : [ ],
            "name" : "io.micrometer.observation.ObservationRegistry"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.document.Document"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.embedding.BatchingStrategy"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.embedding.EmbeddingModel"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.AbstractVectorStoreBuilder"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.SearchRequest"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.VectorStore"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.filter.Filter"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.lang.Nullable"
          } ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/vectorstore/observation/AbstractObservationVectorStore.java",
        "name" : "org.springframework.ai.vectorstore.observation.AbstractObservationVectorStore"
      }, {
        "dereferencedParts" : [ {
          "name" : "VectorStoreObservationContext",
          "comments" : "Context used to store metadata for vector store operations.",
          "annotations" : [ ],
          "methods" : [ {
            "name" : "builder",
            "arguments" : [ "String databaseSystem", "String operationName" ],
            "accessModifier" : "public,static",
            "methodsCalled" : [ ],
            "usedEntities" : [ "databaseSystem", "operationName" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public static Builder builder(String databaseSystem, String operationName) {\n    return new Builder(databaseSystem, operationName);\n}"
          }, {
            "name" : "builder",
            "arguments" : [ "String databaseSystem", "Operation operation" ],
            "accessModifier" : "public,static",
            "methodsCalled" : [ {
              "name" : "builder",
              "arguments" : [ "databaseSystem", "operation.value" ],
              "body" : "public static Builder builder(String databaseSystem, String operationName) {\n    return new Builder(databaseSystem, operationName);\n}"
            } ],
            "usedEntities" : [ "databaseSystem", "operation" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public static Builder builder(String databaseSystem, Operation operation) {\n    return builder(databaseSystem, operation.value);\n}"
          } ],
          "fields" : [ {
            "name" : "databaseSystem",
            "accessModifier" : "private,final",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "operationName",
            "accessModifier" : "private,final",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "collectionName",
            "accessModifier" : "private",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "dimensions",
            "accessModifier" : "private",
            "value" : null,
            "type" : "Integer",
            "comments" : null
          }, {
            "name" : "fieldName",
            "accessModifier" : "private",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "namespace",
            "accessModifier" : "private",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "similarityMetric",
            "accessModifier" : "private",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "queryRequest",
            "accessModifier" : "private",
            "value" : null,
            "type" : "SearchRequest",
            "comments" : null
          }, {
            "name" : "queryResponse",
            "accessModifier" : "private",
            "value" : null,
            "type" : "List<Document>",
            "comments" : null
          } ],
          "constructors" : [ {
            "name" : "VectorStoreObservationContext",
            "arguments" : [ "String databaseSystem", "String operationName" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "hasText",
              "arguments" : [ "databaseSystem", "\"databaseSystem cannot be null or empty\"" ],
              "body" : ""
            }, {
              "name" : "hasText",
              "arguments" : [ "operationName", "\"operationName cannot be null or empty\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Assert", "databaseSystem", "operationName" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "public VectorStoreObservationContext(String databaseSystem, String operationName) {\n    Assert.hasText(databaseSystem, \"databaseSystem cannot be null or empty\");\n    Assert.hasText(operationName, \"operationName cannot be null or empty\");\n    this.databaseSystem = databaseSystem;\n    this.operationName = operationName;\n}"
          } ],
          "extends" : [ "Observation.Context" ],
          "implements" : [ ],
          "nestedClass" : [ {
            "name" : "Builder",
            "comments" : null,
            "annotations" : [ ],
            "methods" : [ {
              "name" : "collectionName",
              "arguments" : [ "String collectionName" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "setCollectionName",
                "arguments" : [ "collectionName" ],
                "body" : "public void setCollectionName(@Nullable String collectionName) {\n    this.collectionName = collectionName;\n}"
              } ],
              "usedEntities" : [ "collectionName" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder collectionName(String collectionName) {\n    this.context.setCollectionName(collectionName);\n    return this;\n}"
            }, {
              "name" : "dimensions",
              "arguments" : [ "Integer dimensions" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "setDimensions",
                "arguments" : [ "dimensions" ],
                "body" : "public void setDimensions(@Nullable Integer dimensions) {\n    this.dimensions = dimensions;\n}"
              } ],
              "usedEntities" : [ "dimensions" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder dimensions(Integer dimensions) {\n    this.context.setDimensions(dimensions);\n    return this;\n}"
            }, {
              "name" : "fieldName",
              "arguments" : [ "@Nullable String fieldName" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "setFieldName",
                "arguments" : [ "fieldName" ],
                "body" : "public void setFieldName(@Nullable String fieldName) {\n    this.fieldName = fieldName;\n}"
              } ],
              "usedEntities" : [ "fieldName" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder fieldName(@Nullable String fieldName) {\n    this.context.setFieldName(fieldName);\n    return this;\n}"
            }, {
              "name" : "namespace",
              "arguments" : [ "String namespace" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "setNamespace",
                "arguments" : [ "namespace" ],
                "body" : "public void setNamespace(@Nullable String namespace) {\n    this.namespace = namespace;\n}"
              } ],
              "usedEntities" : [ "namespace" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder namespace(String namespace) {\n    this.context.setNamespace(namespace);\n    return this;\n}"
            }, {
              "name" : "queryRequest",
              "arguments" : [ "SearchRequest request" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "setQueryRequest",
                "arguments" : [ "request" ],
                "body" : "public void setQueryRequest(@Nullable SearchRequest queryRequest) {\n    this.queryRequest = queryRequest;\n}"
              } ],
              "usedEntities" : [ "request" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder queryRequest(SearchRequest request) {\n    this.context.setQueryRequest(request);\n    return this;\n}"
            }, {
              "name" : "queryResponse",
              "arguments" : [ "List<Document> documents" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "setQueryResponse",
                "arguments" : [ "documents" ],
                "body" : "public void setQueryResponse(@Nullable List<Document> queryResponse) {\n    this.queryResponse = queryResponse;\n}"
              } ],
              "usedEntities" : [ "documents" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder queryResponse(List<Document> documents) {\n    this.context.setQueryResponse(documents);\n    return this;\n}"
            }, {
              "name" : "similarityMetric",
              "arguments" : [ "String similarityMetric" ],
              "accessModifier" : "public",
              "methodsCalled" : [ {
                "name" : "setSimilarityMetric",
                "arguments" : [ "similarityMetric" ],
                "body" : "public void setSimilarityMetric(@Nullable String similarityMetric) {\n    this.similarityMetric = similarityMetric;\n}"
              } ],
              "usedEntities" : [ "similarityMetric" ],
              "annotations" : [ ],
              "returnType" : "Builder",
              "comments" : null,
              "methodDefinition" : "public Builder similarityMetric(String similarityMetric) {\n    this.context.setSimilarityMetric(similarityMetric);\n    return this;\n}"
            }, {
              "name" : "build",
              "arguments" : [ ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ ],
              "annotations" : [ ],
              "returnType" : "VectorStoreObservationContext",
              "comments" : null,
              "methodDefinition" : "public VectorStoreObservationContext build() {\n    return this.context;\n}"
            } ],
            "fields" : [ {
              "name" : "context",
              "accessModifier" : "private,final",
              "value" : null,
              "type" : "VectorStoreObservationContext",
              "comments" : null
            } ],
            "constructors" : [ {
              "name" : "Builder",
              "arguments" : [ "String databaseSystem", "String operationName" ],
              "accessModifier" : "public",
              "methodsCalled" : [ ],
              "usedEntities" : [ "databaseSystem", "operationName" ],
              "annotations" : [ ],
              "comments" : null,
              "methodDefinition" : "public Builder(String databaseSystem, String operationName) {\n    this.context = new VectorStoreObservationContext(databaseSystem, operationName);\n}"
            } ],
            "extends" : null,
            "implements" : null,
            "nestedClass" : null,
            "accessSpecifier" : "public , static",
            "records" : null
          } ],
          "accessSpecifier" : "public",
          "records" : null,
          "imports" : [ {
            "dereferencedParts" : [ ],
            "name" : "java.util.List"
          }, {
            "dereferencedParts" : [ ],
            "name" : "io.micrometer.observation.Observation"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.document.Document"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.SearchRequest"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.lang.Nullable"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.util.Assert"
          } ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/vectorstore/observation/VectorStoreObservationContext.java",
        "name" : "org.springframework.ai.vectorstore.observation.VectorStoreObservationContext"
      }, {
        "dereferencedParts" : [ ],
        "name" : "org.springframework.util.Assert"
      } ],
      "classes" : [ {
        "name" : "CassandraVectorStore",
        "comments" : "The CassandraVectorStore is for managing and querying vector data in an Apache\nCassandra db. It offers functionalities like adding, deleting, and performing\nsimilarity searches on documents.\n\nThe store utilizes CQL to index and search vector data. It allows for custom metadata\nfields in the documents to be stored alongside the vector and content data.\n\nThis class requires a CassandraVectorStore#CassandraBuilder configuration object for\ninitialization, which includes settings like connection details, index name, column\nnames, etc. It also requires an EmbeddingModel to convert documents into embeddings\nbefore storing them.\n\nA schema matching the configuration is automatically created if it doesn't exist.\nMissing columns and indexes in existing tables will also be automatically created.\nDisable this with the CassandraBuilder#disallowSchemaChanges().\n\n<p>\nBasic usage example:\n</p>\n<pre>{@code\nCassandraVectorStore vectorStore = CassandraVectorStore.builder(embeddingModel)\n    .session(cqlSession)\n    .keyspace(\"my_keyspace\")\n    .table(\"my_vectors\")\n    .build();\n\n// Add documents\nvectorStore.add(List.of(\n    new Document(\"1\", \"content1\", Map.of(\"key1\", \"value1\")),\n    new Document(\"2\", \"content2\", Map.of(\"key2\", \"value2\"))\n));\n\n// Search with filters\nList<Document> results = vectorStore.similaritySearch(\n    SearchRequest.query(\"search text\")\n        .withTopK(5)\n        .withSimilarityThreshold(0.7)\n        .withFilterExpression(\"metadata.key1 == 'value1'\")\n);\n}</pre>\n\n<p>\nAdvanced configuration example:\n</p>\n<pre>{@code\nCassandraVectorStore vectorStore = CassandraVectorStore.builder(embeddingModel)\n    .session(cqlSession)\n    .keyspace(\"my_keyspace\")\n    .table(\"my_vectors\")\n    .partitionKeys(List.of(new SchemaColumn(\"id\", DataTypes.TEXT)))\n    .clusteringKeys(List.of(new SchemaColumn(\"timestamp\", DataTypes.TIMESTAMP)))\n    .addMetadataColumns(\n        new SchemaColumn(\"category\", DataTypes.TEXT, SchemaColumnTags.INDEXED),\n        new SchemaColumn(\"score\", DataTypes.DOUBLE)\n    )\n    .contentColumnName(\"text\")\n    .embeddingColumnName(\"vector\")\n    .fixedThreadPoolExecutorSize(32)\n    .disallowSchemaChanges(false)\n    .batchingStrategy(new TokenCountBatchingStrategy())\n    .build();\n}</pre>\n\nThis class is designed to work with brand new tables that it creates for you, or on top\nof existing Cassandra tables. The latter is appropriate when wanting to keep data in\nplace, creating embeddings next to it, and performing vector similarity searches\nin-situ.\n\nInstances of this class are not dynamic against server-side schema changes. If you\nchange the schema server-side you need a new CassandraVectorStore instance.\n\nWhen adding documents with the method {@link #add(List<Document>)} it first calls\nembeddingModel to create the embeddings. This is slow. Configure\n{@link Builder#fixedThreadPoolExecutorSize(int)} accordingly to improve performance so\nembeddings are created and the documents are added concurrently. The default\nconcurrency is 16 ({@link Builder#DEFAULT_ADD_CONCURRENCY}). Remote transformers\nprobably want higher concurrency, and local transformers may need lower concurrency.\nThis concurrency limit does not need to be higher than the max parallel calls made to\nthe {@link #add(List<Document>)} method multiplied by the list size. This setting can\nalso serve as a protecting throttle against your embedding model.",
        "annotations" : [ ],
        "methods" : [ {
          "name" : "builder",
          "arguments" : [ "EmbeddingModel embeddingModel" ],
          "accessModifier" : "public,static",
          "methodsCalled" : [ ],
          "usedEntities" : [ "embeddingModel" ],
          "annotations" : [ ],
          "returnType" : "Builder",
          "comments" : null,
          "methodDefinition" : "public static Builder builder(EmbeddingModel embeddingModel) {\n    return new Builder(embeddingModel);\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : true,
          "test_functions" : {
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreObservationIT.java" : {
              "observationVectorStoreAddAndQueryOperations" : {
                "definition" : "@Test\nvoid observationVectorStoreAddAndQueryOperations() {\n    this.contextRunner.run(context -> {\n        VectorStore vectorStore = context.getBean(VectorStore.class);\n        TestObservationRegistry observationRegistry = context.getBean(TestObservationRegistry.class);\n        vectorStore.add(this.documents);\n        TestObservationRegistryAssert.assertThat(observationRegistry).doesNotHaveAnyRemainingCurrentObservation().hasObservationWithNameEqualTo(DefaultVectorStoreObservationConvention.DEFAULT_NAME).that().hasContextualNameEqualTo(\"%s add\".formatted(VectorStoreProvider.CASSANDRA.value())).hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_OPERATION_NAME.asString(), \"add\").hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_SYSTEM.asString(), VectorStoreProvider.CASSANDRA.value()).hasLowCardinalityKeyValue(LowCardinalityKeyNames.SPRING_AI_KIND.asString(), SpringAiKind.VECTOR_STORE.value()).doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_QUERY_CONTENT.asString()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_DIMENSION_COUNT.asString(), \"384\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_COLLECTION_NAME.asString(), CassandraVectorStore.DEFAULT_TABLE_NAME).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_NAMESPACE.asString(), \"test_springframework\").doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_FIELD_NAME.asString()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_SEARCH_SIMILARITY_METRIC.asString(), VectorStoreSimilarityMetric.COSINE.value()).doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_QUERY_TOP_K.asString()).doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_QUERY_SIMILARITY_THRESHOLD.asString()).hasBeenStarted().hasBeenStopped();\n        observationRegistry.clear();\n        List<Document> results = vectorStore.similaritySearch(SearchRequest.builder().query(\"What is Great Depression\").topK(1).build());\n        assertThat(results).isNotEmpty();\n        TestObservationRegistryAssert.assertThat(observationRegistry).doesNotHaveAnyRemainingCurrentObservation().hasObservationWithNameEqualTo(DefaultVectorStoreObservationConvention.DEFAULT_NAME).that().hasContextualNameEqualTo(\"%s query\".formatted(VectorStoreProvider.CASSANDRA.value())).hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_OPERATION_NAME.asString(), \"query\").hasLowCardinalityKeyValue(LowCardinalityKeyNames.DB_SYSTEM.asString(), VectorStoreProvider.CASSANDRA.value()).hasLowCardinalityKeyValue(LowCardinalityKeyNames.SPRING_AI_KIND.asString(), SpringAiKind.VECTOR_STORE.value()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_QUERY_CONTENT.asString(), \"What is Great Depression\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_DIMENSION_COUNT.asString(), \"384\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_COLLECTION_NAME.asString(), CassandraVectorStore.DEFAULT_TABLE_NAME).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_NAMESPACE.asString(), \"test_springframework\").doesNotHaveHighCardinalityKeyValueWithKey(HighCardinalityKeyNames.DB_VECTOR_FIELD_NAME.asString()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_SEARCH_SIMILARITY_METRIC.asString(), VectorStoreSimilarityMetric.COSINE.value()).hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_QUERY_TOP_K.asString(), \"1\").hasHighCardinalityKeyValue(HighCardinalityKeyNames.DB_VECTOR_QUERY_SIMILARITY_THRESHOLD.asString(), \"0.0\").hasBeenStarted().hasBeenStopped();\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/WikiVectorStoreExample.java" : {
              "ensureBeanGetsCreated" : {
                "definition" : "@Test\nvoid ensureBeanGetsCreated() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore store = context.getBean(CassandraVectorStore.class);\n        Assertions.assertNotNull(store);\n        store.checkSchemaValid();\n        store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n    });\n}"
              },
              "search" : {
                "definition" : "@Test\nvoid search() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore store = context.getBean(CassandraVectorStore.class);\n        Assertions.assertNotNull(store);\n        store.checkSchemaValid();\n        var results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n        assertThat(results).hasSize(1);\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreIT.java" : {
              "storeBuilder" : {
                "definition" : "private static CassandraVectorStore.Builder storeBuilder(CqlSession cqlSession, EmbeddingModel embeddingModel) {\n    return CassandraVectorStore.builder(embeddingModel).session(cqlSession).keyspace(\"test_\" + CassandraVectorStore.DEFAULT_KEYSPACE_NAME);\n}"
              },
              "addAndSearch" : {
                "definition" : "@Test\nvoid addAndSearch() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"meta1\", DataTypes.TEXT), new SchemaColumn(\"meta2\", DataTypes.TEXT))) {\n            List<Document> documents = documents();\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents().get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Spring AI provides abstractions that serve as the foundation for developing AI applications.\");\n            assertThat(resultDoc.getMetadata()).hasSize(2);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"meta1\", DocumentMetadata.DISTANCE.value());\n            \n            store.delete(documents().stream().map(doc -> doc.getId()).toList());\n            results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).isEmpty();\n        }\n    });\n}"
              },
              "addAndSearchReturnEmbeddings" : {
                "definition" : "@Test\nvoid addAndSearchReturnEmbeddings() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore.Builder builder = storeBuilder(context.getBean(CqlSession.class), context.getBean(EmbeddingModel.class)).returnEmbeddings(true);\n        try (CassandraVectorStore store = createTestStore(context, builder)) {\n            List<Document> documents = documents();\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents().get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Spring AI provides abstractions that serve as the foundation for developing AI applications.\");\n            assertThat(resultDoc.getMetadata()).hasSize(1);\n            assertThat(resultDoc.getMetadata()).containsKey(DocumentMetadata.DISTANCE.value());\n            \n            store.delete(documents().stream().map(doc -> doc.getId()).toList());\n            results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).isEmpty();\n        }\n    });\n}"
              },
              "searchWithPartitionFilter" : {
                "definition" : "@Test\nvoid searchWithPartitionFilter() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"BG\", \"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"year\", (short) 2020));\n            var nlDocument = new Document(\"NL\", \"The World is Big and Salvation Lurks Around the Corner\", java.util.Collections.emptyMap());\n            var bgDocument2 = new Document(\"BG2\", \"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"%s == 'NL'\", CassandraVectorStore.DEFAULT_ID_NAME)).build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(nlDocument.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"%s == 'BG2'\", CassandraVectorStore.DEFAULT_ID_NAME)).build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(bgDocument2.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"%s == 'BG' && year == 2020\", CassandraVectorStore.DEFAULT_ID_NAME)).build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(bgDocument.getId());\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(java.lang.String.format(\"NOT(%s == 'BG' && year == 2020)\", CassandraVectorStore.DEFAULT_ID_NAME)).build()));\n        }\n    });\n}"
              },
              "unsearchableFilters" : {
                "definition" : "@Test\nvoid unsearchableFilters() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'NL'\").build()));\n        }\n    });\n}"
              },
              "searchWithFilters" : {
                "definition" : "@Test\nvoid searchWithFilters() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"country\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'NL'\").build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(nlDocument.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'BG'\").build());\n            assertThat(results).hasSize(2);\n            assertThat(results.get(0).getId()).isIn(bgDocument.getId(), bgDocument2.getId());\n            assertThat(results.get(1).getId()).isIn(bgDocument.getId(), bgDocument2.getId());\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'BG' && year == 2020\").build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getId()).isEqualTo(bgDocument.getId());\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"country == 'BG' || year == 2020\").build()));\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"NOT(country == 'BG' && year == 2020)\").build()));\n        }\n    });\n}"
              },
              "documentUpdate" : {
                "definition" : "@Test\nvoid documentUpdate() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            Document document = new Document(UUID.randomUUID().toString(), \"Spring AI rocks!!\", Collections.singletonMap(\"meta1\", \"meta1\"));\n            store.add(List.of(document));\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(5).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(document.getId());\n            assertThat(resultDoc.getText()).isEqualTo(\"Spring AI rocks!!\");\n            assertThat(resultDoc.getMetadata()).containsKey(\"meta1\");\n            Document sameIdDocument = new Document(document.getId(), \"The World is Big and Salvation Lurks Around the Corner\", Collections.singletonMap(\"meta2\", \"meta2\"));\n            store.add(List.of(sameIdDocument));\n            results = store.similaritySearch(SearchRequest.builder().query(\"FooBar\").topK(5).build());\n            assertThat(results).hasSize(1);\n            resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(document.getId());\n            assertThat(resultDoc.getText()).isEqualTo(\"The World is Big and Salvation Lurks Around the Corner\");\n            assertThat(resultDoc.getMetadata()).containsKeys(\"meta2\", DocumentMetadata.DISTANCE.value());\n            store.delete(List.of(document.getId()));\n        }\n    });\n}"
              },
              "searchWithThreshold" : {
                "definition" : "@Test\nvoid searchWithThreshold() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            store.add(documents());\n            List<Document> fullResult = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(5).similarityThresholdAll().build());\n            List<Double> scores = fullResult.stream().map(Document::getScore).toList();\n            assertThat(scores).hasSize(3);\n            double similarityThreshold = (scores.get(0) + scores.get(1)) / 2;\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(5).similarityThreshold(similarityThreshold).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents().get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Spring AI provides abstractions that serve as the foundation for developing AI applications.\");\n            assertThat(resultDoc.getMetadata()).containsKeys(\"meta1\", DocumentMetadata.DISTANCE.value());\n            assertThat(resultDoc.getScore()).isGreaterThanOrEqualTo(similarityThreshold);\n        }\n    });\n}"
              },
              "deleteByFilter" : {
                "definition" : "@Test\nprotected void deleteByFilter() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"country\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            \n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            \n            Filter.Expression filterExpression = new Filter.Expression(Filter.ExpressionType.EQ, new Filter.Key(\"country\"), new Filter.Value(\"BG\"));\n            store.delete(filterExpression);\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getMetadata()).containsEntry(\"country\", \"NL\");\n        }\n    });\n}"
              },
              "deleteWithStringFilterExpression" : {
                "definition" : "@Test\nprotected void deleteWithStringFilterExpression() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"country\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"year\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var bgDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2020));\n            var nlDocument = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"NL\"));\n            var bgDocument2 = new Document(\"The World is Big and Salvation Lurks Around the Corner\", Map.of(\"country\", \"BG\", \"year\", (short) 2023));\n            store.add(List.of(bgDocument, nlDocument, bgDocument2));\n            \n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).build());\n            assertThat(results).hasSize(3);\n            store.delete(\"country == 'BG'\");\n            results = store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().build());\n            assertThat(results).hasSize(1);\n            assertThat(results.get(0).getMetadata()).containsEntry(\"country\", \"NL\");\n        }\n    });\n}"
              },
              "deleteWithComplexFilterExpression" : {
                "definition" : "@Test\nvoid deleteWithComplexFilterExpression() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createTestStore(context, new SchemaColumn(\"type\", DataTypes.TEXT, SchemaColumnTags.INDEXED), new SchemaColumn(\"priority\", DataTypes.SMALLINT, SchemaColumnTags.INDEXED))) {\n            var doc1 = new Document(\"Content 1\", Map.of(\"type\", \"A\", \"priority\", (short) 1));\n            var doc2 = new Document(\"Content 2\", Map.of(\"type\", \"A\", \"priority\", (short) 2));\n            var doc3 = new Document(\"Content 3\", Map.of(\"type\", \"B\", \"priority\", (short) 1));\n            store.add(List.of(doc1, doc2, doc3));\n            \n            Filter.Expression priorityFilter = new Filter.Expression(Filter.ExpressionType.GT, new Filter.Key(\"priority\"), new Filter.Value((short) 1));\n            Filter.Expression typeFilter = new Filter.Expression(Filter.ExpressionType.EQ, new Filter.Key(\"type\"), new Filter.Value(\"A\"));\n            Filter.Expression complexFilter = new Filter.Expression(Filter.ExpressionType.AND, typeFilter, priorityFilter);\n            store.delete(complexFilter);\n            var results = store.similaritySearch(SearchRequest.builder().query(\"Content\").topK(5).similarityThresholdAll().build());\n            assertThat(results).hasSize(2);\n            assertThat(results.stream().map(doc -> doc.getMetadata().get(\"type\")).collect(Collectors.toList())).containsExactlyInAnyOrder(\"A\", \"B\");\n            assertThat(results.stream().map(doc -> ((Short) doc.getMetadata().get(\"priority\")).intValue()).collect(Collectors.toList())).containsExactlyInAnyOrder(1, 1);\n        }\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraRichSchemaVectorStoreIT.java" : {
              "storeBuilder" : {
                "definition" : "static CassandraVectorStore.Builder storeBuilder(ApplicationContext context, List<CassandraVectorStore.SchemaColumn> columnOverrides) throws IOException {\n    Optional<CassandraVectorStore.SchemaColumn> wikiOverride = columnOverrides.stream().filter(f -> \"wiki\".equals(f.name())).findFirst();\n    Optional<CassandraVectorStore.SchemaColumn> langOverride = columnOverrides.stream().filter(f -> \"language\".equals(f.name())).findFirst();\n    Optional<CassandraVectorStore.SchemaColumn> titleOverride = columnOverrides.stream().filter(f -> \"title\".equals(f.name())).findFirst();\n    Optional<CassandraVectorStore.SchemaColumn> chunkNoOverride = columnOverrides.stream().filter(f -> \"chunk_no\".equals(f.name())).findFirst();\n    var wikiSC = wikiOverride.orElse(new CassandraVectorStore.SchemaColumn(\"wiki\", DataTypes.TEXT));\n    var langSC = langOverride.orElse(new CassandraVectorStore.SchemaColumn(\"language\", DataTypes.TEXT));\n    var titleSC = titleOverride.orElse(new CassandraVectorStore.SchemaColumn(\"title\", DataTypes.TEXT));\n    var chunkNoSC = chunkNoOverride.orElse(new CassandraVectorStore.SchemaColumn(\"chunk_no\", DataTypes.INT));\n    List<CassandraVectorStore.SchemaColumn> partitionKeys = List.of(wikiSC, langSC, titleSC);\n    List<CassandraVectorStore.SchemaColumn> clusteringKeys = List.of(chunkNoSC);\n    return CassandraVectorStore.builder(context.getBean(EmbeddingModel.class)).session(context.getBean(CqlSession.class)).keyspace(\"test_wikidata\").table(\"articles\").partitionKeys(partitionKeys).clusteringKeys(clusteringKeys).contentColumnName(\"body\").embeddingColumnName(\"all_minilm_l6_v2_embedding\").indexName(\"all_minilm_l6_v2_ann\").addMetadataColumns(new CassandraVectorStore.SchemaColumn(\"revision\", DataTypes.INT), new CassandraVectorStore.SchemaColumn(\"id\", DataTypes.INT, CassandraVectorStore.SchemaColumnTags.INDEXED)).\n    \n    primaryKeyTranslator((List<Object> primaryKeys) -> {\n        if (primaryKeys.isEmpty()) {\n            return \"test§¶0\";\n        }\n        return String.format(\"%s§¶%s\", primaryKeys.get(2), primaryKeys.get(3));\n    }).documentIdTranslator(id -> {\n        String[] parts = id.split(\"§¶\");\n        String title = parts[0];\n        int chunk_no = 0 < parts.length ? Integer.parseInt(parts[1]) : 0;\n        return List.of(\"simplewiki\", \"en\", title, chunk_no);\n    });\n}"
              },
              "ensureSchemaCreation" : {
                "definition" : "@Test\nvoid ensureSchemaCreation() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            Assertions.assertNotNull(store);\n            store.checkSchemaValid();\n            store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n        }\n    });\n}"
              },
              "ensureSchemaNoCreation" : {
                "definition" : "@Test\nvoid ensureSchemaNoCreation() {\n    this.contextRunner.run(context -> {\n        executeCqlFile(context, \"test_wiki_full_schema.cql\");\n        var builder = createBuilder(context, List.of(), true, false);\n        Assertions.assertNotNull(builder);\n        var store = new CassandraVectorStore(builder);\n        try {\n            store.checkSchemaValid();\n            store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            CassandraVectorStore.dropKeyspace(builder);\n            executeCqlFile(context, \"test_wiki_partial_3_schema.cql\");\n            \n            IllegalStateException ise = Assertions.assertThrows(IllegalStateException.class, () -> createStore(context, List.of(), true, false));\n            Assertions.assertEquals(\"column all_minilm_l6_v2_embedding does not exist\", ise.getMessage());\n        } finally {\n            CassandraVectorStore.dropKeyspace(builder);\n            store.close();\n        }\n    });\n}"
              },
              "ensureSchemaPartialCreation" : {
                "definition" : "@Test\nvoid ensureSchemaPartialCreation() {\n    this.contextRunner.run(context -> {\n        int PARTIAL_FILES = 5;\n        for (int i = 0; i < PARTIAL_FILES; ++i) {\n            executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", i));\n            var builder = createBuilder(context, List.of(), false, false);\n            Assertions.assertNotNull(builder);\n            CassandraVectorStore.dropKeyspace(builder);\n            var store = builder.build();\n            try {\n                store.checkSchemaValid();\n                store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            } finally {\n                CassandraVectorStore.dropKeyspace(builder);\n                store.close();\n            }\n        }\n        \n        Assertions.assertThrows(IOException.class, () -> executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", PARTIAL_FILES)));\n    });\n}"
              },
              "addAndSearch" : {
                "definition" : "@Test\nvoid addAndSearch() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Neptunes gravity makes its atmosphere\").topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents.get(0).getId());\n            assertThat(resultDoc.getText()).contains(\"Neptunes gravity makes its atmosphere\");\n            assertThat(resultDoc.getMetadata()).hasSize(3);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"id\", \"revision\", DocumentMetadata.DISTANCE.value());\n            \n            store.delete(documents.stream().map(doc -> doc.getId()).toList());\n            results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n            assertThat(results).isEmpty();\n        }\n    });\n}"
              },
              "addAndSearchPoormansBench" : {
                "definition" : "@Test\nvoid addAndSearchPoormansBench() {\n    \n    int nThreads = CassandraVectorStore.DEFAULT_ADD_CONCURRENCY;\n    \n    int runs = 10;\n    \n    int docsPerAdd = 12;\n    int rounds = 3;\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = storeBuilder(context, List.of()).fixedThreadPoolExecutorSize(nThreads).build()) {\n            var executor = Executors.newFixedThreadPool((int) (nThreads * 1.2));\n            for (int k = 0; k < rounds; ++k) {\n                long start = System.nanoTime();\n                var futures = new CompletableFuture[runs];\n                for (int j = 0; j < runs; ++j) {\n                    futures[j] = CompletableFuture.runAsync(() -> {\n                        List<Document> documents = new ArrayList<>();\n                        for (int i = docsPerAdd; i >= 0; --i) {\n                            documents.add(new Document(RandomStringUtils.randomAlphanumeric(4) + \"§¶\" + ThreadLocalRandom.current().nextInt(1, 10), RandomStringUtils.randomAlphanumeric(1024), Map.of(\"revision\", ThreadLocalRandom.current().nextInt(1, 100000), \"id\", 1000)));\n                        }\n                        store.add(documents);\n                        var results = store.similaritySearch(SearchRequest.builder().query(RandomStringUtils.randomAlphanumeric(20)).topK(10).build());\n                        assertThat(results).hasSize(10);\n                    }, executor);\n                }\n                CompletableFuture.allOf(futures).join();\n                long time = System.nanoTime() - start;\n                logger.info(\"add+search took an average of {} ms\", Duration.ofNanos(time / runs).toMillis());\n            }\n        }\n    });\n}"
              },
              "searchWithPartitionFilter" : {
                "definition" : "@Test\nvoid searchWithPartitionFilter() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"wiki == 'simplewiki' && language == 'en' && title == 'Neptune'\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            results = store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"wiki == 'simplewiki' && language == 'en' && title == 'Neptune' && id == 558\").build());\n            assertThat(results).hasSize(3);\n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"NOT(wiki == 'simplewiki' && language == 'en' && title == 'Neptune' && id == 1)\").build()));\n        }\n    });\n}"
              },
              "unsearchableFilters" : {
                "definition" : "@Test\nvoid unsearchableFilters() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).build());\n            assertThat(results).hasSize(3);\n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(\"The World\").topK(5).similarityThresholdAll().filterExpression(\"revision == 9385813\").build()));\n        }\n    });\n}"
              },
              "searchWithFilters" : {
                "definition" : "@Test\nvoid searchWithFilters() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).build());\n            assertThat(results).hasSize(3);\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id == 558\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id > 557\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id >= 558\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            \n            \n            \n            \n            \n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id > 557 && \\\"chunk_no\\\" == 1\").build()));\n            \n            \n            Assertions.assertThrows(SyntaxError.class, () -> store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"id == 558 || revision == 2020\").build()));\n            \n            Assertions.assertThrows(InvalidQueryException.class, () -> store.similaritySearch(SearchRequest.builder().query(\"Great Dark Spot\").topK(5).similarityThresholdAll().filterExpression(\"NOT(id == 557 || revision == 2020)\").build()));\n        }\n    });\n}"
              },
              "searchWithFilterOnPrimaryKeys" : {
                "definition" : "@Test\nvoid searchWithFilterOnPrimaryKeys() throws InterruptedException {\n    this.contextRunner.run(context -> {\n        List<SchemaColumn> overrides = List.of(new SchemaColumn(\"title\", DataTypes.TEXT, CassandraVectorStore.SchemaColumnTags.INDEXED), new SchemaColumn(\"chunk_no\", DataTypes.INT, CassandraVectorStore.SchemaColumnTags.INDEXED));\n        try (CassandraVectorStore store = createStore(context, overrides, false, true)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).build());\n            assertThat(results).hasSize(3);\n            store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().filterExpression(\"id > 557 && \\\"chunk_no\\\" == 1\").build());\n            assertThat(results).hasSize(3);\n            assertThat(results.get(0).getId()).isEqualTo(documents.get(1).getId());\n            \n            \n            \n            \n            \n            \n            \n            \n            \n        }\n    });\n}"
              },
              "documentUpdate" : {
                "definition" : "@Test\nvoid documentUpdate() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(1).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getText()).contains(URANUS_ORBIT_QUERY);\n            assertThat(resultDoc.getMetadata()).containsKey(\"revision\");\n            String newContent = \"The World is Big and Salvation Lurks Around the Corner\";\n            Document sameIdDocument = new Document(documents.get(1).getId(), newContent, Collections.emptyMap());\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            store.delete(List.of(sameIdDocument.getId()));\n            results = store.similaritySearch(SearchRequest.builder().query(newContent).topK(1).build());\n            assertThat(results).hasSize(1);\n            resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isNotEqualTo(sameIdDocument.getId());\n            assertThat(resultDoc.getText()).doesNotContain(newContent);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"id\", \"revision\", DocumentMetadata.DISTANCE.value());\n        }\n    });\n}"
              },
              "searchWithThreshold" : {
                "definition" : "@Test\nvoid searchWithThreshold() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            store.add(documents);\n            List<Document> fullResult = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThresholdAll().build());\n            List<Double> scores = fullResult.stream().map(Document::getScore).toList();\n            assertThat(scores).hasSize(3);\n            double similarityThreshold = (scores.get(0) + scores.get(1)) / 2;\n            List<Document> results = store.similaritySearch(SearchRequest.builder().query(URANUS_ORBIT_QUERY).topK(5).similarityThreshold(similarityThreshold).build());\n            assertThat(results).hasSize(1);\n            Document resultDoc = results.get(0);\n            assertThat(resultDoc.getId()).isEqualTo(documents.get(1).getId());\n            assertThat(resultDoc.getText()).contains(URANUS_ORBIT_QUERY);\n            assertThat(resultDoc.getMetadata()).containsKeys(\"id\", \"revision\", DocumentMetadata.DISTANCE.value());\n            assertThat(resultDoc.getScore()).isGreaterThanOrEqualTo(similarityThreshold);\n        }\n    });\n}"
              }
            }
          }
        }, {
          "name" : "toFloatArray",
          "arguments" : [ "float[] embedding" ],
          "accessModifier" : "private,static",
          "methodsCalled" : [ {
            "name" : "floatValue",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "embedding", "embeddingFloat", "i", "d" ],
          "annotations" : [ ],
          "returnType" : "Float[]",
          "comments" : null,
          "methodDefinition" : "private static Float[] toFloatArray(float[] embedding) {\n    Float[] embeddingFloat = new Float[embedding.length];\n    int i = 0;\n    for (Float d : embedding) {\n        embeddingFloat[i++] = d.floatValue();\n    }\n    return embeddingFloat;\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "doAdd",
          "arguments" : [ "List<Document> documents" ],
          "accessModifier" : "public",
          "methodsCalled" : [ {
            "name" : "size",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "embed",
            "arguments" : [ "documents", "EmbeddingOptionsBuilder.builder().build()", "this.batchingStrategy" ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : "@Override\npublic CassandraVectorStore build() {\n    if (this.session == null && this.sessionBuilder != null) {\n        this.session = this.sessionBuilder.build();\n        this.closeSessionOnClose = true;\n    }\n    Assert.notNull(this.session, \"Either session must be set directly or configured via sessionBuilder\");\n    return new CassandraVectorStore(this);\n}"
          }, {
            "name" : "builder",
            "arguments" : [ ],
            "body" : "public static Builder builder(EmbeddingModel embeddingModel) {\n    return new Builder(embeddingModel);\n}"
          }, {
            "name" : "runAsync",
            "arguments" : [ "() -> {\n    List<Object> primaryKeyValues = this.documentIdTranslator.apply(d.getId());\n    BoundStatementBuilder builder = prepareAddStatement(d.getMetadata().keySet()).boundStatementBuilder();\n    for (int k = 0; k < primaryKeyValues.size(); ++k) {\n        SchemaColumn keyColumn = this.getPrimaryKeyColumn(k);\n        builder = builder.set(keyColumn.name(), primaryKeyValues.get(k), keyColumn.javaType());\n    }\n    builder = builder.setString(this.schema.content(), d.getText()).setVector(this.schema.embedding(), CqlVector.newInstance(EmbeddingUtils.toList(embeddings.get(documents.indexOf(d)))), Float.class);\n    for (var metadataColumn : this.schema.metadataColumns().stream().filter(mc -> d.getMetadata().containsKey(mc.name())).toList()) {\n        builder = builder.set(metadataColumn.name(), d.getMetadata().get(metadataColumn.name()), metadataColumn.javaType());\n    }\n    BoundStatement s = builder.build().setExecutionProfileName(DRIVER_PROFILE_UPDATES);\n    this.session.execute(s);\n}", "this.executor" ],
            "body" : ""
          }, {
            "name" : "apply",
            "arguments" : [ "d.getId()" ],
            "body" : ""
          }, {
            "name" : "getId",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "boundStatementBuilder",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "prepareAddStatement",
            "arguments" : [ "d.getMetadata().keySet()" ],
            "body" : "private PreparedStatement prepareAddStatement(Set<String> metadataFields) {\n    \n    Set<String> fieldsThatAreColumns = new HashSet<>(this.schema.metadataColumns().stream().map(mc -> mc.name()).filter(mc -> metadataFields.contains(mc)).toList());\n    return this.addStmts.computeIfAbsent(fieldsThatAreColumns, fields -> {\n        RegularInsert stmt = null;\n        InsertInto stmtStart = QueryBuilder.insertInto(this.schema.keyspace(), this.schema.table());\n        for (var c : this.schema.partitionKeys()) {\n            stmt = (null != stmt ? stmt : stmtStart).value(c.name(), QueryBuilder.bindMarker(c.name()));\n        }\n        for (var c : this.schema.clusteringKeys()) {\n            stmt = stmt.value(c.name(), QueryBuilder.bindMarker(c.name()));\n        }\n        stmt = stmt.value(this.schema.content(), QueryBuilder.bindMarker(this.schema.content())).value(this.schema.embedding(), QueryBuilder.bindMarker(this.schema.embedding()));\n        for (String metadataField : fields) {\n            stmt = stmt.value(metadataField, QueryBuilder.bindMarker(metadataField));\n        }\n        return this.session.prepare(stmt.build());\n    });\n}"
          }, {
            "name" : "keySet",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "size",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getPrimaryKeyColumn",
            "arguments" : [ "k" ],
            "body" : "SchemaColumn getPrimaryKeyColumn(int index) {\n    return index < this.schema.partitionKeys().size() ? this.schema.partitionKeys().get(index) : this.schema.clusteringKeys().get(index - this.schema.partitionKeys().size());\n}"
          }, {
            "name" : "set",
            "arguments" : [ "keyColumn.name()", "primaryKeyValues.get(k)", "keyColumn.javaType()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "k" ],
            "body" : ""
          }, {
            "name" : "javaType",
            "arguments" : [ ],
            "body" : "public GenericType<Object> javaType() {\n    return CodecRegistry.DEFAULT.codecFor(this.type).getJavaType();\n}"
          }, {
            "name" : "setVector",
            "arguments" : [ "this.schema.embedding()", "CqlVector.newInstance(EmbeddingUtils.toList(embeddings.get(documents.indexOf(d))))", "Float.class" ],
            "body" : ""
          }, {
            "name" : "setString",
            "arguments" : [ "this.schema.content()", "d.getText()" ],
            "body" : ""
          }, {
            "name" : "content",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getText",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "embedding",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "newInstance",
            "arguments" : [ "EmbeddingUtils.toList(embeddings.get(documents.indexOf(d)))" ],
            "body" : ""
          }, {
            "name" : "toList",
            "arguments" : [ "embeddings.get(documents.indexOf(d))" ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "documents.indexOf(d)" ],
            "body" : ""
          }, {
            "name" : "indexOf",
            "arguments" : [ "d" ],
            "body" : ""
          }, {
            "name" : "toList",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "filter",
            "arguments" : [ "mc -> d.getMetadata().containsKey(mc.name())" ],
            "body" : ""
          }, {
            "name" : "stream",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "metadataColumns",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "containsKey",
            "arguments" : [ "mc.name()" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "set",
            "arguments" : [ "metadataColumn.name()", "d.getMetadata().get(metadataColumn.name())", "metadataColumn.javaType()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "metadataColumn.name()" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "javaType",
            "arguments" : [ ],
            "body" : "public GenericType<Object> javaType() {\n    return CodecRegistry.DEFAULT.codecFor(this.type).getJavaType();\n}"
          }, {
            "name" : "setExecutionProfileName",
            "arguments" : [ "DRIVER_PROFILE_UPDATES" ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : "@Override\npublic CassandraVectorStore build() {\n    if (this.session == null && this.sessionBuilder != null) {\n        this.session = this.sessionBuilder.build();\n        this.closeSessionOnClose = true;\n    }\n    Assert.notNull(this.session, \"Either session must be set directly or configured via sessionBuilder\");\n    return new CassandraVectorStore(this);\n}"
          }, {
            "name" : "execute",
            "arguments" : [ "s" ],
            "body" : ""
          }, {
            "name" : "join",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "allOf",
            "arguments" : [ "futures" ],
            "body" : ""
          } ],
          "usedEntities" : [ "documents", "EmbeddingOptionsBuilder", "futures", "i", "CompletableFuture", "d", "k", "primaryKeyValues", "builder", "keyColumn", "CqlVector", "EmbeddingUtils", "embeddings", "mc", "metadataColumn", "DRIVER_PROFILE_UPDATES", "s" ],
          "annotations" : [ "Override" ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "@Override\npublic void doAdd(List<Document> documents) {\n    var futures = new CompletableFuture[documents.size()];\n    List<float[]> embeddings = this.embeddingModel.embed(documents, EmbeddingOptionsBuilder.builder().build(), this.batchingStrategy);\n    int i = 0;\n    for (Document d : documents) {\n        futures[i++] = CompletableFuture.runAsync(() -> {\n            List<Object> primaryKeyValues = this.documentIdTranslator.apply(d.getId());\n            BoundStatementBuilder builder = prepareAddStatement(d.getMetadata().keySet()).boundStatementBuilder();\n            for (int k = 0; k < primaryKeyValues.size(); ++k) {\n                SchemaColumn keyColumn = this.getPrimaryKeyColumn(k);\n                builder = builder.set(keyColumn.name(), primaryKeyValues.get(k), keyColumn.javaType());\n            }\n            builder = builder.setString(this.schema.content(), d.getText()).setVector(this.schema.embedding(), CqlVector.newInstance(EmbeddingUtils.toList(embeddings.get(documents.indexOf(d)))), Float.class);\n            for (var metadataColumn : this.schema.metadataColumns().stream().filter(mc -> d.getMetadata().containsKey(mc.name())).toList()) {\n                builder = builder.set(metadataColumn.name(), d.getMetadata().get(metadataColumn.name()), metadataColumn.javaType());\n            }\n            BoundStatement s = builder.build().setExecutionProfileName(DRIVER_PROFILE_UPDATES);\n            this.session.execute(s);\n        }, this.executor);\n    }\n    CompletableFuture.allOf(futures).join();\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "doDelete",
          "arguments" : [ "List<String> idList" ],
          "accessModifier" : "public",
          "methodsCalled" : [ {
            "name" : "size",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "apply",
            "arguments" : [ "id" ],
            "body" : ""
          }, {
            "name" : "bind",
            "arguments" : [ "primaryKeyValues.toArray()" ],
            "body" : ""
          }, {
            "name" : "toArray",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "toCompletableFuture",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "executeAsync",
            "arguments" : [ "s" ],
            "body" : ""
          }, {
            "name" : "join",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "allOf",
            "arguments" : [ "futures" ],
            "body" : ""
          } ],
          "usedEntities" : [ "idList", "id", "primaryKeyValues", "futures", "i", "s", "CompletableFuture" ],
          "annotations" : [ "Override" ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "@Override\npublic void doDelete(List<String> idList) {\n    CompletableFuture[] futures = new CompletableFuture[idList.size()];\n    int i = 0;\n    for (String id : idList) {\n        List<Object> primaryKeyValues = this.documentIdTranslator.apply(id);\n        BoundStatement s = this.deleteStmt.bind(primaryKeyValues.toArray());\n        futures[i++] = this.session.executeAsync(s).toCompletableFuture();\n    }\n    CompletableFuture.allOf(futures).join();\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "doDelete",
          "arguments" : [ "Filter.Expression filterExpression" ],
          "accessModifier" : "protected",
          "methodsCalled" : [ {
            "name" : "notNull",
            "arguments" : [ "filterExpression", "\"Filter expression must not be null\"" ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : "@Override\npublic CassandraVectorStore build() {\n    if (this.session == null && this.sessionBuilder != null) {\n        this.session = this.sessionBuilder.build();\n        this.closeSessionOnClose = true;\n    }\n    Assert.notNull(this.session, \"Either session must be set directly or configured via sessionBuilder\");\n    return new CassandraVectorStore(this);\n}"
          }, {
            "name" : "similarityThresholdAll",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "topK",
            "arguments" : [ "// large enough to get all matches\n1000" ],
            "body" : ""
          }, {
            "name" : "filterExpression",
            "arguments" : [ "filterExpression" ],
            "body" : ""
          }, {
            "name" : "query",
            "arguments" : [ "// empty query since we only want filter matches\n\"\"" ],
            "body" : ""
          }, {
            "name" : "builder",
            "arguments" : [ ],
            "body" : "public static Builder builder(EmbeddingModel embeddingModel) {\n    return new Builder(embeddingModel);\n}"
          }, {
            "name" : "similaritySearch",
            "arguments" : [ "searchRequest" ],
            "body" : ""
          }, {
            "name" : "isEmpty",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "collect",
            "arguments" : [ "Collectors.toList()" ],
            "body" : ""
          }, {
            "name" : "map",
            "arguments" : [ "Document::getId" ],
            "body" : ""
          }, {
            "name" : "stream",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "toList",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "delete",
            "arguments" : [ "idsToDelete" ],
            "body" : ""
          }, {
            "name" : "debug",
            "arguments" : [ "\"Deleted {} documents matching filter expression\"", "idsToDelete.size()" ],
            "body" : ""
          }, {
            "name" : "size",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "error",
            "arguments" : [ "\"Failed to delete documents by filter\"", "e" ],
            "body" : ""
          } ],
          "usedEntities" : [ "Assert", "filterExpression", "SearchRequest", "searchRequest", "matchingDocs", "Collectors", "idsToDelete", "logger", "e" ],
          "annotations" : [ "Override" ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "@Override\nprotected void doDelete(Filter.Expression filterExpression) {\n    Assert.notNull(filterExpression, \"Filter expression must not be null\");\n    try {\n        \n        \n        \n        \n        \n        SearchRequest searchRequest = SearchRequest.builder().query(\n        \"\").filterExpression(filterExpression).topK(\n        1000).similarityThresholdAll().build();\n        List<Document> matchingDocs = similaritySearch(searchRequest);\n        if (!matchingDocs.isEmpty()) {\n            \n            List<String> idsToDelete = matchingDocs.stream().map(Document::getId).collect(Collectors.toList());\n            delete(idsToDelete);\n            logger.debug(\"Deleted {} documents matching filter expression\", idsToDelete.size());\n        }\n    } catch (Exception e) {\n        logger.error(\"Failed to delete documents by filter\", e);\n        throw new IllegalStateException(\"Failed to delete documents by filter\", e);\n    }\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "doSimilaritySearch",
          "arguments" : [ "SearchRequest request" ],
          "accessModifier" : "public",
          "methodsCalled" : [ {
            "name" : "checkArgument",
            "arguments" : [ "request.getTopK() <= 1000" ],
            "body" : ""
          }, {
            "name" : "getTopK",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "toFloatArray",
            "arguments" : [ "this.embeddingModel.embed(request.getQuery())" ],
            "body" : "private static Float[] toFloatArray(float[] embedding) {\n    Float[] embeddingFloat = new Float[embedding.length];\n    int i = 0;\n    for (Float d : embedding) {\n        embeddingFloat[i++] = d.floatValue();\n    }\n    return embeddingFloat;\n}"
          }, {
            "name" : "embed",
            "arguments" : [ "request.getQuery()" ],
            "body" : ""
          }, {
            "name" : "getQuery",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "newInstance",
            "arguments" : [ "embedding" ],
            "body" : ""
          }, {
            "name" : "hasFilterExpression",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "convertExpression",
            "arguments" : [ "request.getFilterExpression()" ],
            "body" : ""
          }, {
            "name" : "getFilterExpression",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "isBlank",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "format",
            "arguments" : [ "\"where %s\"", "expression" ],
            "body" : ""
          }, {
            "name" : "format",
            "arguments" : [ "this.similarityStmt", "cqlVector", "whereClause", "cqlVector", "request.getTopK()" ],
            "body" : ""
          }, {
            "name" : "getTopK",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "trace",
            "arguments" : [ "\"Executing {}\"", "query" ],
            "body" : ""
          }, {
            "name" : "setExecutionProfileName",
            "arguments" : [ "DRIVER_PROFILE_SEARCH" ],
            "body" : ""
          }, {
            "name" : "newInstance",
            "arguments" : [ "query" ],
            "body" : ""
          }, {
            "name" : "execute",
            "arguments" : [ "s" ],
            "body" : ""
          }, {
            "name" : "getFloat",
            "arguments" : [ "0" ],
            "body" : ""
          }, {
            "name" : "getSimilarityThreshold",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "put",
            "arguments" : [ "DocumentMetadata.DISTANCE.value()", "1 - score" ],
            "body" : ""
          }, {
            "name" : "value",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "metadataColumns",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "metadata.name()", "metadata.javaType()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "javaType",
            "arguments" : [ ],
            "body" : "public GenericType<Object> javaType() {\n    return CodecRegistry.DEFAULT.codecFor(this.type).getJavaType();\n}"
          }, {
            "name" : "put",
            "arguments" : [ "metadata.name()", "value" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : "@Override\npublic CassandraVectorStore build() {\n    if (this.session == null && this.sessionBuilder != null) {\n        this.session = this.sessionBuilder.build();\n        this.closeSessionOnClose = true;\n    }\n    Assert.notNull(this.session, \"Either session must be set directly or configured via sessionBuilder\");\n    return new CassandraVectorStore(this);\n}"
          }, {
            "name" : "score",
            "arguments" : [ "(double) score" ],
            "body" : ""
          }, {
            "name" : "metadata",
            "arguments" : [ "docFields" ],
            "body" : ""
          }, {
            "name" : "text",
            "arguments" : [ "row.getString(this.schema.content())" ],
            "body" : ""
          }, {
            "name" : "id",
            "arguments" : [ "getDocumentId(row)" ],
            "body" : ""
          }, {
            "name" : "builder",
            "arguments" : [ ],
            "body" : "public static Builder builder(EmbeddingModel embeddingModel) {\n    return new Builder(embeddingModel);\n}"
          }, {
            "name" : "getDocumentId",
            "arguments" : [ "row" ],
            "body" : "private String getDocumentId(Row row) {\n    List<Object> primaryKeyValues = new ArrayList<>();\n    for (var m : this.schema.partitionKeys()) {\n        primaryKeyValues.add(row.get(m.name(), m.javaType()));\n    }\n    for (var m : this.schema.clusteringKeys()) {\n        primaryKeyValues.add(row.get(m.name(), m.javaType()));\n    }\n    return this.primaryKeyTranslator.apply(primaryKeyValues);\n}"
          }, {
            "name" : "getString",
            "arguments" : [ "this.schema.content()" ],
            "body" : ""
          }, {
            "name" : "content",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "add",
            "arguments" : [ "doc" ],
            "body" : ""
          } ],
          "usedEntities" : [ "Preconditions", "request", "CqlVector", "embedding", "expression", "whereClause", "String", "cqlVector", "logger", "query", "SimpleStatement", "DRIVER_PROFILE_SEARCH", "s", "row", "score", "docFields", "DocumentMetadata", "metadata", "value", "Document", "documents", "doc" ],
          "annotations" : [ "Override" ],
          "returnType" : "List<Document>",
          "comments" : null,
          "methodDefinition" : "@Override\npublic List<Document> doSimilaritySearch(SearchRequest request) {\n    Preconditions.checkArgument(request.getTopK() <= 1000);\n    var embedding = toFloatArray(this.embeddingModel.embed(request.getQuery()));\n    CqlVector<Float> cqlVector = CqlVector.newInstance(embedding);\n    String whereClause = \"\";\n    if (request.hasFilterExpression()) {\n        String expression = this.filterExpressionConverter.convertExpression(request.getFilterExpression());\n        if (!expression.isBlank()) {\n            whereClause = String.format(\"where %s\", expression);\n        }\n    }\n    String query = String.format(this.similarityStmt, cqlVector, whereClause, cqlVector, request.getTopK());\n    List<Document> documents = new ArrayList<>();\n    logger.trace(\"Executing {}\", query);\n    SimpleStatement s = SimpleStatement.newInstance(query).setExecutionProfileName(DRIVER_PROFILE_SEARCH);\n    for (Row row : this.session.execute(s)) {\n        float score = row.getFloat(0);\n        if (score < request.getSimilarityThreshold()) {\n            break;\n        }\n        Map<String, Object> docFields = new HashMap<>();\n        docFields.put(DocumentMetadata.DISTANCE.value(), 1 - score);\n        for (var metadata : this.schema.metadataColumns()) {\n            var value = row.get(metadata.name(), metadata.javaType());\n            if (null != value) {\n                docFields.put(metadata.name(), value);\n            }\n        }\n        Document doc = Document.builder().id(getDocumentId(row)).text(row.getString(this.schema.content())).metadata(docFields).score((double) score).build();\n        documents.add(doc);\n    }\n    return documents;\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "checkSchemaValid",
          "arguments" : [ ],
          "accessModifier" : "",
          "methodsCalled" : [ {
            "name" : "checkSchemaValid",
            "arguments" : [ "this.embeddingModel.dimensions()" ],
            "body" : "void checkSchemaValid() {\n    this.checkSchemaValid(this.embeddingModel.dimensions());\n}"
          }, {
            "name" : "dimensions",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "void checkSchemaValid() {\n    this.checkSchemaValid(this.embeddingModel.dimensions());\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : true,
          "test_functions" : {
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemoryIT.java" : {
              "ensureBeanGetsCreated" : {
                "definition" : "@Test\nvoid ensureBeanGetsCreated() {\n    this.contextRunner.run(context -> {\n        CassandraChatMemory memory = context.getBean(CassandraChatMemory.class);\n        Assertions.assertNotNull(memory);\n        memory.conf.checkSchemaValid();\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/WikiVectorStoreExample.java" : {
              "ensureBeanGetsCreated" : {
                "definition" : "@Test\nvoid ensureBeanGetsCreated() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore store = context.getBean(CassandraVectorStore.class);\n        Assertions.assertNotNull(store);\n        store.checkSchemaValid();\n        store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n    });\n}"
              },
              "search" : {
                "definition" : "@Test\nvoid search() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore store = context.getBean(CassandraVectorStore.class);\n        Assertions.assertNotNull(store);\n        store.checkSchemaValid();\n        var results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n        assertThat(results).hasSize(1);\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreIT.java" : {
              "ensureBeanGetsCreated" : {
                "definition" : "@Test\nvoid ensureBeanGetsCreated() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            Assertions.assertNotNull(store);\n            store.checkSchemaValid();\n        }\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraRichSchemaVectorStoreIT.java" : {
              "ensureSchemaCreation" : {
                "definition" : "@Test\nvoid ensureSchemaCreation() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            Assertions.assertNotNull(store);\n            store.checkSchemaValid();\n            store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n        }\n    });\n}"
              },
              "ensureSchemaNoCreation" : {
                "definition" : "@Test\nvoid ensureSchemaNoCreation() {\n    this.contextRunner.run(context -> {\n        executeCqlFile(context, \"test_wiki_full_schema.cql\");\n        var builder = createBuilder(context, List.of(), true, false);\n        Assertions.assertNotNull(builder);\n        var store = new CassandraVectorStore(builder);\n        try {\n            store.checkSchemaValid();\n            store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            CassandraVectorStore.dropKeyspace(builder);\n            executeCqlFile(context, \"test_wiki_partial_3_schema.cql\");\n            \n            IllegalStateException ise = Assertions.assertThrows(IllegalStateException.class, () -> createStore(context, List.of(), true, false));\n            Assertions.assertEquals(\"column all_minilm_l6_v2_embedding does not exist\", ise.getMessage());\n        } finally {\n            CassandraVectorStore.dropKeyspace(builder);\n            store.close();\n        }\n    });\n}"
              },
              "ensureSchemaPartialCreation" : {
                "definition" : "@Test\nvoid ensureSchemaPartialCreation() {\n    this.contextRunner.run(context -> {\n        int PARTIAL_FILES = 5;\n        for (int i = 0; i < PARTIAL_FILES; ++i) {\n            executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", i));\n            var builder = createBuilder(context, List.of(), false, false);\n            Assertions.assertNotNull(builder);\n            CassandraVectorStore.dropKeyspace(builder);\n            var store = builder.build();\n            try {\n                store.checkSchemaValid();\n                store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            } finally {\n                CassandraVectorStore.dropKeyspace(builder);\n                store.close();\n            }\n        }\n        \n        Assertions.assertThrows(IOException.class, () -> executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", PARTIAL_FILES)));\n    });\n}"
              }
            }
          }
        }, {
          "name" : "getIndexSimilarity",
          "arguments" : [ "TableMetadata metadata" ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "valueOf",
            "arguments" : [ "metadata.getIndex(this.schema.index()).get().getOptions().getOrDefault(\"similarity_function\", \"COSINE\").toUpperCase()" ],
            "body" : ""
          }, {
            "name" : "toUpperCase",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getOrDefault",
            "arguments" : [ "\"similarity_function\"", "\"COSINE\"" ],
            "body" : ""
          }, {
            "name" : "getOptions",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getIndex",
            "arguments" : [ "this.schema.index()" ],
            "body" : ""
          }, {
            "name" : "index",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "Similarity", "metadata" ],
          "annotations" : [ ],
          "returnType" : "Similarity",
          "comments" : null,
          "methodDefinition" : "private Similarity getIndexSimilarity(TableMetadata metadata) {\n    return Similarity.valueOf(metadata.getIndex(this.schema.index()).get().getOptions().getOrDefault(\"similarity_function\", \"COSINE\").toUpperCase());\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "prepareDeleteStatement",
          "arguments" : [ ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "deleteFrom",
            "arguments" : [ "this.schema.keyspace()", "this.schema.table()" ],
            "body" : ""
          }, {
            "name" : "keyspace",
            "arguments" : [ ],
            "body" : "public Builder keyspace(String keyspace) {\n    Assert.hasText(keyspace, \"Keyspace must not be null or empty\");\n    this.keyspace = keyspace;\n    return this;\n}"
          }, {
            "name" : "table",
            "arguments" : [ ],
            "body" : "public Builder table(String table) {\n    Assert.hasText(table, \"Table must not be null or empty\");\n    this.table = table;\n    return this;\n}"
          }, {
            "name" : "partitionKeys",
            "arguments" : [ ],
            "body" : "public Builder partitionKeys(List<SchemaColumn> partitionKeys) {\n    Assert.notEmpty(partitionKeys, \"Partition keys must not be null or empty\");\n    this.partitionKeys = partitionKeys;\n    return this;\n}"
          }, {
            "name" : "isEqualTo",
            "arguments" : [ "QueryBuilder.bindMarker(c.name())" ],
            "body" : ""
          }, {
            "name" : "whereColumn",
            "arguments" : [ "c.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "bindMarker",
            "arguments" : [ "c.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "clusteringKeys",
            "arguments" : [ ],
            "body" : "public Builder clusteringKeys(List<SchemaColumn> clusteringKeys) {\n    this.clusteringKeys = clusteringKeys != null ? clusteringKeys : List.of();\n    return this;\n}"
          }, {
            "name" : "isEqualTo",
            "arguments" : [ "QueryBuilder.bindMarker(c.name())" ],
            "body" : ""
          }, {
            "name" : "whereColumn",
            "arguments" : [ "c.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "bindMarker",
            "arguments" : [ "c.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "prepare",
            "arguments" : [ "stmt.build()" ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : "@Override\npublic CassandraVectorStore build() {\n    if (this.session == null && this.sessionBuilder != null) {\n        this.session = this.sessionBuilder.build();\n        this.closeSessionOnClose = true;\n    }\n    Assert.notNull(this.session, \"Either session must be set directly or configured via sessionBuilder\");\n    return new CassandraVectorStore(this);\n}"
          } ],
          "usedEntities" : [ "QueryBuilder", "stmt", "stmtStart", "c" ],
          "annotations" : [ ],
          "returnType" : "PreparedStatement",
          "comments" : null,
          "methodDefinition" : "private PreparedStatement prepareDeleteStatement() {\n    Delete stmt = null;\n    DeleteSelection stmtStart = QueryBuilder.deleteFrom(this.schema.keyspace(), this.schema.table());\n    for (var c : this.schema.partitionKeys()) {\n        stmt = (null != stmt ? stmt : stmtStart).whereColumn(c.name()).isEqualTo(QueryBuilder.bindMarker(c.name()));\n    }\n    for (var c : this.schema.clusteringKeys()) {\n        stmt = stmt.whereColumn(c.name()).isEqualTo(QueryBuilder.bindMarker(c.name()));\n    }\n    return this.session.prepare(stmt.build());\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "prepareAddStatement",
          "arguments" : [ "Set<String> metadataFields" ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "toList",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "filter",
            "arguments" : [ "mc -> metadataFields.contains(mc)" ],
            "body" : ""
          }, {
            "name" : "map",
            "arguments" : [ "mc -> mc.name()" ],
            "body" : ""
          }, {
            "name" : "stream",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "metadataColumns",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "contains",
            "arguments" : [ "mc" ],
            "body" : ""
          }, {
            "name" : "computeIfAbsent",
            "arguments" : [ "fieldsThatAreColumns", "fields -> {\n    RegularInsert stmt = null;\n    InsertInto stmtStart = QueryBuilder.insertInto(this.schema.keyspace(), this.schema.table());\n    for (var c : this.schema.partitionKeys()) {\n        stmt = (null != stmt ? stmt : stmtStart).value(c.name(), QueryBuilder.bindMarker(c.name()));\n    }\n    for (var c : this.schema.clusteringKeys()) {\n        stmt = stmt.value(c.name(), QueryBuilder.bindMarker(c.name()));\n    }\n    stmt = stmt.value(this.schema.content(), QueryBuilder.bindMarker(this.schema.content())).value(this.schema.embedding(), QueryBuilder.bindMarker(this.schema.embedding()));\n    for (String metadataField : fields) {\n        stmt = stmt.value(metadataField, QueryBuilder.bindMarker(metadataField));\n    }\n    return this.session.prepare(stmt.build());\n}" ],
            "body" : ""
          }, {
            "name" : "insertInto",
            "arguments" : [ "this.schema.keyspace()", "this.schema.table()" ],
            "body" : ""
          }, {
            "name" : "keyspace",
            "arguments" : [ ],
            "body" : "public Builder keyspace(String keyspace) {\n    Assert.hasText(keyspace, \"Keyspace must not be null or empty\");\n    this.keyspace = keyspace;\n    return this;\n}"
          }, {
            "name" : "table",
            "arguments" : [ ],
            "body" : "public Builder table(String table) {\n    Assert.hasText(table, \"Table must not be null or empty\");\n    this.table = table;\n    return this;\n}"
          }, {
            "name" : "partitionKeys",
            "arguments" : [ ],
            "body" : "public Builder partitionKeys(List<SchemaColumn> partitionKeys) {\n    Assert.notEmpty(partitionKeys, \"Partition keys must not be null or empty\");\n    this.partitionKeys = partitionKeys;\n    return this;\n}"
          }, {
            "name" : "value",
            "arguments" : [ "c.name()", "QueryBuilder.bindMarker(c.name())" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "bindMarker",
            "arguments" : [ "c.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "clusteringKeys",
            "arguments" : [ ],
            "body" : "public Builder clusteringKeys(List<SchemaColumn> clusteringKeys) {\n    this.clusteringKeys = clusteringKeys != null ? clusteringKeys : List.of();\n    return this;\n}"
          }, {
            "name" : "value",
            "arguments" : [ "c.name()", "QueryBuilder.bindMarker(c.name())" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "bindMarker",
            "arguments" : [ "c.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "value",
            "arguments" : [ "this.schema.embedding()", "QueryBuilder.bindMarker(this.schema.embedding())" ],
            "body" : ""
          }, {
            "name" : "value",
            "arguments" : [ "this.schema.content()", "QueryBuilder.bindMarker(this.schema.content())" ],
            "body" : ""
          }, {
            "name" : "content",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "bindMarker",
            "arguments" : [ "this.schema.content()" ],
            "body" : ""
          }, {
            "name" : "content",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "embedding",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "bindMarker",
            "arguments" : [ "this.schema.embedding()" ],
            "body" : ""
          }, {
            "name" : "embedding",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "value",
            "arguments" : [ "metadataField", "QueryBuilder.bindMarker(metadataField)" ],
            "body" : ""
          }, {
            "name" : "bindMarker",
            "arguments" : [ "metadataField" ],
            "body" : ""
          }, {
            "name" : "prepare",
            "arguments" : [ "stmt.build()" ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : "@Override\npublic CassandraVectorStore build() {\n    if (this.session == null && this.sessionBuilder != null) {\n        this.session = this.sessionBuilder.build();\n        this.closeSessionOnClose = true;\n    }\n    Assert.notNull(this.session, \"Either session must be set directly or configured via sessionBuilder\");\n    return new CassandraVectorStore(this);\n}"
          } ],
          "usedEntities" : [ "mc", "metadataFields", "fieldsThatAreColumns", "QueryBuilder", "stmt", "stmtStart", "c", "fields", "metadataField" ],
          "annotations" : [ ],
          "returnType" : "PreparedStatement",
          "comments" : null,
          "methodDefinition" : "private PreparedStatement prepareAddStatement(Set<String> metadataFields) {\n    \n    Set<String> fieldsThatAreColumns = new HashSet<>(this.schema.metadataColumns().stream().map(mc -> mc.name()).filter(mc -> metadataFields.contains(mc)).toList());\n    return this.addStmts.computeIfAbsent(fieldsThatAreColumns, fields -> {\n        RegularInsert stmt = null;\n        InsertInto stmtStart = QueryBuilder.insertInto(this.schema.keyspace(), this.schema.table());\n        for (var c : this.schema.partitionKeys()) {\n            stmt = (null != stmt ? stmt : stmtStart).value(c.name(), QueryBuilder.bindMarker(c.name()));\n        }\n        for (var c : this.schema.clusteringKeys()) {\n            stmt = stmt.value(c.name(), QueryBuilder.bindMarker(c.name()));\n        }\n        stmt = stmt.value(this.schema.content(), QueryBuilder.bindMarker(this.schema.content())).value(this.schema.embedding(), QueryBuilder.bindMarker(this.schema.embedding()));\n        for (String metadataField : fields) {\n            stmt = stmt.value(metadataField, QueryBuilder.bindMarker(metadataField));\n        }\n        return this.session.prepare(stmt.build());\n    });\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "similaritySearchStatement",
          "arguments" : [ ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "partitionKeys",
            "arguments" : [ ],
            "body" : "public Builder partitionKeys(List<SchemaColumn> partitionKeys) {\n    Assert.notEmpty(partitionKeys, \"Partition keys must not be null or empty\");\n    this.partitionKeys = partitionKeys;\n    return this;\n}"
          }, {
            "name" : "append",
            "arguments" : [ "','" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "m.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "clusteringKeys",
            "arguments" : [ ],
            "body" : "public Builder clusteringKeys(List<SchemaColumn> clusteringKeys) {\n    this.clusteringKeys = clusteringKeys != null ? clusteringKeys : List.of();\n    return this;\n}"
          }, {
            "name" : "append",
            "arguments" : [ "','" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "m.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "deleteCharAt",
            "arguments" : [ "ids.length() - 1" ],
            "body" : ""
          }, {
            "name" : "length",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "toString",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "\",?)\"" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "this.schema.embedding()" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "'('" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "this.similarity.toString().toLowerCase()" ],
            "body" : ""
          }, {
            "name" : "toLowerCase",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "toString",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "embedding",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "metadataColumns",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "m.name()" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "','" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "format",
            "arguments" : [ "QUERY_FORMAT", "similarityFunction", "ids.toString()", "this.schema.content()", "extraSelectFields.toString()", "this.schema.keyspace()", "this.schema.table()", "this.schema.embedding()" ],
            "body" : ""
          }, {
            "name" : "toString",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "content",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "toString",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "keyspace",
            "arguments" : [ ],
            "body" : "public Builder keyspace(String keyspace) {\n    Assert.hasText(keyspace, \"Keyspace must not be null or empty\");\n    this.keyspace = keyspace;\n    return this;\n}"
          }, {
            "name" : "table",
            "arguments" : [ ],
            "body" : "public Builder table(String table) {\n    Assert.hasText(table, \"Table must not be null or empty\");\n    this.table = table;\n    return this;\n}"
          }, {
            "name" : "embedding",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "replace",
            "arguments" : [ "\"?\"", "\"%s\"" ],
            "body" : ""
          }, {
            "name" : "debug",
            "arguments" : [ "\"preparing {}\"", "query" ],
            "body" : ""
          } ],
          "usedEntities" : [ "ids", "m", "extraSelectFields", "String", "QUERY_FORMAT", "similarityFunction", "query", "logger" ],
          "annotations" : [ ],
          "returnType" : "String",
          "comments" : null,
          "methodDefinition" : "private String similaritySearchStatement() {\n    StringBuilder ids = new StringBuilder();\n    for (var m : this.schema.partitionKeys()) {\n        ids.append(m.name()).append(',');\n    }\n    for (var m : this.schema.clusteringKeys()) {\n        ids.append(m.name()).append(',');\n    }\n    ids.deleteCharAt(ids.length() - 1);\n    String similarityFunction = new StringBuilder(\"similarity_\").append(this.similarity.toString().toLowerCase()).append('(').append(this.schema.embedding()).append(\",?)\").toString();\n    StringBuilder extraSelectFields = new StringBuilder();\n    for (var m : this.schema.metadataColumns()) {\n        extraSelectFields.append(',').append(m.name());\n    }\n    \n    String query = String.format(QUERY_FORMAT, similarityFunction, ids.toString(), this.schema.content(), extraSelectFields.toString(), this.schema.keyspace(), this.schema.table(), this.schema.embedding());\n    query = query.replace(\"?\", \"%s\");\n    logger.debug(\"preparing {}\", query);\n    return query;\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "getDocumentId",
          "arguments" : [ "Row row" ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "partitionKeys",
            "arguments" : [ ],
            "body" : "public Builder partitionKeys(List<SchemaColumn> partitionKeys) {\n    Assert.notEmpty(partitionKeys, \"Partition keys must not be null or empty\");\n    this.partitionKeys = partitionKeys;\n    return this;\n}"
          }, {
            "name" : "add",
            "arguments" : [ "row.get(m.name(), m.javaType())" ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "m.name()", "m.javaType()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "javaType",
            "arguments" : [ ],
            "body" : "public GenericType<Object> javaType() {\n    return CodecRegistry.DEFAULT.codecFor(this.type).getJavaType();\n}"
          }, {
            "name" : "clusteringKeys",
            "arguments" : [ ],
            "body" : "public Builder clusteringKeys(List<SchemaColumn> clusteringKeys) {\n    this.clusteringKeys = clusteringKeys != null ? clusteringKeys : List.of();\n    return this;\n}"
          }, {
            "name" : "add",
            "arguments" : [ "row.get(m.name(), m.javaType())" ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "m.name()", "m.javaType()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "javaType",
            "arguments" : [ ],
            "body" : "public GenericType<Object> javaType() {\n    return CodecRegistry.DEFAULT.codecFor(this.type).getJavaType();\n}"
          }, {
            "name" : "apply",
            "arguments" : [ "primaryKeyValues" ],
            "body" : ""
          } ],
          "usedEntities" : [ "primaryKeyValues", "row", "m" ],
          "annotations" : [ ],
          "returnType" : "String",
          "comments" : null,
          "methodDefinition" : "private String getDocumentId(Row row) {\n    List<Object> primaryKeyValues = new ArrayList<>();\n    for (var m : this.schema.partitionKeys()) {\n        primaryKeyValues.add(row.get(m.name(), m.javaType()));\n    }\n    for (var m : this.schema.clusteringKeys()) {\n        primaryKeyValues.add(row.get(m.name(), m.javaType()));\n    }\n    return this.primaryKeyTranslator.apply(primaryKeyValues);\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "createObservationContextBuilder",
          "arguments" : [ "String operationName" ],
          "accessModifier" : "public",
          "methodsCalled" : [ {
            "name" : "similarityMetric",
            "arguments" : [ "getSimilarityMetric()" ],
            "body" : ""
          }, {
            "name" : "namespace",
            "arguments" : [ "this.schema.keyspace()" ],
            "body" : ""
          }, {
            "name" : "dimensions",
            "arguments" : [ "this.embeddingModel.dimensions()" ],
            "body" : ""
          }, {
            "name" : "collectionName",
            "arguments" : [ "this.schema.table()" ],
            "body" : ""
          }, {
            "name" : "builder",
            "arguments" : [ "VectorStoreProvider.CASSANDRA.value()", "operationName" ],
            "body" : "public static Builder builder(EmbeddingModel embeddingModel) {\n    return new Builder(embeddingModel);\n}"
          }, {
            "name" : "value",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "table",
            "arguments" : [ ],
            "body" : "public Builder table(String table) {\n    Assert.hasText(table, \"Table must not be null or empty\");\n    this.table = table;\n    return this;\n}"
          }, {
            "name" : "dimensions",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "keyspace",
            "arguments" : [ ],
            "body" : "public Builder keyspace(String keyspace) {\n    Assert.hasText(keyspace, \"Keyspace must not be null or empty\");\n    this.keyspace = keyspace;\n    return this;\n}"
          }, {
            "name" : "getSimilarityMetric",
            "arguments" : [ ],
            "body" : "private String getSimilarityMetric() {\n    if (!SIMILARITY_TYPE_MAPPING.containsKey(this.similarity)) {\n        return this.similarity.name();\n    }\n    return SIMILARITY_TYPE_MAPPING.get(this.similarity).value();\n}"
          } ],
          "usedEntities" : [ "VectorStoreObservationContext", "VectorStoreProvider", "operationName" ],
          "annotations" : [ "Override" ],
          "returnType" : "VectorStoreObservationContext.Builder",
          "comments" : null,
          "methodDefinition" : "@Override\npublic VectorStoreObservationContext.Builder createObservationContextBuilder(String operationName) {\n    return VectorStoreObservationContext.builder(VectorStoreProvider.CASSANDRA.value(), operationName).collectionName(this.schema.table()).dimensions(this.embeddingModel.dimensions()).namespace(this.schema.keyspace()).similarityMetric(getSimilarityMetric());\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "getSimilarityMetric",
          "arguments" : [ ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "containsKey",
            "arguments" : [ "this.similarity" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "value",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "this.similarity" ],
            "body" : ""
          } ],
          "usedEntities" : [ "SIMILARITY_TYPE_MAPPING" ],
          "annotations" : [ ],
          "returnType" : "String",
          "comments" : null,
          "methodDefinition" : "private String getSimilarityMetric() {\n    if (!SIMILARITY_TYPE_MAPPING.containsKey(this.similarity)) {\n        return this.similarity.name();\n    }\n    return SIMILARITY_TYPE_MAPPING.get(this.similarity).value();\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "close",
          "arguments" : [ ],
          "accessModifier" : "public",
          "methodsCalled" : [ {
            "name" : "close",
            "arguments" : [ ],
            "body" : "@Override\npublic void close() throws Exception {\n    if (this.closeSessionOnClose) {\n        this.session.close();\n    }\n}"
          } ],
          "usedEntities" : [ ],
          "annotations" : [ "Override" ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "@Override\npublic void close() throws Exception {\n    if (this.closeSessionOnClose) {\n        this.session.close();\n    }\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : true,
          "test_functions" : {
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraRichSchemaVectorStoreIT.java" : {
              "ensureSchemaNoCreation" : {
                "definition" : "@Test\nvoid ensureSchemaNoCreation() {\n    this.contextRunner.run(context -> {\n        executeCqlFile(context, \"test_wiki_full_schema.cql\");\n        var builder = createBuilder(context, List.of(), true, false);\n        Assertions.assertNotNull(builder);\n        var store = new CassandraVectorStore(builder);\n        try {\n            store.checkSchemaValid();\n            store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            CassandraVectorStore.dropKeyspace(builder);\n            executeCqlFile(context, \"test_wiki_partial_3_schema.cql\");\n            \n            IllegalStateException ise = Assertions.assertThrows(IllegalStateException.class, () -> createStore(context, List.of(), true, false));\n            Assertions.assertEquals(\"column all_minilm_l6_v2_embedding does not exist\", ise.getMessage());\n        } finally {\n            CassandraVectorStore.dropKeyspace(builder);\n            store.close();\n        }\n    });\n}"
              },
              "ensureSchemaPartialCreation" : {
                "definition" : "@Test\nvoid ensureSchemaPartialCreation() {\n    this.contextRunner.run(context -> {\n        int PARTIAL_FILES = 5;\n        for (int i = 0; i < PARTIAL_FILES; ++i) {\n            executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", i));\n            var builder = createBuilder(context, List.of(), false, false);\n            Assertions.assertNotNull(builder);\n            CassandraVectorStore.dropKeyspace(builder);\n            var store = builder.build();\n            try {\n                store.checkSchemaValid();\n                store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            } finally {\n                CassandraVectorStore.dropKeyspace(builder);\n                store.close();\n            }\n        }\n        \n        Assertions.assertThrows(IOException.class, () -> executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", PARTIAL_FILES)));\n    });\n}"
              }
            }
          }
        }, {
          "name" : "getPrimaryKeyColumn",
          "arguments" : [ "int index" ],
          "accessModifier" : "",
          "methodsCalled" : [ {
            "name" : "size",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "partitionKeys",
            "arguments" : [ ],
            "body" : "public Builder partitionKeys(List<SchemaColumn> partitionKeys) {\n    Assert.notEmpty(partitionKeys, \"Partition keys must not be null or empty\");\n    this.partitionKeys = partitionKeys;\n    return this;\n}"
          }, {
            "name" : "get",
            "arguments" : [ "index" ],
            "body" : ""
          }, {
            "name" : "partitionKeys",
            "arguments" : [ ],
            "body" : "public Builder partitionKeys(List<SchemaColumn> partitionKeys) {\n    Assert.notEmpty(partitionKeys, \"Partition keys must not be null or empty\");\n    this.partitionKeys = partitionKeys;\n    return this;\n}"
          }, {
            "name" : "get",
            "arguments" : [ "index - this.schema.partitionKeys().size()" ],
            "body" : ""
          }, {
            "name" : "clusteringKeys",
            "arguments" : [ ],
            "body" : "public Builder clusteringKeys(List<SchemaColumn> clusteringKeys) {\n    this.clusteringKeys = clusteringKeys != null ? clusteringKeys : List.of();\n    return this;\n}"
          }, {
            "name" : "size",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "partitionKeys",
            "arguments" : [ ],
            "body" : "public Builder partitionKeys(List<SchemaColumn> partitionKeys) {\n    Assert.notEmpty(partitionKeys, \"Partition keys must not be null or empty\");\n    this.partitionKeys = partitionKeys;\n    return this;\n}"
          } ],
          "usedEntities" : [ "index" ],
          "annotations" : [ ],
          "returnType" : "SchemaColumn",
          "comments" : null,
          "methodDefinition" : "SchemaColumn getPrimaryKeyColumn(int index) {\n    return index < this.schema.partitionKeys().size() ? this.schema.partitionKeys().get(index) : this.schema.clusteringKeys().get(index - this.schema.partitionKeys().size());\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "dropKeyspace",
          "arguments" : [ "Builder builder" ],
          "accessModifier" : "static",
          "methodsCalled" : [ {
            "name" : "checkState",
            "arguments" : [ "builder.keyspace.startsWith(\"test_\")", "\"Only test keyspaces can be dropped\"" ],
            "body" : ""
          }, {
            "name" : "startsWith",
            "arguments" : [ "\"test_\"" ],
            "body" : ""
          }, {
            "name" : "execute",
            "arguments" : [ "SchemaBuilder.dropKeyspace(builder.keyspace).ifExists().build()" ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : "@Override\npublic CassandraVectorStore build() {\n    if (this.session == null && this.sessionBuilder != null) {\n        this.session = this.sessionBuilder.build();\n        this.closeSessionOnClose = true;\n    }\n    Assert.notNull(this.session, \"Either session must be set directly or configured via sessionBuilder\");\n    return new CassandraVectorStore(this);\n}"
          }, {
            "name" : "ifExists",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "dropKeyspace",
            "arguments" : [ "builder.keyspace" ],
            "body" : "@VisibleForTesting\nstatic void dropKeyspace(Builder builder) {\n    Preconditions.checkState(builder.keyspace.startsWith(\"test_\"), \"Only test keyspaces can be dropped\");\n    builder.session.execute(SchemaBuilder.dropKeyspace(builder.keyspace).ifExists().build());\n}"
          } ],
          "usedEntities" : [ "Preconditions", "builder", "SchemaBuilder" ],
          "annotations" : [ "VisibleForTesting" ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "@VisibleForTesting\nstatic void dropKeyspace(Builder builder) {\n    Preconditions.checkState(builder.keyspace.startsWith(\"test_\"), \"Only test keyspaces can be dropped\");\n    builder.session.execute(SchemaBuilder.dropKeyspace(builder.keyspace).ifExists().build());\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : true,
          "test_functions" : {
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreIT.java" : {
              "createTestStore" : {
                "definition" : "private static CassandraVectorStore createTestStore(ApplicationContext context, CassandraVectorStore.Builder builder) {\n    CassandraVectorStore.dropKeyspace(builder);\n    CassandraVectorStore store = builder.build();\n    return store;\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraRichSchemaVectorStoreIT.java" : {
              "ensureSchemaNoCreation" : {
                "definition" : "@Test\nvoid ensureSchemaNoCreation() {\n    this.contextRunner.run(context -> {\n        executeCqlFile(context, \"test_wiki_full_schema.cql\");\n        var builder = createBuilder(context, List.of(), true, false);\n        Assertions.assertNotNull(builder);\n        var store = new CassandraVectorStore(builder);\n        try {\n            store.checkSchemaValid();\n            store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            CassandraVectorStore.dropKeyspace(builder);\n            executeCqlFile(context, \"test_wiki_partial_3_schema.cql\");\n            \n            IllegalStateException ise = Assertions.assertThrows(IllegalStateException.class, () -> createStore(context, List.of(), true, false));\n            Assertions.assertEquals(\"column all_minilm_l6_v2_embedding does not exist\", ise.getMessage());\n        } finally {\n            CassandraVectorStore.dropKeyspace(builder);\n            store.close();\n        }\n    });\n}"
              },
              "ensureSchemaPartialCreation" : {
                "definition" : "@Test\nvoid ensureSchemaPartialCreation() {\n    this.contextRunner.run(context -> {\n        int PARTIAL_FILES = 5;\n        for (int i = 0; i < PARTIAL_FILES; ++i) {\n            executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", i));\n            var builder = createBuilder(context, List.of(), false, false);\n            Assertions.assertNotNull(builder);\n            CassandraVectorStore.dropKeyspace(builder);\n            var store = builder.build();\n            try {\n                store.checkSchemaValid();\n                store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            } finally {\n                CassandraVectorStore.dropKeyspace(builder);\n                store.close();\n            }\n        }\n        \n        Assertions.assertThrows(IOException.class, () -> executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", PARTIAL_FILES)));\n    });\n}"
              },
              "createStore" : {
                "definition" : "private CassandraVectorStore createStore(ApplicationContext context, List<SchemaColumn> columnOverrides, boolean disallowSchemaCreation, boolean dropKeyspaceFirst) throws IOException {\n    CassandraVectorStore.Builder builder = storeBuilder(context, columnOverrides);\n    if (disallowSchemaCreation) {\n        builder = builder.disallowSchemaChanges(true);\n    }\n    if (dropKeyspaceFirst) {\n        CassandraVectorStore.dropKeyspace(builder);\n    }\n    return new CassandraVectorStore(builder);\n}"
              },
              "createBuilder" : {
                "definition" : "private CassandraVectorStore.Builder createBuilder(ApplicationContext context, List<SchemaColumn> columnOverrides, boolean disallowSchemaCreation, boolean dropKeyspaceFirst) throws IOException {\n    CassandraVectorStore.Builder builder = storeBuilder(context, columnOverrides);\n    if (disallowSchemaCreation) {\n        builder = builder.disallowSchemaChanges(true);\n    }\n    if (dropKeyspaceFirst) {\n        CassandraVectorStore.dropKeyspace(builder);\n    }\n    return builder;\n}"
              }
            }
          }
        }, {
          "name" : "ensureSchemaExists",
          "arguments" : [ "int vectorDimension" ],
          "accessModifier" : "",
          "methodsCalled" : [ {
            "name" : "ensureKeyspaceExists",
            "arguments" : [ "this.session", "this.schema.keyspace" ],
            "body" : ""
          }, {
            "name" : "ensureTableExists",
            "arguments" : [ "vectorDimension" ],
            "body" : "private void ensureTableExists(int vectorDimension) {\n    if (this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).isEmpty()) {\n        CreateTable createTable = null;\n        CreateTableStart createTableStart = SchemaBuilder.createTable(this.schema.keyspace, this.schema.table).ifNotExists();\n        for (SchemaColumn partitionKey : this.schema.partitionKeys) {\n            createTable = (null != createTable ? createTable : createTableStart).withPartitionKey(partitionKey.name, partitionKey.type);\n        }\n        for (SchemaColumn clusteringKey : this.schema.clusteringKeys) {\n            createTable = createTable.withClusteringColumn(clusteringKey.name, clusteringKey.type);\n        }\n        createTable = createTable.withColumn(this.schema.content, DataTypes.TEXT);\n        for (SchemaColumn metadata : this.schema.metadataColumns) {\n            createTable = createTable.withColumn(metadata.name(), metadata.type());\n        }\n        \n        \n        \n        StringBuilder tableStmt = new StringBuilder(createTable.asCql());\n        tableStmt.setLength(tableStmt.length() - 1);\n        tableStmt.append(',').append(this.schema.embedding).append(\" vector<float,\").append(vectorDimension).append(\">)\");\n        logger.debug(\"Executing {}\", tableStmt.toString());\n        this.session.execute(tableStmt.toString());\n    }\n}"
          }, {
            "name" : "ensureTableColumnsExist",
            "arguments" : [ "vectorDimension" ],
            "body" : "private void ensureTableColumnsExist(int vectorDimension) {\n    TableMetadata tableMetadata = this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).get();\n    Set<SchemaColumn> newColumns = new HashSet<>();\n    boolean addContent = tableMetadata.getColumn(this.schema.content).isEmpty();\n    boolean addEmbedding = tableMetadata.getColumn(this.schema.embedding).isEmpty();\n    for (SchemaColumn metadata : this.schema.metadataColumns) {\n        Optional<ColumnMetadata> column = tableMetadata.getColumn(metadata.name());\n        if (column.isPresent()) {\n            Preconditions.checkArgument(column.get().getType().equals(metadata.type()), \"Cannot change type on metadata column %s from %s to %s\", metadata.name(), column.get().getType(), metadata.type());\n        } else {\n            newColumns.add(metadata);\n        }\n    }\n    if (!newColumns.isEmpty() || addContent || addEmbedding) {\n        AlterTableAddColumn alterTable = SchemaBuilder.alterTable(this.schema.keyspace, this.schema.table);\n        for (SchemaColumn metadata : newColumns) {\n            alterTable = alterTable.addColumn(metadata.name(), metadata.type());\n        }\n        if (addContent) {\n            alterTable = alterTable.addColumn(this.schema.content, DataTypes.TEXT);\n        }\n        if (addEmbedding) {\n            \n            StringBuilder alterTableStmt = new StringBuilder(((BuildableQuery) alterTable).asCql());\n            if (newColumns.isEmpty() && !addContent) {\n                alterTableStmt.append(\" ADD (\");\n            } else {\n                alterTableStmt.setLength(alterTableStmt.length() - 1);\n                alterTableStmt.append(',');\n            }\n            alterTableStmt.append(this.schema.embedding).append(\" vector<float,\").append(vectorDimension).append(\">)\");\n            logger.debug(\"Executing {}\", alterTableStmt.toString());\n            this.session.execute(alterTableStmt.toString());\n        } else {\n            SimpleStatement stmt = ((AlterTableAddColumnEnd) alterTable).build();\n            logger.debug(\"Executing {}\", stmt.getQuery());\n            this.session.execute(stmt);\n        }\n    }\n}"
          }, {
            "name" : "ensureIndexesExists",
            "arguments" : [ ],
            "body" : "private void ensureIndexesExists() {\n    SimpleStatement indexStmt = SchemaBuilder.createIndex(this.schema.index).ifNotExists().custom(\"StorageAttachedIndex\").onTable(this.schema.keyspace, this.schema.table).andColumn(this.schema.embedding).build();\n    logger.debug(\"Executing {}\", indexStmt.getQuery());\n    this.session.execute(indexStmt);\n    Stream.concat(this.schema.partitionKeys.stream(), Stream.concat(this.schema.clusteringKeys.stream(), this.schema.metadataColumns.stream())).filter(cs -> cs.indexed()).forEach(metadata -> {\n        SimpleStatement indexStatement = SchemaBuilder.createIndex(String.format(\"%s_idx\", metadata.name())).ifNotExists().custom(\"StorageAttachedIndex\").onTable(this.schema.keyspace, this.schema.table).andColumn(metadata.name()).build();\n        logger.debug(\"Executing {}\", indexStatement.getQuery());\n        this.session.execute(indexStatement);\n    });\n}"
          }, {
            "name" : "checkSchemaAgreement",
            "arguments" : [ "this.session" ],
            "body" : ""
          }, {
            "name" : "checkSchemaValid",
            "arguments" : [ "vectorDimension" ],
            "body" : "void checkSchemaValid() {\n    this.checkSchemaValid(this.embeddingModel.dimensions());\n}"
          } ],
          "usedEntities" : [ "SchemaUtil", "vectorDimension" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "void ensureSchemaExists(int vectorDimension) {\n    if (!this.disallowSchemaChanges) {\n        SchemaUtil.ensureKeyspaceExists(this.session, this.schema.keyspace);\n        ensureTableExists(vectorDimension);\n        ensureTableColumnsExist(vectorDimension);\n        ensureIndexesExists();\n        SchemaUtil.checkSchemaAgreement(this.session);\n    } else {\n        checkSchemaValid(vectorDimension);\n    }\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "checkSchemaValid",
          "arguments" : [ "int vectorDimension" ],
          "accessModifier" : "",
          "methodsCalled" : [ {
            "name" : "checkState",
            "arguments" : [ "this.session.getMetadata().getKeyspace(this.schema.keyspace).isPresent()", "\"keyspace %s does not exist\"", "this.schema.keyspace" ],
            "body" : ""
          }, {
            "name" : "isPresent",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getKeyspace",
            "arguments" : [ "this.schema.keyspace" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "checkState",
            "arguments" : [ "this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).isPresent()", "\"table %s does not exist\"" ],
            "body" : ""
          }, {
            "name" : "isPresent",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getTable",
            "arguments" : [ "this.schema.table" ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getKeyspace",
            "arguments" : [ "this.schema.keyspace" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getTable",
            "arguments" : [ "this.schema.table" ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getKeyspace",
            "arguments" : [ "this.schema.keyspace" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "checkState",
            "arguments" : [ "tableMetadata.getColumn(this.schema.content).isPresent()", "\"column %s does not exist\"", "this.schema.content" ],
            "body" : ""
          }, {
            "name" : "isPresent",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getColumn",
            "arguments" : [ "this.schema.content" ],
            "body" : ""
          }, {
            "name" : "checkState",
            "arguments" : [ "tableMetadata.getColumn(this.schema.embedding).isPresent()", "\"column %s does not exist\"", "this.schema.embedding" ],
            "body" : ""
          }, {
            "name" : "isPresent",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getColumn",
            "arguments" : [ "this.schema.embedding" ],
            "body" : ""
          }, {
            "name" : "getColumn",
            "arguments" : [ "m.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "checkState",
            "arguments" : [ "column.isPresent()", "\"column %s does not exist\"", "m.name()" ],
            "body" : ""
          }, {
            "name" : "isPresent",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "checkArgument",
            "arguments" : [ "column.get().getType().equals(m.type())", "\"Mismatching type on metadata column %s of %s vs %s\"", "m.name()", "column.get().getType()", "m.type()" ],
            "body" : ""
          }, {
            "name" : "equals",
            "arguments" : [ "m.type()" ],
            "body" : ""
          }, {
            "name" : "getType",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "type",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getType",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "type",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "indexed",
            "arguments" : [ ],
            "body" : "public boolean indexed() {\n    for (SchemaColumnTags t : this.tags) {\n        if (SchemaColumnTags.INDEXED == t) {\n            return true;\n        }\n    }\n    return false;\n}"
          }, {
            "name" : "checkState",
            "arguments" : [ "tableMetadata.getIndexes().values().stream().anyMatch(i -> i.getTarget().equals(m.name()))", "\"index %s does not exist\"", "m.name()" ],
            "body" : ""
          }, {
            "name" : "anyMatch",
            "arguments" : [ "i -> i.getTarget().equals(m.name())" ],
            "body" : ""
          }, {
            "name" : "stream",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "values",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getIndexes",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "equals",
            "arguments" : [ "m.name()" ],
            "body" : ""
          }, {
            "name" : "getTarget",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "Preconditions", "tableMetadata", "m", "column", "i" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "void checkSchemaValid(int vectorDimension) {\n    Preconditions.checkState(this.session.getMetadata().getKeyspace(this.schema.keyspace).isPresent(), \"keyspace %s does not exist\", this.schema.keyspace);\n    Preconditions.checkState(this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).isPresent(), \"table %s does not exist\");\n    TableMetadata tableMetadata = this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).get();\n    Preconditions.checkState(tableMetadata.getColumn(this.schema.content).isPresent(), \"column %s does not exist\", this.schema.content);\n    Preconditions.checkState(tableMetadata.getColumn(this.schema.embedding).isPresent(), \"column %s does not exist\", this.schema.embedding);\n    for (SchemaColumn m : this.schema.metadataColumns) {\n        Optional<ColumnMetadata> column = tableMetadata.getColumn(m.name());\n        Preconditions.checkState(column.isPresent(), \"column %s does not exist\", m.name());\n        Preconditions.checkArgument(column.get().getType().equals(m.type()), \"Mismatching type on metadata column %s of %s vs %s\", m.name(), column.get().getType(), m.type());\n        if (m.indexed()) {\n            Preconditions.checkState(tableMetadata.getIndexes().values().stream().anyMatch(i -> i.getTarget().equals(m.name())), \"index %s does not exist\", m.name());\n        }\n    }\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : true,
          "test_functions" : {
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/chat/memory/cassandra/CassandraChatMemoryIT.java" : {
              "ensureBeanGetsCreated" : {
                "definition" : "@Test\nvoid ensureBeanGetsCreated() {\n    this.contextRunner.run(context -> {\n        CassandraChatMemory memory = context.getBean(CassandraChatMemory.class);\n        Assertions.assertNotNull(memory);\n        memory.conf.checkSchemaValid();\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/WikiVectorStoreExample.java" : {
              "ensureBeanGetsCreated" : {
                "definition" : "@Test\nvoid ensureBeanGetsCreated() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore store = context.getBean(CassandraVectorStore.class);\n        Assertions.assertNotNull(store);\n        store.checkSchemaValid();\n        store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n    });\n}"
              },
              "search" : {
                "definition" : "@Test\nvoid search() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore store = context.getBean(CassandraVectorStore.class);\n        Assertions.assertNotNull(store);\n        store.checkSchemaValid();\n        var results = store.similaritySearch(SearchRequest.builder().query(\"Spring\").topK(1).build());\n        assertThat(results).hasSize(1);\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreIT.java" : {
              "ensureBeanGetsCreated" : {
                "definition" : "@Test\nvoid ensureBeanGetsCreated() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = context.getBean(CassandraVectorStore.class)) {\n            Assertions.assertNotNull(store);\n            store.checkSchemaValid();\n        }\n    });\n}"
              }
            },
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraRichSchemaVectorStoreIT.java" : {
              "ensureSchemaCreation" : {
                "definition" : "@Test\nvoid ensureSchemaCreation() {\n    this.contextRunner.run(context -> {\n        try (CassandraVectorStore store = createStore(context, false)) {\n            Assertions.assertNotNull(store);\n            store.checkSchemaValid();\n            store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n        }\n    });\n}"
              },
              "ensureSchemaNoCreation" : {
                "definition" : "@Test\nvoid ensureSchemaNoCreation() {\n    this.contextRunner.run(context -> {\n        executeCqlFile(context, \"test_wiki_full_schema.cql\");\n        var builder = createBuilder(context, List.of(), true, false);\n        Assertions.assertNotNull(builder);\n        var store = new CassandraVectorStore(builder);\n        try {\n            store.checkSchemaValid();\n            store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            CassandraVectorStore.dropKeyspace(builder);\n            executeCqlFile(context, \"test_wiki_partial_3_schema.cql\");\n            \n            IllegalStateException ise = Assertions.assertThrows(IllegalStateException.class, () -> createStore(context, List.of(), true, false));\n            Assertions.assertEquals(\"column all_minilm_l6_v2_embedding does not exist\", ise.getMessage());\n        } finally {\n            CassandraVectorStore.dropKeyspace(builder);\n            store.close();\n        }\n    });\n}"
              },
              "ensureSchemaPartialCreation" : {
                "definition" : "@Test\nvoid ensureSchemaPartialCreation() {\n    this.contextRunner.run(context -> {\n        int PARTIAL_FILES = 5;\n        for (int i = 0; i < PARTIAL_FILES; ++i) {\n            executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", i));\n            var builder = createBuilder(context, List.of(), false, false);\n            Assertions.assertNotNull(builder);\n            CassandraVectorStore.dropKeyspace(builder);\n            var store = builder.build();\n            try {\n                store.checkSchemaValid();\n                store.similaritySearch(SearchRequest.builder().query(\"1843\").topK(1).build());\n            } finally {\n                CassandraVectorStore.dropKeyspace(builder);\n                store.close();\n            }\n        }\n        \n        Assertions.assertThrows(IOException.class, () -> executeCqlFile(context, java.lang.String.format(\"test_wiki_partial_%d_schema.cql\", PARTIAL_FILES)));\n    });\n}"
              }
            }
          }
        }, {
          "name" : "ensureIndexesExists",
          "arguments" : [ ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "build",
            "arguments" : [ ],
            "body" : "@Override\npublic CassandraVectorStore build() {\n    if (this.session == null && this.sessionBuilder != null) {\n        this.session = this.sessionBuilder.build();\n        this.closeSessionOnClose = true;\n    }\n    Assert.notNull(this.session, \"Either session must be set directly or configured via sessionBuilder\");\n    return new CassandraVectorStore(this);\n}"
          }, {
            "name" : "andColumn",
            "arguments" : [ "this.schema.embedding" ],
            "body" : ""
          }, {
            "name" : "onTable",
            "arguments" : [ "this.schema.keyspace", "this.schema.table" ],
            "body" : ""
          }, {
            "name" : "custom",
            "arguments" : [ "\"StorageAttachedIndex\"" ],
            "body" : ""
          }, {
            "name" : "ifNotExists",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "createIndex",
            "arguments" : [ "this.schema.index" ],
            "body" : ""
          }, {
            "name" : "debug",
            "arguments" : [ "\"Executing {}\"", "indexStmt.getQuery()" ],
            "body" : ""
          }, {
            "name" : "getQuery",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "execute",
            "arguments" : [ "indexStmt" ],
            "body" : ""
          }, {
            "name" : "forEach",
            "arguments" : [ "metadata -> {\n    SimpleStatement indexStatement = SchemaBuilder.createIndex(String.format(\"%s_idx\", metadata.name())).ifNotExists().custom(\"StorageAttachedIndex\").onTable(this.schema.keyspace, this.schema.table).andColumn(metadata.name()).build();\n    logger.debug(\"Executing {}\", indexStatement.getQuery());\n    this.session.execute(indexStatement);\n}" ],
            "body" : ""
          }, {
            "name" : "filter",
            "arguments" : [ "cs -> cs.indexed()" ],
            "body" : ""
          }, {
            "name" : "concat",
            "arguments" : [ "this.schema.partitionKeys.stream()", "Stream.concat(this.schema.clusteringKeys.stream(), this.schema.metadataColumns.stream())" ],
            "body" : ""
          }, {
            "name" : "stream",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "concat",
            "arguments" : [ "this.schema.clusteringKeys.stream()", "this.schema.metadataColumns.stream()" ],
            "body" : ""
          }, {
            "name" : "stream",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "stream",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "indexed",
            "arguments" : [ ],
            "body" : "public boolean indexed() {\n    for (SchemaColumnTags t : this.tags) {\n        if (SchemaColumnTags.INDEXED == t) {\n            return true;\n        }\n    }\n    return false;\n}"
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : "@Override\npublic CassandraVectorStore build() {\n    if (this.session == null && this.sessionBuilder != null) {\n        this.session = this.sessionBuilder.build();\n        this.closeSessionOnClose = true;\n    }\n    Assert.notNull(this.session, \"Either session must be set directly or configured via sessionBuilder\");\n    return new CassandraVectorStore(this);\n}"
          }, {
            "name" : "andColumn",
            "arguments" : [ "metadata.name()" ],
            "body" : ""
          }, {
            "name" : "onTable",
            "arguments" : [ "this.schema.keyspace", "this.schema.table" ],
            "body" : ""
          }, {
            "name" : "custom",
            "arguments" : [ "\"StorageAttachedIndex\"" ],
            "body" : ""
          }, {
            "name" : "ifNotExists",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "createIndex",
            "arguments" : [ "String.format(\"%s_idx\", metadata.name())" ],
            "body" : ""
          }, {
            "name" : "format",
            "arguments" : [ "\"%s_idx\"", "metadata.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "debug",
            "arguments" : [ "\"Executing {}\"", "indexStatement.getQuery()" ],
            "body" : ""
          }, {
            "name" : "getQuery",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "execute",
            "arguments" : [ "indexStatement" ],
            "body" : ""
          } ],
          "usedEntities" : [ "SchemaBuilder", "logger", "indexStmt", "Stream", "cs", "String", "metadata", "indexStatement" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "private void ensureIndexesExists() {\n    SimpleStatement indexStmt = SchemaBuilder.createIndex(this.schema.index).ifNotExists().custom(\"StorageAttachedIndex\").onTable(this.schema.keyspace, this.schema.table).andColumn(this.schema.embedding).build();\n    logger.debug(\"Executing {}\", indexStmt.getQuery());\n    this.session.execute(indexStmt);\n    Stream.concat(this.schema.partitionKeys.stream(), Stream.concat(this.schema.clusteringKeys.stream(), this.schema.metadataColumns.stream())).filter(cs -> cs.indexed()).forEach(metadata -> {\n        SimpleStatement indexStatement = SchemaBuilder.createIndex(String.format(\"%s_idx\", metadata.name())).ifNotExists().custom(\"StorageAttachedIndex\").onTable(this.schema.keyspace, this.schema.table).andColumn(metadata.name()).build();\n        logger.debug(\"Executing {}\", indexStatement.getQuery());\n        this.session.execute(indexStatement);\n    });\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "ensureTableExists",
          "arguments" : [ "int vectorDimension" ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "isEmpty",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getTable",
            "arguments" : [ "this.schema.table" ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getKeyspace",
            "arguments" : [ "this.schema.keyspace" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "ifNotExists",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "createTable",
            "arguments" : [ "this.schema.keyspace", "this.schema.table" ],
            "body" : ""
          }, {
            "name" : "withPartitionKey",
            "arguments" : [ "partitionKey.name", "partitionKey.type" ],
            "body" : ""
          }, {
            "name" : "withClusteringColumn",
            "arguments" : [ "clusteringKey.name", "clusteringKey.type" ],
            "body" : ""
          }, {
            "name" : "withColumn",
            "arguments" : [ "this.schema.content", "DataTypes.TEXT" ],
            "body" : ""
          }, {
            "name" : "withColumn",
            "arguments" : [ "metadata.name()", "metadata.type()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "type",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "asCql",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "setLength",
            "arguments" : [ "tableStmt.length() - 1" ],
            "body" : ""
          }, {
            "name" : "length",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "\">)\"" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "vectorDimension" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "\" vector<float,\"" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "this.schema.embedding" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "','" ],
            "body" : ""
          }, {
            "name" : "debug",
            "arguments" : [ "\"Executing {}\"", "tableStmt.toString()" ],
            "body" : ""
          }, {
            "name" : "toString",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "execute",
            "arguments" : [ "tableStmt.toString()" ],
            "body" : ""
          }, {
            "name" : "toString",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "SchemaBuilder", "createTable", "createTableStart", "partitionKey", "clusteringKey", "DataTypes", "metadata", "tableStmt", "vectorDimension", "logger" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "private void ensureTableExists(int vectorDimension) {\n    if (this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).isEmpty()) {\n        CreateTable createTable = null;\n        CreateTableStart createTableStart = SchemaBuilder.createTable(this.schema.keyspace, this.schema.table).ifNotExists();\n        for (SchemaColumn partitionKey : this.schema.partitionKeys) {\n            createTable = (null != createTable ? createTable : createTableStart).withPartitionKey(partitionKey.name, partitionKey.type);\n        }\n        for (SchemaColumn clusteringKey : this.schema.clusteringKeys) {\n            createTable = createTable.withClusteringColumn(clusteringKey.name, clusteringKey.type);\n        }\n        createTable = createTable.withColumn(this.schema.content, DataTypes.TEXT);\n        for (SchemaColumn metadata : this.schema.metadataColumns) {\n            createTable = createTable.withColumn(metadata.name(), metadata.type());\n        }\n        \n        \n        \n        StringBuilder tableStmt = new StringBuilder(createTable.asCql());\n        tableStmt.setLength(tableStmt.length() - 1);\n        tableStmt.append(',').append(this.schema.embedding).append(\" vector<float,\").append(vectorDimension).append(\">)\");\n        logger.debug(\"Executing {}\", tableStmt.toString());\n        this.session.execute(tableStmt.toString());\n    }\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "ensureTableColumnsExist",
          "arguments" : [ "int vectorDimension" ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getTable",
            "arguments" : [ "this.schema.table" ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getKeyspace",
            "arguments" : [ "this.schema.keyspace" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "isEmpty",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getColumn",
            "arguments" : [ "this.schema.content" ],
            "body" : ""
          }, {
            "name" : "isEmpty",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getColumn",
            "arguments" : [ "this.schema.embedding" ],
            "body" : ""
          }, {
            "name" : "getColumn",
            "arguments" : [ "metadata.name()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "isPresent",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "checkArgument",
            "arguments" : [ "column.get().getType().equals(metadata.type())", "\"Cannot change type on metadata column %s from %s to %s\"", "metadata.name()", "column.get().getType()", "metadata.type()" ],
            "body" : ""
          }, {
            "name" : "equals",
            "arguments" : [ "metadata.type()" ],
            "body" : ""
          }, {
            "name" : "getType",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "type",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getType",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "type",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "add",
            "arguments" : [ "metadata" ],
            "body" : ""
          }, {
            "name" : "isEmpty",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "alterTable",
            "arguments" : [ "this.schema.keyspace", "this.schema.table" ],
            "body" : ""
          }, {
            "name" : "addColumn",
            "arguments" : [ "metadata.name()", "metadata.type()" ],
            "body" : ""
          }, {
            "name" : "name",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "type",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "addColumn",
            "arguments" : [ "this.schema.content", "DataTypes.TEXT" ],
            "body" : ""
          }, {
            "name" : "asCql",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "isEmpty",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "\" ADD (\"" ],
            "body" : ""
          }, {
            "name" : "setLength",
            "arguments" : [ "alterTableStmt.length() - 1" ],
            "body" : ""
          }, {
            "name" : "length",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "','" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "\">)\"" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "vectorDimension" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "\" vector<float,\"" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "this.schema.embedding" ],
            "body" : ""
          }, {
            "name" : "debug",
            "arguments" : [ "\"Executing {}\"", "alterTableStmt.toString()" ],
            "body" : ""
          }, {
            "name" : "toString",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "execute",
            "arguments" : [ "alterTableStmt.toString()" ],
            "body" : ""
          }, {
            "name" : "toString",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "build",
            "arguments" : [ ],
            "body" : "@Override\npublic CassandraVectorStore build() {\n    if (this.session == null && this.sessionBuilder != null) {\n        this.session = this.sessionBuilder.build();\n        this.closeSessionOnClose = true;\n    }\n    Assert.notNull(this.session, \"Either session must be set directly or configured via sessionBuilder\");\n    return new CassandraVectorStore(this);\n}"
          }, {
            "name" : "debug",
            "arguments" : [ "\"Executing {}\"", "stmt.getQuery()" ],
            "body" : ""
          }, {
            "name" : "getQuery",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "execute",
            "arguments" : [ "stmt" ],
            "body" : ""
          } ],
          "usedEntities" : [ "tableMetadata", "metadata", "column", "Preconditions", "newColumns", "addContent", "addEmbedding", "SchemaBuilder", "alterTable", "DataTypes", "alterTableStmt", "vectorDimension", "logger", "stmt" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "private void ensureTableColumnsExist(int vectorDimension) {\n    TableMetadata tableMetadata = this.session.getMetadata().getKeyspace(this.schema.keyspace).get().getTable(this.schema.table).get();\n    Set<SchemaColumn> newColumns = new HashSet<>();\n    boolean addContent = tableMetadata.getColumn(this.schema.content).isEmpty();\n    boolean addEmbedding = tableMetadata.getColumn(this.schema.embedding).isEmpty();\n    for (SchemaColumn metadata : this.schema.metadataColumns) {\n        Optional<ColumnMetadata> column = tableMetadata.getColumn(metadata.name());\n        if (column.isPresent()) {\n            Preconditions.checkArgument(column.get().getType().equals(metadata.type()), \"Cannot change type on metadata column %s from %s to %s\", metadata.name(), column.get().getType(), metadata.type());\n        } else {\n            newColumns.add(metadata);\n        }\n    }\n    if (!newColumns.isEmpty() || addContent || addEmbedding) {\n        AlterTableAddColumn alterTable = SchemaBuilder.alterTable(this.schema.keyspace, this.schema.table);\n        for (SchemaColumn metadata : newColumns) {\n            alterTable = alterTable.addColumn(metadata.name(), metadata.type());\n        }\n        if (addContent) {\n            alterTable = alterTable.addColumn(this.schema.content, DataTypes.TEXT);\n        }\n        if (addEmbedding) {\n            \n            StringBuilder alterTableStmt = new StringBuilder(((BuildableQuery) alterTable).asCql());\n            if (newColumns.isEmpty() && !addContent) {\n                alterTableStmt.append(\" ADD (\");\n            } else {\n                alterTableStmt.setLength(alterTableStmt.length() - 1);\n                alterTableStmt.append(',');\n            }\n            alterTableStmt.append(this.schema.embedding).append(\" vector<float,\").append(vectorDimension).append(\">)\");\n            logger.debug(\"Executing {}\", alterTableStmt.toString());\n            this.session.execute(alterTableStmt.toString());\n        } else {\n            SimpleStatement stmt = ((AlterTableAddColumnEnd) alterTable).build();\n            logger.debug(\"Executing {}\", stmt.getQuery());\n            this.session.execute(stmt);\n        }\n    }\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "getNativeClient",
          "arguments" : [ ],
          "accessModifier" : "public",
          "methodsCalled" : [ {
            "name" : "of",
            "arguments" : [ "client" ],
            "body" : ""
          } ],
          "usedEntities" : [ "Optional", "client" ],
          "annotations" : [ "Override" ],
          "returnType" : "Optional<T>",
          "comments" : null,
          "methodDefinition" : "@Override\npublic <T> Optional<T> getNativeClient() {\n    @SuppressWarnings(\"unchecked\")\n    T client = (T) this.session;\n    return Optional.of(client);\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStore.java",
          "test_exists" : true,
          "test_functions" : {
            "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/test/java/org/springframework/ai/vectorstore/cassandra/CassandraVectorStoreIT.java" : {
              "getNativeClientTest" : {
                "definition" : "@Test\nvoid getNativeClientTest() {\n    this.contextRunner.run(context -> {\n        CassandraVectorStore vectorStore = context.getBean(CassandraVectorStore.class);\n        Optional<CqlSession> nativeClient = vectorStore.getNativeClient();\n        assertThat(nativeClient).isPresent();\n    });\n}"
              }
            }
          }
        } ],
        "fields" : [ {
          "name" : "DEFAULT_KEYSPACE_NAME",
          "accessModifier" : "public,static,final",
          "value" : "\"springframework\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "DEFAULT_TABLE_NAME",
          "accessModifier" : "public,static,final",
          "value" : "\"ai_vector_store\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "DEFAULT_ID_NAME",
          "accessModifier" : "public,static,final",
          "value" : "\"id\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "DEFAULT_INDEX_SUFFIX",
          "accessModifier" : "public,static,final",
          "value" : "\"idx\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "DEFAULT_CONTENT_COLUMN_NAME",
          "accessModifier" : "public,static,final",
          "value" : "\"content\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "DEFAULT_EMBEDDING_COLUMN_NAME",
          "accessModifier" : "public,static,final",
          "value" : "\"embedding\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "DEFAULT_ADD_CONCURRENCY",
          "accessModifier" : "public,static,final",
          "value" : "16",
          "type" : "int",
          "comments" : null
        }, {
          "name" : "DRIVER_PROFILE_UPDATES",
          "accessModifier" : "public,static,final",
          "value" : "\"spring-ai-updates\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "DRIVER_PROFILE_SEARCH",
          "accessModifier" : "public,static,final",
          "value" : "\"spring-ai-search\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "QUERY_FORMAT",
          "accessModifier" : "private,static,final",
          "value" : "\"select %s,%s,%s%s from %s.%s ? order by %s ann of ? limit ?\"",
          "type" : "String",
          "comments" : null
        }, {
          "name" : "logger",
          "accessModifier" : "private,static,final",
          "value" : "LoggerFactory.getLogger(CassandraVectorStore.class)",
          "type" : "Logger",
          "comments" : null
        }, {
          "name" : "SIMILARITY_TYPE_MAPPING",
          "accessModifier" : "private,static,final",
          "value" : "Map.of(Similarity.COSINE, VectorStoreSimilarityMetric.COSINE, Similarity.EUCLIDEAN, VectorStoreSimilarityMetric.EUCLIDEAN, Similarity.DOT_PRODUCT, VectorStoreSimilarityMetric.DOT)",
          "type" : "Map<Similarity,VectorStoreSimilarityMetric>",
          "comments" : null
        }, {
          "name" : "session",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "CqlSession",
          "comments" : null
        }, {
          "name" : "schema",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "Schema",
          "comments" : null
        }, {
          "name" : "disallowSchemaChanges",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "boolean",
          "comments" : null
        }, {
          "name" : "filterExpressionConverter",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "FilterExpressionConverter",
          "comments" : null
        }, {
          "name" : "documentIdTranslator",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "DocumentIdTranslator",
          "comments" : null
        }, {
          "name" : "primaryKeyTranslator",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "PrimaryKeyTranslator",
          "comments" : null
        }, {
          "name" : "executor",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "Executor",
          "comments" : null
        }, {
          "name" : "closeSessionOnClose",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "boolean",
          "comments" : null
        }, {
          "name" : "addStmts",
          "accessModifier" : "private,final",
          "value" : "new ConcurrentHashMap<>()",
          "type" : "ConcurrentMap<Set<String>,PreparedStatement>",
          "comments" : null
        }, {
          "name" : "deleteStmt",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "PreparedStatement",
          "comments" : null
        }, {
          "name" : "similarityStmt",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "String",
          "comments" : null
        }, {
          "name" : "similarity",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "Similarity",
          "comments" : null
        } ],
        "constructors" : [ {
          "name" : "CassandraVectorStore",
          "arguments" : [ "Builder builder" ],
          "accessModifier" : "protected",
          "methodsCalled" : [ {
            "name" : "notNull",
            "arguments" : [ "builder.session", "\"Session must not be null\"" ],
            "body" : ""
          }, {
            "name" : "buildSchema",
            "arguments" : [ ],
            "body" : "Schema buildSchema() {\n    if (this.indexName == null) {\n        this.indexName = String.format(\"%s_%s_%s\", this.table, this.embeddingColumnName, DEFAULT_INDEX_SUFFIX);\n    }\n    validateSchema();\n    return new Schema(this.keyspace, this.table, this.partitionKeys, this.clusteringKeys, this.contentColumnName, this.embeddingColumnName, this.indexName, this.metadataColumns);\n}"
          }, {
            "name" : "newFixedThreadPool",
            "arguments" : [ "builder.fixedThreadPoolExecutorSize" ],
            "body" : ""
          }, {
            "name" : "ensureSchemaExists",
            "arguments" : [ "embeddingModel.dimensions()" ],
            "body" : "void ensureSchemaExists(int vectorDimension) {\n    if (!this.disallowSchemaChanges) {\n        SchemaUtil.ensureKeyspaceExists(this.session, this.schema.keyspace);\n        ensureTableExists(vectorDimension);\n        ensureTableColumnsExist(vectorDimension);\n        ensureIndexesExists();\n        SchemaUtil.checkSchemaAgreement(this.session);\n    } else {\n        checkSchemaValid(vectorDimension);\n    }\n}"
          }, {
            "name" : "dimensions",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "prepareAddStatement",
            "arguments" : [ "Set.of()" ],
            "body" : "private PreparedStatement prepareAddStatement(Set<String> metadataFields) {\n    \n    Set<String> fieldsThatAreColumns = new HashSet<>(this.schema.metadataColumns().stream().map(mc -> mc.name()).filter(mc -> metadataFields.contains(mc)).toList());\n    return this.addStmts.computeIfAbsent(fieldsThatAreColumns, fields -> {\n        RegularInsert stmt = null;\n        InsertInto stmtStart = QueryBuilder.insertInto(this.schema.keyspace(), this.schema.table());\n        for (var c : this.schema.partitionKeys()) {\n            stmt = (null != stmt ? stmt : stmtStart).value(c.name(), QueryBuilder.bindMarker(c.name()));\n        }\n        for (var c : this.schema.clusteringKeys()) {\n            stmt = stmt.value(c.name(), QueryBuilder.bindMarker(c.name()));\n        }\n        stmt = stmt.value(this.schema.content(), QueryBuilder.bindMarker(this.schema.content())).value(this.schema.embedding(), QueryBuilder.bindMarker(this.schema.embedding()));\n        for (String metadataField : fields) {\n            stmt = stmt.value(metadataField, QueryBuilder.bindMarker(metadataField));\n        }\n        return this.session.prepare(stmt.build());\n    });\n}"
          }, {
            "name" : "of",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "prepareDeleteStatement",
            "arguments" : [ ],
            "body" : "private PreparedStatement prepareDeleteStatement() {\n    Delete stmt = null;\n    DeleteSelection stmtStart = QueryBuilder.deleteFrom(this.schema.keyspace(), this.schema.table());\n    for (var c : this.schema.partitionKeys()) {\n        stmt = (null != stmt ? stmt : stmtStart).whereColumn(c.name()).isEqualTo(QueryBuilder.bindMarker(c.name()));\n    }\n    for (var c : this.schema.clusteringKeys()) {\n        stmt = stmt.whereColumn(c.name()).isEqualTo(QueryBuilder.bindMarker(c.name()));\n    }\n    return this.session.prepare(stmt.build());\n}"
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getTable",
            "arguments" : [ "this.schema.table()" ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getKeyspace",
            "arguments" : [ "this.schema.keyspace()" ],
            "body" : ""
          }, {
            "name" : "getMetadata",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "keyspace",
            "arguments" : [ ],
            "body" : "public Builder keyspace(String keyspace) {\n    Assert.hasText(keyspace, \"Keyspace must not be null or empty\");\n    this.keyspace = keyspace;\n    return this;\n}"
          }, {
            "name" : "table",
            "arguments" : [ ],
            "body" : "public Builder table(String table) {\n    Assert.hasText(table, \"Table must not be null or empty\");\n    this.table = table;\n    return this;\n}"
          }, {
            "name" : "getIndexSimilarity",
            "arguments" : [ "cassandraMetadata" ],
            "body" : "private Similarity getIndexSimilarity(TableMetadata metadata) {\n    return Similarity.valueOf(metadata.getIndex(this.schema.index()).get().getOptions().getOrDefault(\"similarity_function\", \"COSINE\").toUpperCase());\n}"
          }, {
            "name" : "similaritySearchStatement",
            "arguments" : [ ],
            "body" : "private String similaritySearchStatement() {\n    StringBuilder ids = new StringBuilder();\n    for (var m : this.schema.partitionKeys()) {\n        ids.append(m.name()).append(',');\n    }\n    for (var m : this.schema.clusteringKeys()) {\n        ids.append(m.name()).append(',');\n    }\n    ids.deleteCharAt(ids.length() - 1);\n    String similarityFunction = new StringBuilder(\"similarity_\").append(this.similarity.toString().toLowerCase()).append('(').append(this.schema.embedding()).append(\",?)\").toString();\n    StringBuilder extraSelectFields = new StringBuilder();\n    for (var m : this.schema.metadataColumns()) {\n        extraSelectFields.append(',').append(m.name());\n    }\n    \n    String query = String.format(QUERY_FORMAT, similarityFunction, ids.toString(), this.schema.content(), extraSelectFields.toString(), this.schema.keyspace(), this.schema.table(), this.schema.embedding());\n    query = query.replace(\"?\", \"%s\");\n    logger.debug(\"preparing {}\", query);\n    return query;\n}"
          }, {
            "name" : "values",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getColumns",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "builder", "Assert", "Executors", "embeddingModel", "Set", "cassandraMetadata" ],
          "annotations" : [ ],
          "comments" : null,
          "methodDefinition" : "protected CassandraVectorStore(Builder builder) {\n    super(builder);\n    Assert.notNull(builder.session, \"Session must not be null\");\n    this.session = builder.session;\n    this.schema = builder.buildSchema();\n    this.disallowSchemaChanges = builder.disallowSchemaChanges;\n    this.documentIdTranslator = builder.documentIdTranslator;\n    this.primaryKeyTranslator = builder.primaryKeyTranslator;\n    this.executor = Executors.newFixedThreadPool(builder.fixedThreadPoolExecutorSize);\n    this.closeSessionOnClose = builder.closeSessionOnClose;\n    ensureSchemaExists(embeddingModel.dimensions());\n    prepareAddStatement(Set.of());\n    this.deleteStmt = prepareDeleteStatement();\n    TableMetadata cassandraMetadata = this.session.getMetadata().getKeyspace(this.schema.keyspace()).get().getTable(this.schema.table()).get();\n    this.similarity = getIndexSimilarity(cassandraMetadata);\n    this.similarityStmt = similaritySearchStatement();\n    this.filterExpressionConverter = builder.filterExpressionConverter != null ? builder.filterExpressionConverter : new CassandraFilterExpressionConverter(cassandraMetadata.getColumns().values());\n}"
        } ],
        "extends" : [ "AbstractObservationVectorStore" ],
        "implements" : [ "AutoCloseable" ],
        "nestedClass" : [ {
          "name" : "DocumentIdTranslator",
          "comments" : "Given a string document id, return the value for each primary key column.\n\nIt is a requirement that an empty {@code List<Object>} returns an example formatted\nid",
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ ],
          "constructors" : [ ],
          "extends" : null,
          "implements" : null,
          "nestedClass" : null,
          "accessSpecifier" : "public",
          "records" : null
        }, {
          "name" : "PrimaryKeyTranslator",
          "comments" : "Given a list of primary key column values, return the document id.",
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ ],
          "constructors" : [ ],
          "extends" : null,
          "implements" : null,
          "nestedClass" : null,
          "accessSpecifier" : "public",
          "records" : null
        }, {
          "name" : "Builder",
          "comments" : "Builder for the Cassandra vector store.\n\nAll metadata columns configured to the store will be fetched and added to all\nqueried documents.\n\nTo filter expression search against a metadata column configure it with\nSchemaColumnTags.INDEXED\n\nThe Cassandra Java Driver is configured via the application.conf resource found in\nthe classpath. See\nhttps://github.com/apache/cassandra-java-driver/tree/4.x/manual/core/configuration",
          "annotations" : [ ],
          "methods" : [ {
            "name" : "session",
            "arguments" : [ "CqlSession session" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "notNull",
              "arguments" : [ "session", "\"Session must not be null\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Assert", "session" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : "Sets the CQL session.",
            "methodDefinition" : "public Builder session(CqlSession session) {\n    Assert.notNull(session, \"Session must not be null\");\n    this.session = session;\n    return this;\n}"
          }, {
            "name" : "fixedThreadPoolExecutorSize",
            "arguments" : [ "int threads" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "checkArgument",
              "arguments" : [ "0 < threads" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Preconditions", "threads" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : "Executor to use when adding documents. The hotspot is the call to the\nembeddingModel. For remote transformers you probably want a higher value to\nutilize network. For local transformers you probably want a lower value to\navoid saturation.",
            "methodDefinition" : "public Builder fixedThreadPoolExecutorSize(int threads) {\n    Preconditions.checkArgument(0 < threads);\n    this.fixedThreadPoolExecutorSize = threads;\n    return this;\n}"
          }, {
            "name" : "keyspace",
            "arguments" : [ "String keyspace" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "hasText",
              "arguments" : [ "keyspace", "\"Keyspace must not be null or empty\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Assert", "keyspace" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : "Sets the keyspace name.",
            "methodDefinition" : "public Builder keyspace(String keyspace) {\n    Assert.hasText(keyspace, \"Keyspace must not be null or empty\");\n    this.keyspace = keyspace;\n    return this;\n}"
          }, {
            "name" : "contactPoint",
            "arguments" : [ "InetSocketAddress contactPoint" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "state",
              "arguments" : [ "this.session == null", "\"Cannot call addContactPoint(..) when session is already set\"" ],
              "body" : ""
            }, {
              "name" : "addContactPoint",
              "arguments" : [ "contactPoint" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Assert", "contactPoint" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : "Adds a contact point to the session builder.",
            "methodDefinition" : "public Builder contactPoint(InetSocketAddress contactPoint) {\n    Assert.state(this.session == null, \"Cannot call addContactPoint(..) when session is already set\");\n    if (this.sessionBuilder == null) {\n        this.sessionBuilder = new CqlSessionBuilder();\n    }\n    this.sessionBuilder.addContactPoint(contactPoint);\n    return this;\n}"
          }, {
            "name" : "localDatacenter",
            "arguments" : [ "String localDatacenter" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "state",
              "arguments" : [ "this.session == null", "\"Cannot call withLocalDatacenter(..) when session is already set\"" ],
              "body" : ""
            }, {
              "name" : "withLocalDatacenter",
              "arguments" : [ "localDatacenter" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Assert", "localDatacenter" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : "Sets the local datacenter for the session builder.",
            "methodDefinition" : "public Builder localDatacenter(String localDatacenter) {\n    Assert.state(this.session == null, \"Cannot call withLocalDatacenter(..) when session is already set\");\n    if (this.sessionBuilder == null) {\n        this.sessionBuilder = new CqlSessionBuilder();\n    }\n    this.sessionBuilder.withLocalDatacenter(localDatacenter);\n    return this;\n}"
          }, {
            "name" : "table",
            "arguments" : [ "String table" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "hasText",
              "arguments" : [ "table", "\"Table must not be null or empty\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Assert", "table" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : "Sets the table name.",
            "methodDefinition" : "public Builder table(String table) {\n    Assert.hasText(table, \"Table must not be null or empty\");\n    this.table = table;\n    return this;\n}"
          }, {
            "name" : "partitionKeys",
            "arguments" : [ "List<SchemaColumn> partitionKeys" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "notEmpty",
              "arguments" : [ "partitionKeys", "\"Partition keys must not be null or empty\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Assert", "partitionKeys" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : "Sets the partition keys.",
            "methodDefinition" : "public Builder partitionKeys(List<SchemaColumn> partitionKeys) {\n    Assert.notEmpty(partitionKeys, \"Partition keys must not be null or empty\");\n    this.partitionKeys = partitionKeys;\n    return this;\n}"
          }, {
            "name" : "clusteringKeys",
            "arguments" : [ "List<SchemaColumn> clusteringKeys" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "of",
              "arguments" : [ ],
              "body" : ""
            } ],
            "usedEntities" : [ "clusteringKeys", "List" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : "Sets the clustering keys.",
            "methodDefinition" : "public Builder clusteringKeys(List<SchemaColumn> clusteringKeys) {\n    this.clusteringKeys = clusteringKeys != null ? clusteringKeys : List.of();\n    return this;\n}"
          }, {
            "name" : "indexName",
            "arguments" : [ "String indexName" ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ "indexName" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : "Sets the index name.",
            "methodDefinition" : "public Builder indexName(String indexName) {\n    this.indexName = indexName;\n    return this;\n}"
          }, {
            "name" : "disallowSchemaChanges",
            "arguments" : [ "boolean disallowSchemaChanges" ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ "disallowSchemaChanges" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : "Sets whether to disallow schema changes.",
            "methodDefinition" : "public Builder disallowSchemaChanges(boolean disallowSchemaChanges) {\n    this.disallowSchemaChanges = disallowSchemaChanges;\n    return this;\n}"
          }, {
            "name" : "filterExpressionConverter",
            "arguments" : [ "FilterExpressionConverter converter" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "notNull",
              "arguments" : [ "converter", "\"FilterExpressionConverter must not be null\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Assert", "converter" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : "Sets the filter expression converter.",
            "methodDefinition" : "public Builder filterExpressionConverter(FilterExpressionConverter converter) {\n    Assert.notNull(converter, \"FilterExpressionConverter must not be null\");\n    this.filterExpressionConverter = converter;\n    return this;\n}"
          }, {
            "name" : "documentIdTranslator",
            "arguments" : [ "DocumentIdTranslator translator" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "notNull",
              "arguments" : [ "translator", "\"DocumentIdTranslator must not be null\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Assert", "translator" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : "Sets the document ID translator.",
            "methodDefinition" : "public Builder documentIdTranslator(DocumentIdTranslator translator) {\n    Assert.notNull(translator, \"DocumentIdTranslator must not be null\");\n    this.documentIdTranslator = translator;\n    return this;\n}"
          }, {
            "name" : "contentColumnName",
            "arguments" : [ "String contentColumnName" ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ "contentColumnName" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder contentColumnName(String contentColumnName) {\n    this.contentColumnName = contentColumnName;\n    return this;\n}"
          }, {
            "name" : "embeddingColumnName",
            "arguments" : [ "String embeddingColumnName" ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ "embeddingColumnName" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder embeddingColumnName(String embeddingColumnName) {\n    this.embeddingColumnName = embeddingColumnName;\n    return this;\n}"
          }, {
            "name" : "addMetadataColumns",
            "arguments" : [ "SchemaColumn... columns" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "addMetadataColumn",
              "arguments" : [ "f" ],
              "body" : "public Builder addMetadataColumn(SchemaColumn column) {\n    Preconditions.checkArgument(this.metadataColumns.stream().noneMatch(sc -> sc.name().equals(column.name())), \"A metadata column with name %s has already been added\", column.name());\n    this.metadataColumns.add(column);\n    return this;\n}"
            } ],
            "usedEntities" : [ "columns", "builder", "f" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder addMetadataColumns(SchemaColumn... columns) {\n    Builder builder = this;\n    for (SchemaColumn f : columns) {\n        builder = builder.addMetadataColumn(f);\n    }\n    return builder;\n}"
          }, {
            "name" : "addMetadataColumns",
            "arguments" : [ "List<SchemaColumn> columns" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "addAll",
              "arguments" : [ "columns" ],
              "body" : ""
            } ],
            "usedEntities" : [ "columns", "builder" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder addMetadataColumns(List<SchemaColumn> columns) {\n    Builder builder = this;\n    this.metadataColumns.addAll(columns);\n    return builder;\n}"
          }, {
            "name" : "addMetadataColumn",
            "arguments" : [ "SchemaColumn column" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "checkArgument",
              "arguments" : [ "this.metadataColumns.stream().noneMatch(sc -> sc.name().equals(column.name()))", "\"A metadata column with name %s has already been added\"", "column.name()" ],
              "body" : ""
            }, {
              "name" : "noneMatch",
              "arguments" : [ "sc -> sc.name().equals(column.name())" ],
              "body" : ""
            }, {
              "name" : "stream",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "equals",
              "arguments" : [ "column.name()" ],
              "body" : ""
            }, {
              "name" : "name",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "name",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "name",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "add",
              "arguments" : [ "column" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Preconditions", "sc", "column" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder addMetadataColumn(SchemaColumn column) {\n    Preconditions.checkArgument(this.metadataColumns.stream().noneMatch(sc -> sc.name().equals(column.name())), \"A metadata column with name %s has already been added\", column.name());\n    this.metadataColumns.add(column);\n    return this;\n}"
          }, {
            "name" : "primaryKeyTranslator",
            "arguments" : [ "PrimaryKeyTranslator translator" ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "notNull",
              "arguments" : [ "translator", "\"PrimaryKeyTranslator must not be null\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Assert", "translator" ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : "Sets the primary key translator.",
            "methodDefinition" : "public Builder primaryKeyTranslator(PrimaryKeyTranslator translator) {\n    Assert.notNull(translator, \"PrimaryKeyTranslator must not be null\");\n    this.primaryKeyTranslator = translator;\n    return this;\n}"
          }, {
            "name" : "returnEmbeddings",
            "arguments" : [ "boolean returnEmbeddings" ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "returnType" : "Builder",
            "comments" : null,
            "methodDefinition" : "public Builder returnEmbeddings(boolean returnEmbeddings) {\n    this.returnEmbeddings = true;\n    return this;\n}"
          }, {
            "name" : "buildSchema",
            "arguments" : [ ],
            "accessModifier" : "",
            "methodsCalled" : [ {
              "name" : "format",
              "arguments" : [ "\"%s_%s_%s\"", "this.table", "this.embeddingColumnName", "DEFAULT_INDEX_SUFFIX" ],
              "body" : ""
            }, {
              "name" : "validateSchema",
              "arguments" : [ ],
              "body" : "private void validateSchema() {\n    for (SchemaColumn metadata : this.metadataColumns) {\n        Assert.isTrue(!this.partitionKeys.stream().anyMatch(c -> c.name().equals(metadata.name())), \"metadataColumn \" + metadata.name() + \" cannot have same name as a partition key\");\n        Assert.isTrue(!this.clusteringKeys.stream().anyMatch(c -> c.name().equals(metadata.name())), \"metadataColumn \" + metadata.name() + \" cannot have same name as a clustering key\");\n        Assert.isTrue(!metadata.name().equals(this.contentColumnName), \"metadataColumn \" + metadata.name() + \" cannot have same name as content column name\");\n        Assert.isTrue(!metadata.name().equals(this.embeddingColumnName), \"metadataColumn \" + metadata.name() + \" cannot have same name as embedding column name\");\n    }\n    int primaryKeyColumnsCount = this.partitionKeys.size() + this.clusteringKeys.size();\n    String exampleId = this.primaryKeyTranslator.apply(Collections.emptyList());\n    List<Object> testIdTranslation = this.documentIdTranslator.apply(exampleId);\n    Assert.isTrue(testIdTranslation.size() == primaryKeyColumnsCount, \"documentIdTranslator results length \" + testIdTranslation.size() + \" doesn't match number of primary key columns \" + primaryKeyColumnsCount);\n    Assert.isTrue(exampleId.equals(this.primaryKeyTranslator.apply(this.documentIdTranslator.apply(exampleId))), \"primaryKeyTranslator is not an inverse function to documentIdTranslator\");\n}"
            } ],
            "usedEntities" : [ "String", "DEFAULT_INDEX_SUFFIX" ],
            "annotations" : [ ],
            "returnType" : "Schema",
            "comments" : null,
            "methodDefinition" : "Schema buildSchema() {\n    if (this.indexName == null) {\n        this.indexName = String.format(\"%s_%s_%s\", this.table, this.embeddingColumnName, DEFAULT_INDEX_SUFFIX);\n    }\n    validateSchema();\n    return new Schema(this.keyspace, this.table, this.partitionKeys, this.clusteringKeys, this.contentColumnName, this.embeddingColumnName, this.indexName, this.metadataColumns);\n}"
          }, {
            "name" : "validateSchema",
            "arguments" : [ ],
            "accessModifier" : "private",
            "methodsCalled" : [ {
              "name" : "isTrue",
              "arguments" : [ "!this.partitionKeys.stream().anyMatch(c -> c.name().equals(metadata.name()))", "\"metadataColumn \" + metadata.name() + \" cannot have same name as a partition key\"" ],
              "body" : ""
            }, {
              "name" : "anyMatch",
              "arguments" : [ "c -> c.name().equals(metadata.name())" ],
              "body" : ""
            }, {
              "name" : "stream",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "equals",
              "arguments" : [ "metadata.name()" ],
              "body" : ""
            }, {
              "name" : "name",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "name",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "name",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "isTrue",
              "arguments" : [ "!this.clusteringKeys.stream().anyMatch(c -> c.name().equals(metadata.name()))", "\"metadataColumn \" + metadata.name() + \" cannot have same name as a clustering key\"" ],
              "body" : ""
            }, {
              "name" : "anyMatch",
              "arguments" : [ "c -> c.name().equals(metadata.name())" ],
              "body" : ""
            }, {
              "name" : "stream",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "equals",
              "arguments" : [ "metadata.name()" ],
              "body" : ""
            }, {
              "name" : "name",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "name",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "name",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "isTrue",
              "arguments" : [ "!metadata.name().equals(this.contentColumnName)", "\"metadataColumn \" + metadata.name() + \" cannot have same name as content column name\"" ],
              "body" : ""
            }, {
              "name" : "equals",
              "arguments" : [ "this.contentColumnName" ],
              "body" : ""
            }, {
              "name" : "name",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "name",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "isTrue",
              "arguments" : [ "!metadata.name().equals(this.embeddingColumnName)", "\"metadataColumn \" + metadata.name() + \" cannot have same name as embedding column name\"" ],
              "body" : ""
            }, {
              "name" : "equals",
              "arguments" : [ "this.embeddingColumnName" ],
              "body" : ""
            }, {
              "name" : "name",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "name",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "size",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "size",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "apply",
              "arguments" : [ "Collections.emptyList()" ],
              "body" : ""
            }, {
              "name" : "emptyList",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "apply",
              "arguments" : [ "exampleId" ],
              "body" : ""
            }, {
              "name" : "isTrue",
              "arguments" : [ "testIdTranslation.size() == primaryKeyColumnsCount", "\"documentIdTranslator results length \" + testIdTranslation.size() + \" doesn't match number of primary key columns \" + primaryKeyColumnsCount" ],
              "body" : ""
            }, {
              "name" : "size",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "size",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "isTrue",
              "arguments" : [ "exampleId.equals(this.primaryKeyTranslator.apply(this.documentIdTranslator.apply(exampleId)))", "\"primaryKeyTranslator is not an inverse function to documentIdTranslator\"" ],
              "body" : ""
            }, {
              "name" : "equals",
              "arguments" : [ "this.primaryKeyTranslator.apply(this.documentIdTranslator.apply(exampleId))" ],
              "body" : ""
            }, {
              "name" : "apply",
              "arguments" : [ "this.documentIdTranslator.apply(exampleId)" ],
              "body" : ""
            }, {
              "name" : "apply",
              "arguments" : [ "exampleId" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Assert", "c", "metadata", "Collections", "exampleId", "testIdTranslation", "primaryKeyColumnsCount" ],
            "annotations" : [ ],
            "returnType" : "void",
            "comments" : null,
            "methodDefinition" : "private void validateSchema() {\n    for (SchemaColumn metadata : this.metadataColumns) {\n        Assert.isTrue(!this.partitionKeys.stream().anyMatch(c -> c.name().equals(metadata.name())), \"metadataColumn \" + metadata.name() + \" cannot have same name as a partition key\");\n        Assert.isTrue(!this.clusteringKeys.stream().anyMatch(c -> c.name().equals(metadata.name())), \"metadataColumn \" + metadata.name() + \" cannot have same name as a clustering key\");\n        Assert.isTrue(!metadata.name().equals(this.contentColumnName), \"metadataColumn \" + metadata.name() + \" cannot have same name as content column name\");\n        Assert.isTrue(!metadata.name().equals(this.embeddingColumnName), \"metadataColumn \" + metadata.name() + \" cannot have same name as embedding column name\");\n    }\n    int primaryKeyColumnsCount = this.partitionKeys.size() + this.clusteringKeys.size();\n    String exampleId = this.primaryKeyTranslator.apply(Collections.emptyList());\n    List<Object> testIdTranslation = this.documentIdTranslator.apply(exampleId);\n    Assert.isTrue(testIdTranslation.size() == primaryKeyColumnsCount, \"documentIdTranslator results length \" + testIdTranslation.size() + \" doesn't match number of primary key columns \" + primaryKeyColumnsCount);\n    Assert.isTrue(exampleId.equals(this.primaryKeyTranslator.apply(this.documentIdTranslator.apply(exampleId))), \"primaryKeyTranslator is not an inverse function to documentIdTranslator\");\n}"
          }, {
            "name" : "build",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "build",
              "arguments" : [ ],
              "body" : "@Override\npublic CassandraVectorStore build() {\n    if (this.session == null && this.sessionBuilder != null) {\n        this.session = this.sessionBuilder.build();\n        this.closeSessionOnClose = true;\n    }\n    Assert.notNull(this.session, \"Either session must be set directly or configured via sessionBuilder\");\n    return new CassandraVectorStore(this);\n}"
            }, {
              "name" : "notNull",
              "arguments" : [ "this.session", "\"Either session must be set directly or configured via sessionBuilder\"" ],
              "body" : ""
            } ],
            "usedEntities" : [ "Assert" ],
            "annotations" : [ "Override" ],
            "returnType" : "CassandraVectorStore",
            "comments" : null,
            "methodDefinition" : "@Override\npublic CassandraVectorStore build() {\n    if (this.session == null && this.sessionBuilder != null) {\n        this.session = this.sessionBuilder.build();\n        this.closeSessionOnClose = true;\n    }\n    Assert.notNull(this.session, \"Either session must be set directly or configured via sessionBuilder\");\n    return new CassandraVectorStore(this);\n}"
          } ],
          "fields" : [ {
            "name" : "session",
            "accessModifier" : "private",
            "value" : null,
            "type" : "CqlSession",
            "comments" : null
          }, {
            "name" : "sessionBuilder",
            "accessModifier" : "private",
            "value" : null,
            "type" : "CqlSessionBuilder",
            "comments" : null
          }, {
            "name" : "closeSessionOnClose",
            "accessModifier" : "private",
            "value" : null,
            "type" : "boolean",
            "comments" : null
          }, {
            "name" : "keyspace",
            "accessModifier" : "private",
            "value" : "DEFAULT_KEYSPACE_NAME",
            "type" : "String",
            "comments" : null
          }, {
            "name" : "table",
            "accessModifier" : "private",
            "value" : "DEFAULT_TABLE_NAME",
            "type" : "String",
            "comments" : null
          }, {
            "name" : "partitionKeys",
            "accessModifier" : "private",
            "value" : "List.of(new SchemaColumn(DEFAULT_ID_NAME, DataTypes.TEXT))",
            "type" : "List<SchemaColumn>",
            "comments" : null
          }, {
            "name" : "clusteringKeys",
            "accessModifier" : "private",
            "value" : "List.of()",
            "type" : "List<SchemaColumn>",
            "comments" : null
          }, {
            "name" : "indexName",
            "accessModifier" : "private",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "contentColumnName",
            "accessModifier" : "private",
            "value" : "DEFAULT_CONTENT_COLUMN_NAME",
            "type" : "String",
            "comments" : null
          }, {
            "name" : "embeddingColumnName",
            "accessModifier" : "private",
            "value" : "DEFAULT_EMBEDDING_COLUMN_NAME",
            "type" : "String",
            "comments" : null
          }, {
            "name" : "metadataColumns",
            "accessModifier" : "private",
            "value" : "new HashSet<>()",
            "type" : "Set<SchemaColumn>",
            "comments" : null
          }, {
            "name" : "disallowSchemaChanges",
            "accessModifier" : "private",
            "value" : "false",
            "type" : "boolean",
            "comments" : null
          }, {
            "name" : "fixedThreadPoolExecutorSize",
            "accessModifier" : "private",
            "value" : "DEFAULT_ADD_CONCURRENCY",
            "type" : "int",
            "comments" : null
          }, {
            "name" : "filterExpressionConverter",
            "accessModifier" : "private",
            "value" : null,
            "type" : "FilterExpressionConverter",
            "comments" : null
          }, {
            "name" : "documentIdTranslator",
            "accessModifier" : "private",
            "value" : "(String id) -> List.of(id)",
            "type" : "DocumentIdTranslator",
            "comments" : null
          }, {
            "name" : "primaryKeyTranslator",
            "accessModifier" : "private",
            "value" : "(List<Object> primaryKeyColumns) -> {\n    if (primaryKeyColumns.isEmpty()) {\n        return \"test\";\n    }\n    Preconditions.checkArgument(1 == primaryKeyColumns.size());\n    return (String) primaryKeyColumns.get(0);\n}",
            "type" : "PrimaryKeyTranslator",
            "comments" : null
          }, {
            "name" : "returnEmbeddings",
            "accessModifier" : "private",
            "value" : "false",
            "type" : "boolean",
            "comments" : null
          } ],
          "constructors" : [ {
            "name" : "Builder",
            "arguments" : [ "EmbeddingModel embeddingModel" ],
            "accessModifier" : "private",
            "methodsCalled" : [ ],
            "usedEntities" : [ "embeddingModel" ],
            "annotations" : [ ],
            "comments" : null,
            "methodDefinition" : "private Builder(EmbeddingModel embeddingModel) {\n    super(embeddingModel);\n}"
          } ],
          "extends" : null,
          "implements" : null,
          "nestedClass" : null,
          "accessSpecifier" : "public , static",
          "records" : null
        } ],
        "accessSpecifier" : "public",
        "records" : [ {
          "name" : "Schema",
          "comments" : null,
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ {
            "name" : "keyspace",
            "accessModifier" : "public",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "table",
            "accessModifier" : "public",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "partitionKeys",
            "accessModifier" : "public",
            "value" : null,
            "type" : "List<SchemaColumn>",
            "comments" : null
          }, {
            "name" : "clusteringKeys",
            "accessModifier" : "public",
            "value" : null,
            "type" : "List<SchemaColumn>",
            "comments" : null
          }, {
            "name" : "content",
            "accessModifier" : "public",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "embedding",
            "accessModifier" : "public",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "index",
            "accessModifier" : "public",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "metadataColumns",
            "accessModifier" : "public",
            "value" : null,
            "type" : "Set<SchemaColumn>",
            "comments" : null
          } ],
          "constructors" : [ ],
          "extends" : null,
          "implements" : null,
          "nestedClass" : null,
          "accessSpecifier" : "",
          "records" : null
        }, {
          "name" : "SchemaColumn",
          "comments" : null,
          "annotations" : [ ],
          "methods" : [ {
            "name" : "javaType",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ {
              "name" : "getJavaType",
              "arguments" : [ ],
              "body" : ""
            }, {
              "name" : "codecFor",
              "arguments" : [ "this.type" ],
              "body" : ""
            } ],
            "usedEntities" : [ "CodecRegistry" ],
            "annotations" : [ ],
            "returnType" : "GenericType<Object>",
            "comments" : null,
            "methodDefinition" : "public GenericType<Object> javaType() {\n    return CodecRegistry.DEFAULT.codecFor(this.type).getJavaType();\n}"
          }, {
            "name" : "indexed",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ "SchemaColumnTags", "t" ],
            "annotations" : [ ],
            "returnType" : "boolean",
            "comments" : null,
            "methodDefinition" : "public boolean indexed() {\n    for (SchemaColumnTags t : this.tags) {\n        if (SchemaColumnTags.INDEXED == t) {\n            return true;\n        }\n    }\n    return false;\n}"
          } ],
          "fields" : [ {
            "name" : "name",
            "accessModifier" : "public",
            "value" : null,
            "type" : "String",
            "comments" : null
          }, {
            "name" : "type",
            "accessModifier" : "public",
            "value" : null,
            "type" : "DataType",
            "comments" : null
          }, {
            "name" : "tags",
            "accessModifier" : "public",
            "value" : null,
            "type" : "SchemaColumnTags",
            "comments" : null
          } ],
          "constructors" : [ ],
          "extends" : null,
          "implements" : null,
          "nestedClass" : null,
          "accessSpecifier" : "public",
          "records" : null
        } ]
      } ],
      "records" : [ ],
      "samePackageClasses" : [ ]
    },
    "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraFilterExpressionConverter.java" : {
      "imports" : [ {
        "dereferencedParts" : [ ],
        "name" : "java.util.Collection"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.Map"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.Optional"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.function.Function"
      }, {
        "dereferencedParts" : [ ],
        "name" : "java.util.stream.Collectors"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.metadata.schema.ColumnMetadata"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.type.DataTypes"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.api.core.type.codec.registry.CodecRegistry"
      }, {
        "dereferencedParts" : [ ],
        "name" : "com.datastax.oss.driver.shaded.guava.common.base.Preconditions"
      }, {
        "dereferencedParts" : [ {
          "name" : "Filter",
          "comments" : "Portable runtime generative for metadata filter expressions. This generic generative is\nused to define store agnostic filter expressions than later can be converted into\nvector-store specific, native, expressions.\n\nThe expression generative supports constant comparison\n{@code (e.g. ==, !=, <, <=, >, >=) }, IN/NON-IN checks and AND and OR to compose\nmultiple expressions.\n\nFor example:\n\n<pre>{@code\n// 1: country == \"BG\"\nnew Expression(EQ, new Key(\"country\"), new Value(\"BG\"));\n\n// 2: genre == \"drama\" AND year >= 2020\nnew Expression(AND, new Expression(EQ, new Key(\"genre\"), new Value(\"drama\")),\n\t\tnew Expression(GTE, new Key(\"year\"), new Value(2020)));\n\n// 3: genre in [\"comedy\", \"documentary\", \"drama\"]\nnew Expression(IN, new Key(\"genre\"), new Value(List.of(\"comedy\", \"documentary\", \"drama\")));\n\n// 4: year >= 2020 OR country == \"BG\" AND city != \"Sofia\"\nnew Expression(OR, new Expression(GTE, new Key(\"year\"), new Value(2020)),\n\t\tnew Expression(AND, new Expression(EQ, new Key(\"country\"), new Value(\"BG\")),\n\t\t\t\tnew Expression(NE, new Key(\"city\"), new Value(\"Sofia\"))));\n\n// 5: (year >= 2020 OR country == \"BG\") AND city NIN [\"Sofia\", \"Plovdiv\"]\nnew Expression(AND,\n\t\tnew Group(new Expression(OR, new Expression(EQ, new Key(\"country\"), new Value(\"BG\")),\n\t\t\t\tnew Expression(GTE, new Key(\"year\"), new Value(2020)))),\n\t\tnew Expression(NIN, new Key(\"city\"), new Value(List.of(\"Sofia\", \"Varna\"))));\n\n// 6: isOpen == true AND year >= 2020 AND country IN [\"BG\", \"NL\", \"US\"]\nnew Expression(AND, new Expression(EQ, new Key(\"isOpen\"), new Value(true)),\n\t\tnew Expression(AND, new Expression(GTE, new Key(\"year\"), new Value(2020)),\n\t\t\t\tnew Expression(IN, new Key(\"country\"), new Value(List.of(\"BG\", \"NL\", \"US\")))));\n\n}</pre>\n\n\nUsually you will not create expression manually but use either the\n{@link FilterExpressionBuilder} DSL or the {@link FilterExpressionTextParser} for\nparsing generic text expressions.",
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ ],
          "constructors" : [ ],
          "extends" : [ ],
          "implements" : [ ],
          "nestedClass" : [ {
            "name" : "Operand",
            "comments" : "Mark interface representing the supported expression types: {@link Key},\n{@link Value}, {@link Expression} and {@link Group}.",
            "annotations" : [ ],
            "methods" : [ ],
            "fields" : [ ],
            "constructors" : [ ],
            "extends" : null,
            "implements" : null,
            "nestedClass" : null,
            "accessSpecifier" : "public",
            "records" : null
          } ],
          "accessSpecifier" : "public",
          "records" : null,
          "imports" : [ ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/vectorstore/filter/Filter.java",
        "name" : "org.springframework.ai.vectorstore.filter.Filter"
      }, {
        "dereferencedParts" : [ ],
        "name" : "org.springframework.ai.vectorstore.filter.Filter.ExpressionType"
      }, {
        "dereferencedParts" : [ ],
        "name" : "org.springframework.ai.vectorstore.filter.Filter.Key"
      }, {
        "dereferencedParts" : [ ],
        "name" : "org.springframework.ai.vectorstore.filter.Filter.Value"
      }, {
        "dereferencedParts" : [ {
          "name" : "AbstractFilterExpressionConverter",
          "comments" : "AbstractFilterExpressionConverter is an abstract class that implements the\nFilterExpressionConverter interface. It provides default implementations for converting\na Filter.Expression into a string representation. All specific filter expression\nconverters should extend this abstract class and implement the remaining abstract\nmethods. Note: The class cannot be directly instantiated as it is abstract.",
          "annotations" : [ ],
          "methods" : [ ],
          "fields" : [ ],
          "constructors" : [ {
            "name" : "AbstractFilterExpressionConverter",
            "arguments" : [ ],
            "accessModifier" : "public",
            "methodsCalled" : [ ],
            "usedEntities" : [ ],
            "annotations" : [ ],
            "comments" : "Create a new AbstractFilterExpressionConverter.",
            "methodDefinition" : "public AbstractFilterExpressionConverter() {\n}"
          } ],
          "extends" : [ ],
          "implements" : [ "FilterExpressionConverter" ],
          "nestedClass" : null,
          "accessSpecifier" : "public , abstract",
          "records" : null,
          "imports" : [ {
            "dereferencedParts" : [ ],
            "name" : "java.util.List"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.filter.Filter"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.filter.Filter.Expression"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.filter.Filter.ExpressionType"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.filter.Filter.Group"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.filter.Filter.Operand"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.filter.FilterExpressionConverter"
          }, {
            "dereferencedParts" : [ ],
            "name" : "org.springframework.ai.vectorstore.filter.FilterHelper"
          } ]
        } ],
        "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/spring-ai-core/src/main/java/org/springframework/ai/vectorstore/filter/converter/AbstractFilterExpressionConverter.java",
        "name" : "org.springframework.ai.vectorstore.filter.converter.AbstractFilterExpressionConverter"
      } ],
      "classes" : [ {
        "name" : "CassandraFilterExpressionConverter",
        "comments" : "Converts {@link org.springframework.ai.vectorstore.filter.Filter.Expression} into CQL\nwhere clauses.",
        "annotations" : [ ],
        "methods" : [ {
          "name" : "doOperand",
          "arguments" : [ "ExpressionType type", "StringBuilder context" ],
          "accessModifier" : "private,static",
          "methodsCalled" : [ {
            "name" : "append",
            "arguments" : [ "\" = \"" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "\" != \"" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "\" > \"" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "\" >= \"" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "\" IN \"" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "\" < \"" ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "\" <= \"" ],
            "body" : ""
          }, {
            "name" : "format",
            "arguments" : [ "\"Expression type %s not yet implemented. Patches welcome.\"", "type" ],
            "body" : ""
          } ],
          "usedEntities" : [ "type", "EQ", "context", "NE", "GT", "GTE", "IN", "LT", "LTE", "String" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "private static void doOperand(ExpressionType type, StringBuilder context) {\n    switch(type) {\n        case EQ ->\n            context.append(\" = \");\n        case NE ->\n            context.append(\" != \");\n        case GT ->\n            context.append(\" > \");\n        case GTE ->\n            context.append(\" >= \");\n        case IN ->\n            context.append(\" IN \");\n        case LT ->\n            context.append(\" < \");\n        case LTE ->\n            context.append(\" <= \");\n        \n        \n        \n        \n        default ->\n            throw new UnsupportedOperationException(String.format(\"Expression type %s not yet implemented. Patches welcome.\", type));\n    }\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraFilterExpressionConverter.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "doKey",
          "arguments" : [ "Key key", "StringBuilder context" ],
          "accessModifier" : "protected",
          "methodsCalled" : [ {
            "name" : "key",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getColumn",
            "arguments" : [ "keyName" ],
            "body" : "private Optional<ColumnMetadata> getColumn(String name) {\n    Optional<ColumnMetadata> column = Optional.ofNullable(this.columnsByName.get(name));\n    \n    \n    if (column.isEmpty()) {\n        if (name.startsWith(\"\\\"\") && name.endsWith(\"\\\"\")) {\n            name = name.substring(1, name.length() - 1);\n            column = Optional.ofNullable(this.columnsByName.get(name));\n        }\n    }\n    return column;\n}"
          }, {
            "name" : "checkArgument",
            "arguments" : [ "column.isPresent()", "\"No metafield %s has been configured\"", "keyName" ],
            "body" : ""
          }, {
            "name" : "isPresent",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "column.get().getName().asCql(false)" ],
            "body" : ""
          }, {
            "name" : "asCql",
            "arguments" : [ "false" ],
            "body" : ""
          }, {
            "name" : "getName",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "key", "keyName", "Preconditions", "column", "context" ],
          "annotations" : [ "Override" ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "@Override\nprotected void doKey(Key key, StringBuilder context) {\n    String keyName = key.key();\n    Optional<ColumnMetadata> column = getColumn(keyName);\n    Preconditions.checkArgument(column.isPresent(), \"No metafield %s has been configured\", keyName);\n    context.append(column.get().getName().asCql(false));\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraFilterExpressionConverter.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "doExpression",
          "arguments" : [ "Filter.Expression expression", "StringBuilder context" ],
          "accessModifier" : "protected",
          "methodsCalled" : [ {
            "name" : "type",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "doBinaryOperation",
            "arguments" : [ "\" and \"", "expression", "context" ],
            "body" : "private void doBinaryOperation(String operator, Filter.Expression expression, StringBuilder context) {\n    this.convertOperand(expression.left(), context);\n    context.append(operator);\n    this.convertOperand(expression.right(), context);\n}"
          }, {
            "name" : "doBinaryOperation",
            "arguments" : [ "\" or \"", "expression", "context" ],
            "body" : "private void doBinaryOperation(String operator, Filter.Expression expression, StringBuilder context) {\n    this.convertOperand(expression.left(), context);\n    context.append(operator);\n    this.convertOperand(expression.right(), context);\n}"
          }, {
            "name" : "format",
            "arguments" : [ "\"Expression type %s not yet implemented. Patches welcome.\"", "expression.type()" ],
            "body" : ""
          }, {
            "name" : "type",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "doField",
            "arguments" : [ "expression", "context" ],
            "body" : "private void doField(Filter.Expression expression, StringBuilder context) {\n    doKey((Key) expression.left(), context);\n    doOperand(expression.type(), context);\n    ColumnMetadata column = getColumn(((Key) expression.left()).key()).get();\n    var v = ((Value) expression.right()).value();\n    if (ExpressionType.IN.equals(expression.type())) {\n        Preconditions.checkArgument(v instanceof Collection);\n        doListValue(column, v, context);\n    } else {\n        doValue(column, v, context);\n    }\n}"
          } ],
          "usedEntities" : [ "expression", "AND", "context", "OR", "NIN", "NOT", "String" ],
          "annotations" : [ "Override" ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "@Override\nprotected void doExpression(Filter.Expression expression, StringBuilder context) {\n    switch(expression.type()) {\n        case AND ->\n            doBinaryOperation(\" and \", expression, context);\n        case OR ->\n            doBinaryOperation(\" or \", expression, context);\n        case NIN, NOT ->\n            throw new UnsupportedOperationException(String.format(\"Expression type %s not yet implemented. Patches welcome.\", expression.type()));\n        default ->\n            doField(expression, context);\n    }\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraFilterExpressionConverter.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "doBinaryOperation",
          "arguments" : [ "String operator", "Filter.Expression expression", "StringBuilder context" ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "convertOperand",
            "arguments" : [ "expression.left()", "context" ],
            "body" : ""
          }, {
            "name" : "left",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "operator" ],
            "body" : ""
          }, {
            "name" : "convertOperand",
            "arguments" : [ "expression.right()", "context" ],
            "body" : ""
          }, {
            "name" : "right",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "expression", "context", "operator" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "private void doBinaryOperation(String operator, Filter.Expression expression, StringBuilder context) {\n    this.convertOperand(expression.left(), context);\n    context.append(operator);\n    this.convertOperand(expression.right(), context);\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraFilterExpressionConverter.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "doField",
          "arguments" : [ "Filter.Expression expression", "StringBuilder context" ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "doKey",
            "arguments" : [ "(Key) expression.left()", "context" ],
            "body" : "@Override\nprotected void doKey(Key key, StringBuilder context) {\n    String keyName = key.key();\n    Optional<ColumnMetadata> column = getColumn(keyName);\n    Preconditions.checkArgument(column.isPresent(), \"No metafield %s has been configured\", keyName);\n    context.append(column.get().getName().asCql(false));\n}"
          }, {
            "name" : "left",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "doOperand",
            "arguments" : [ "expression.type()", "context" ],
            "body" : "private static void doOperand(ExpressionType type, StringBuilder context) {\n    switch(type) {\n        case EQ ->\n            context.append(\" = \");\n        case NE ->\n            context.append(\" != \");\n        case GT ->\n            context.append(\" > \");\n        case GTE ->\n            context.append(\" >= \");\n        case IN ->\n            context.append(\" IN \");\n        case LT ->\n            context.append(\" < \");\n        case LTE ->\n            context.append(\" <= \");\n        \n        \n        \n        \n        default ->\n            throw new UnsupportedOperationException(String.format(\"Expression type %s not yet implemented. Patches welcome.\", type));\n    }\n}"
          }, {
            "name" : "type",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getColumn",
            "arguments" : [ "((Key) expression.left()).key()" ],
            "body" : "private Optional<ColumnMetadata> getColumn(String name) {\n    Optional<ColumnMetadata> column = Optional.ofNullable(this.columnsByName.get(name));\n    \n    \n    if (column.isEmpty()) {\n        if (name.startsWith(\"\\\"\") && name.endsWith(\"\\\"\")) {\n            name = name.substring(1, name.length() - 1);\n            column = Optional.ofNullable(this.columnsByName.get(name));\n        }\n    }\n    return column;\n}"
          }, {
            "name" : "key",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "left",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "value",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "right",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "equals",
            "arguments" : [ "expression.type()" ],
            "body" : ""
          }, {
            "name" : "type",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "checkArgument",
            "arguments" : [ "v instanceof Collection" ],
            "body" : ""
          }, {
            "name" : "doListValue",
            "arguments" : [ "column", "v", "context" ],
            "body" : "private void doListValue(ColumnMetadata column, Object v, StringBuilder context) {\n    context.append('(');\n    for (var e : (Collection) v) {\n        doValue(column, e, context);\n        context.append(',');\n    }\n    context.deleteCharAt(context.length() - 1);\n    context.append(')');\n}"
          }, {
            "name" : "doValue",
            "arguments" : [ "column", "v", "context" ],
            "body" : "private void doValue(ColumnMetadata column, Object v, StringBuilder context) {\n    if (DataTypes.SMALLINT.equals(column.getType())) {\n        v = ((Number) v).shortValue();\n    }\n    context.append(CodecRegistry.DEFAULT.codecFor(column.getType()).format(v));\n}"
          } ],
          "usedEntities" : [ "expression", "context", "ExpressionType", "Preconditions", "v", "column" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "private void doField(Filter.Expression expression, StringBuilder context) {\n    doKey((Key) expression.left(), context);\n    doOperand(expression.type(), context);\n    ColumnMetadata column = getColumn(((Key) expression.left()).key()).get();\n    var v = ((Value) expression.right()).value();\n    if (ExpressionType.IN.equals(expression.type())) {\n        Preconditions.checkArgument(v instanceof Collection);\n        doListValue(column, v, context);\n    } else {\n        doValue(column, v, context);\n    }\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraFilterExpressionConverter.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "doListValue",
          "arguments" : [ "ColumnMetadata column", "Object v", "StringBuilder context" ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "append",
            "arguments" : [ "'('" ],
            "body" : ""
          }, {
            "name" : "doValue",
            "arguments" : [ "column", "e", "context" ],
            "body" : "private void doValue(ColumnMetadata column, Object v, StringBuilder context) {\n    if (DataTypes.SMALLINT.equals(column.getType())) {\n        v = ((Number) v).shortValue();\n    }\n    context.append(CodecRegistry.DEFAULT.codecFor(column.getType()).format(v));\n}"
          }, {
            "name" : "append",
            "arguments" : [ "','" ],
            "body" : ""
          }, {
            "name" : "deleteCharAt",
            "arguments" : [ "context.length() - 1" ],
            "body" : ""
          }, {
            "name" : "length",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "')'" ],
            "body" : ""
          } ],
          "usedEntities" : [ "context", "v", "column", "e" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "private void doListValue(ColumnMetadata column, Object v, StringBuilder context) {\n    context.append('(');\n    for (var e : (Collection) v) {\n        doValue(column, e, context);\n        context.append(',');\n    }\n    context.deleteCharAt(context.length() - 1);\n    context.append(')');\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraFilterExpressionConverter.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "doValue",
          "arguments" : [ "ColumnMetadata column", "Object v", "StringBuilder context" ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "equals",
            "arguments" : [ "column.getType()" ],
            "body" : ""
          }, {
            "name" : "getType",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "shortValue",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "append",
            "arguments" : [ "CodecRegistry.DEFAULT.codecFor(column.getType()).format(v)" ],
            "body" : ""
          }, {
            "name" : "format",
            "arguments" : [ "v" ],
            "body" : ""
          }, {
            "name" : "codecFor",
            "arguments" : [ "column.getType()" ],
            "body" : ""
          }, {
            "name" : "getType",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "DataTypes", "column", "v", "context", "CodecRegistry" ],
          "annotations" : [ ],
          "returnType" : "void",
          "comments" : null,
          "methodDefinition" : "private void doValue(ColumnMetadata column, Object v, StringBuilder context) {\n    if (DataTypes.SMALLINT.equals(column.getType())) {\n        v = ((Number) v).shortValue();\n    }\n    context.append(CodecRegistry.DEFAULT.codecFor(column.getType()).format(v));\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraFilterExpressionConverter.java",
          "test_exists" : false,
          "test_functions" : { }
        }, {
          "name" : "getColumn",
          "arguments" : [ "String name" ],
          "accessModifier" : "private",
          "methodsCalled" : [ {
            "name" : "ofNullable",
            "arguments" : [ "this.columnsByName.get(name)" ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "name" ],
            "body" : ""
          }, {
            "name" : "isEmpty",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "startsWith",
            "arguments" : [ "\"\\\"\"" ],
            "body" : ""
          }, {
            "name" : "endsWith",
            "arguments" : [ "\"\\\"\"" ],
            "body" : ""
          }, {
            "name" : "substring",
            "arguments" : [ "1", "name.length() - 1" ],
            "body" : ""
          }, {
            "name" : "length",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "ofNullable",
            "arguments" : [ "this.columnsByName.get(name)" ],
            "body" : ""
          }, {
            "name" : "get",
            "arguments" : [ "name" ],
            "body" : ""
          } ],
          "usedEntities" : [ "Optional", "name", "column" ],
          "annotations" : [ ],
          "returnType" : "Optional<ColumnMetadata>",
          "comments" : null,
          "methodDefinition" : "private Optional<ColumnMetadata> getColumn(String name) {\n    Optional<ColumnMetadata> column = Optional.ofNullable(this.columnsByName.get(name));\n    \n    \n    if (column.isEmpty()) {\n        if (name.startsWith(\"\\\"\") && name.endsWith(\"\\\"\")) {\n            name = name.substring(1, name.length() - 1);\n            column = Optional.ofNullable(this.columnsByName.get(name));\n        }\n    }\n    return column;\n}",
          "filePath" : "/var/tmp/Roost/RoostGPT/amanProjectPath10thJuly/80ee687d-515d-4bc5-b800-9ecb69eaa8f8/source/spring-ai/vector-stores/spring-ai-cassandra-store/src/main/java/org/springframework/ai/vectorstore/cassandra/CassandraFilterExpressionConverter.java",
          "test_exists" : false,
          "test_functions" : { }
        } ],
        "fields" : [ {
          "name" : "columnsByName",
          "accessModifier" : "private,final",
          "value" : null,
          "type" : "Map<String,ColumnMetadata>",
          "comments" : null
        } ],
        "constructors" : [ {
          "name" : "CassandraFilterExpressionConverter",
          "arguments" : [ "Collection<ColumnMetadata> columns" ],
          "accessModifier" : "",
          "methodsCalled" : [ {
            "name" : "collect",
            "arguments" : [ "Collectors.toMap(c -> c.getName().asInternal(), Function.identity())" ],
            "body" : ""
          }, {
            "name" : "stream",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "toMap",
            "arguments" : [ "c -> c.getName().asInternal()", "Function.identity()" ],
            "body" : ""
          }, {
            "name" : "asInternal",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "getName",
            "arguments" : [ ],
            "body" : ""
          }, {
            "name" : "identity",
            "arguments" : [ ],
            "body" : ""
          } ],
          "usedEntities" : [ "columns", "Collectors", "c", "Function" ],
          "annotations" : [ ],
          "comments" : null,
          "methodDefinition" : "CassandraFilterExpressionConverter(Collection<ColumnMetadata> columns) {\n    this.columnsByName = columns.stream().collect(Collectors.toMap(c -> c.getName().asInternal(), Function.identity()));\n}"
        } ],
        "extends" : [ "AbstractFilterExpressionConverter" ],
        "implements" : [ ],
        "nestedClass" : null,
        "accessSpecifier" : "",
        "records" : [ ]
      } ],
      "records" : [ ],
      "samePackageClasses" : [ ]
    }
  }
}